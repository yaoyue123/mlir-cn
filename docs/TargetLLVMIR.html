<!DOCTYPE html>
<html  lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

      <title>LLVM IR Target</title>
    
          <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
          <link rel="stylesheet" href="../_static/theme.css " type="text/css" />
      
      <!-- sphinx script_files -->
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script src="../_static/translations.js"></script>

      
      <!-- bundled in js (rollup iife) -->
      <!-- <script src="../_static/theme-vendors.js"></script> -->
      <script src="../_static/theme.js" defer></script>
    
  <link rel="index" title="索引" href="../genindex.html" />
  <link rel="search" title="搜索" href="../search.html" /> 
  </head>

  <body>
    <div id="app">
    <div class="theme-container" :class="pageClasses"><navbar @toggle-sidebar="toggleSidebar">
  <router-link to="../index.html" class="home-link">
    
      <span class="site-name">MLIR 中文文档</span>
    
  </router-link>

  <div class="links">
    <navlinks class="can-hide">



    </navlinks>
  </div>
</navbar>

      
      <div class="sidebar-mask" @click="toggleSidebar(false)">
      </div>
        <sidebar @toggle-sidebar="toggleSidebar">
          
          <navlinks>
            



            
          </navlinks><div id="searchbox" class="searchbox" role="search">
  <div class="caption"><span class="caption-text">快速搜索</span>
    <div class="searchformwrapper">
      <form class="search" action="../search.html" method="get">
        <input type="text" name="q" />
        <input type="submit" value="搜索" />
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div><div class="sidebar-links" role="navigation" aria-label="main navigation">
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../index.html#mlir">欢迎使用 mlir 中文文档</a></span>
      </p>
      <ul class="">
        
          <li class="toctree-l1 ">
            
              <a href="../_index.html" class="reference internal ">开始使用MLIR</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/CreatingADialect.html" class="reference internal ">Creating a Dialect</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/DataFlowAnalysis.html" class="reference internal ">Writing DataFlow Analyses in MLIR</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/QuickstartRewrites.html" class="reference internal ">Quickstart tutorial to adding MLIR graph rewrite</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-1.html" class="reference internal ">第1章：Toy语言和AST（抽象语法树）</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-2.html" class="reference internal ">Chapter 2: Emitting Basic MLIR</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-3.html" class="reference internal ">Chapter 3: High-level Language-Specific Analysis and Transformation</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-4.html" class="reference internal ">Chapter 4: Enabling Generic Transformation with Interfaces</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-5.html" class="reference internal ">Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-6.html" class="reference internal ">Chapter 6: Lowering to LLVM and CodeGeneration</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-7.html" class="reference internal ">Chapter 7: Adding a Composite Type to Toy</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/_index.html" class="reference internal ">Toy 入门教程</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/UnderstandingTheIRStructure.html" class="reference internal ">Understanding the IR Structure</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/_index.html" class="reference internal ">Tutorials</a>
            

            
          </li>

        
      </ul>
    </div>
  
</div>
        </sidebar>

      <page>
          <div class="body-header" role="navigation" aria-label="navigation">
  
  <ul class="breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
    
    <li>LLVM IR Target</li>
  </ul>
  

  <ul class="page-nav">
</ul>
  
</div>
<hr>
          <div class="content" role="main" v-pre>
            
  <section id="llvm-ir-target">
<h1>LLVM IR Target<a class="headerlink" href="#llvm-ir-target" title="此标题的永久链接">¶</a></h1>
<p>This document describes the mechanisms of producing LLVM IR from MLIR. The
overall flow is two-stage:</p>
<ol class="simple">
<li><p><strong>conversion</strong> of the IR to a set of dialects translatable to LLVM IR, for
example <a class="reference internal" href="Dialects/LLVM.html"><span class="doc">LLVM Dialect</span></a> or one of the hardware-specific
dialects derived from LLVM IR intrinsics such as <a class="reference external" href="Dialects/AMX">AMX</a>,
<a class="reference external" href="Dialects/X86Vector">X86Vector</a> or <a class="reference external" href="Dialects/ArmNeon">ArmNeon</a>;</p></li>
<li><p><strong>translation</strong> of MLIR dialects to LLVM IR.</p></li>
</ol>
<p>This flow allows the non-trivial transformation to be performed within MLIR
using MLIR APIs and makes the translation between MLIR and LLVM IR <em>simple</em> and
potentially bidirectional. As a corollary, dialect ops translatable to LLVM IR
are expected to closely match the corresponding LLVM IR instructions and
intrinsics. This minimizes the dependency on LLVM IR libraries in MLIR as well
as reduces the churn in case of changes.</p>
<p>Note that many different dialects can be lowered to LLVM but are provided as
different sets of patterns and have different passes available to mlir-opt.
However, this is primarily useful for testing and prototyping, and using the
collection of patterns together is highly recommended. One place this is
important and visible is the ControlFlow dialect’s branching operations which
will fail to apply if their types mismatch with the blocks they jump to in the
parent op.</p>
<p>SPIR-V to LLVM dialect conversion has a
<a class="reference internal" href="SPIRVToLLVMDialectConversion.html"><span class="doc">dedicated document</span></a>.</p>
<p>[TOC]</p>
<section id="conversion-to-the-llvm-dialect">
<h2>Conversion to the LLVM Dialect<a class="headerlink" href="#conversion-to-the-llvm-dialect" title="此标题的永久链接">¶</a></h2>
<p>Conversion to the LLVM dialect from other dialects is the first step to produce
LLVM IR. All non-trivial IR modifications are expected to happen at this stage
or before. The conversion is <em>progressive</em>: most passes convert one dialect to
the LLVM dialect and keep operations from other dialects intact. For example,
the <code class="docutils literal notranslate"><span class="pre">-finalize-memref-to-llvm</span></code> pass will only convert operations from the
<code class="docutils literal notranslate"><span class="pre">memref</span></code> dialect but will not convert operations from other dialects even if
they use or produce <code class="docutils literal notranslate"><span class="pre">memref</span></code>-typed values.</p>
<p>The process relies on the <a class="reference internal" href="DialectConversion.html"><span class="doc">Dialect Conversion</span></a>
infrastructure and, in particular, on the
<a class="reference external" href="DialectConversion.md#type-conversion">materialization</a> hooks of <code class="docutils literal notranslate"><span class="pre">TypeConverter</span></code>
to support progressive lowering by injecting <code class="docutils literal notranslate"><span class="pre">unrealized_conversion_cast</span></code>
operations between converted and unconverted operations. After multiple partial
conversions to the LLVM dialect are performed, the cast operations that became
noop can be removed by the <code class="docutils literal notranslate"><span class="pre">-reconcile-unrealized-casts</span></code> pass. The latter pass
is not specific to the LLVM dialect and can remove any noop casts.</p>
<section id="conversion-of-built-in-types">
<h3>Conversion of Built-in Types<a class="headerlink" href="#conversion-of-built-in-types" title="此标题的永久链接">¶</a></h3>
<p>Built-in types have a default conversion to LLVM dialect types provided by the
<code class="docutils literal notranslate"><span class="pre">LLVMTypeConverter</span></code> class. Users targeting the LLVM dialect can reuse and extend
this type converter to support other types. Extra care must be taken if the
conversion rules for built-in types are overridden: all conversion must use the
same type converter.</p>
<section id="llvm-dialect-compatible-types">
<h4>LLVM Dialect-compatible Types<a class="headerlink" href="#llvm-dialect-compatible-types" title="此标题的永久链接">¶</a></h4>
<p>The types <a class="reference external" href="Dialects/LLVM.md#built-in-type-compatibility">compatible</a> with the
LLVM dialect are kept as is.</p>
</section>
<section id="complex-type">
<h4>Complex Type<a class="headerlink" href="#complex-type" title="此标题的永久链接">¶</a></h4>
<p>Complex type is converted into an LLVM dialect literal structure type with two
elements:</p>
<ul class="simple">
<li><p>real part;</p></li>
<li><p>imaginary part.</p></li>
</ul>
<p>The elemental type is converted recursively using these rules.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  complex&lt;f32&gt;
  // -&gt;
  !llvm.struct&lt;(f32, f32)&gt;
</pre></div>
</div>
</section>
<section id="index-type">
<h4>Index Type<a class="headerlink" href="#index-type" title="此标题的永久链接">¶</a></h4>
<p>Index type is converted into an LLVM dialect integer type with the bitwidth
specified by the <a class="reference internal" href="DataLayout.html"><span class="doc">data layout</span></a> of the closest module. For
example, on x86-64 CPUs it converts to i64. This behavior can be overridden by
the type converter configuration, which is often exposed as a pass option by
conversion passes.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  index
  // -&gt; on x86_64
  i64
</pre></div>
</div>
</section>
<section id="ranked-memref-types">
<h4>Ranked MemRef Types<a class="headerlink" href="#ranked-memref-types" title="此标题的永久链接">¶</a></h4>
<p>Ranked memref types are converted into an LLVM dialect literal structure type
that contains the dynamic information associated with the memref object,
referred to as <em>descriptor</em>. Only memrefs in the
<strong><a class="reference external" href="Dialects/Builtin.md/#strided-memref">strided form</a></strong> can be converted to the
LLVM dialect with the default descriptor format. Memrefs with other, less
trivial layouts should be converted into the strided form first, e.g., by
materializing the non-trivial address remapping due to layout as <code class="docutils literal notranslate"><span class="pre">affine.apply</span></code>
operations.</p>
<p>The default memref descriptor is a struct with the following fields:</p>
<ol class="simple">
<li><p>The pointer to the data buffer as allocated, referred to as “allocated
pointer”. This is only useful for deallocating the memref.</p></li>
<li><p>The pointer to the properly aligned data pointer that the memref indexes,
referred to as “aligned pointer”.</p></li>
<li><p>A lowered converted <code class="docutils literal notranslate"><span class="pre">index</span></code>-type integer containing the distance in number
of elements between the beginning of the (aligned) buffer and the first
element to be accessed through the memref, referred to as “offset”.</p></li>
<li><p>An array containing as many converted <code class="docutils literal notranslate"><span class="pre">index</span></code>-type integers as the rank of
the memref: the array represents the size, in number of elements, of the
memref along the given dimension.</p></li>
<li><p>A second array containing as many converted <code class="docutils literal notranslate"><span class="pre">index</span></code>-type integers as the
rank of memref: the second array represents the “stride” (in tensor
abstraction sense), i.e. the number of consecutive elements of the
underlying buffer one needs to jump over to get to the next logically
indexed element.</p></li>
</ol>
<p>For constant memref dimensions, the corresponding size entry is a constant whose
runtime value matches the static value. This normalization serves as an ABI for
the memref type to interoperate with externally linked functions. In the
particular case of rank <code class="docutils literal notranslate"><span class="pre">0</span></code> memrefs, the size and stride arrays are omitted,
resulting in a struct containing two pointers + offset.</p>
<p>Examples:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>// Assuming index is converted to i64.

memref&lt;f32&gt; -&gt; !llvm.struct&lt;(ptr&lt;f32&gt; , ptr&lt;f32&gt;, i64)&gt;
memref&lt;1 x f32&gt; -&gt; !llvm.struct&lt;(ptr&lt;f32&gt;, ptr&lt;f32&gt;, i64,
                                 array&lt;1 x 64&gt;, array&lt;1 x i64&gt;)&gt;
memref&lt;? x f32&gt; -&gt; !llvm.struct&lt;(ptr&lt;f32&gt;, ptr&lt;f32&gt;, i64
                                 array&lt;1 x 64&gt;, array&lt;1 x i64&gt;)&gt;
memref&lt;10x42x42x43x123 x f32&gt; -&gt; !llvm.struct&lt;(ptr&lt;f32&gt;, ptr&lt;f32&gt;, i64
                                               array&lt;5 x 64&gt;, array&lt;5 x i64&gt;)&gt;
memref&lt;10x?x42x?x123 x f32&gt; -&gt; !llvm.struct&lt;(ptr&lt;f32&gt;, ptr&lt;f32&gt;, i64
                                             array&lt;5 x 64&gt;, array&lt;5 x i64&gt;)&gt;

// Memref types can have vectors as element types
memref&lt;1x? x vector&lt;4xf32&gt;&gt; -&gt; !llvm.struct&lt;(ptr&lt;vector&lt;4 x f32&gt;&gt;,
                                             ptr&lt;vector&lt;4 x f32&gt;&gt;, i64,
                                             array&lt;2 x i64&gt;, array&lt;2 x i64&gt;)&gt;
</pre></div>
</div>
</section>
<section id="unranked-memref-types">
<h4>Unranked MemRef Types<a class="headerlink" href="#unranked-memref-types" title="此标题的永久链接">¶</a></h4>
<p>Unranked memref types are converted to LLVM dialect literal structure type that
contains the dynamic information associated with the memref object, referred to
as <em>unranked descriptor</em>. It contains:</p>
<ol class="simple">
<li><p>a converted <code class="docutils literal notranslate"><span class="pre">index</span></code>-typed integer representing the dynamic rank of the
memref;</p></li>
<li><p>a type-erased pointer (<code class="docutils literal notranslate"><span class="pre">!llvm.ptr&lt;i8&gt;</span></code>) to a ranked memref descriptor with
the contents listed above.</p></li>
</ol>
<p>This descriptor is primarily intended for interfacing with rank-polymorphic
library functions. The pointer to the ranked memref descriptor points to some
<em>allocated</em> memory, which may reside on stack of the current function or in
heap. Conversion patterns for operations producing unranked memrefs are expected
to manage the allocation. Note that this may lead to stack allocations
(<code class="docutils literal notranslate"><span class="pre">llvm.alloca</span></code>) being performed in a loop and not reclaimed until the end of the
current function.</p>
</section>
<section id="function-types">
<h4>Function Types<a class="headerlink" href="#function-types" title="此标题的永久链接">¶</a></h4>
<p>Function types are converted to LLVM dialect function types as follows:</p>
<ul class="simple">
<li><p>function argument and result types are converted recursively using these
rules;</p></li>
<li><p>if a function type has multiple results, they are wrapped into an LLVM
dialect literal structure type since LLVM function types must have exactly
one result;</p></li>
<li><p>if a function type has no results, the corresponding LLVM dialect function
type will have one <code class="docutils literal notranslate"><span class="pre">!llvm.void</span></code> result since LLVM function types must have a
result;</p></li>
<li><p>function types used in arguments of another function type are wrapped in an
LLVM dialect pointer type to comply with LLVM IR expectations;</p></li>
<li><p>the structs corresponding to <code class="docutils literal notranslate"><span class="pre">memref</span></code> types, both ranked and unranked,
appearing as function arguments are unbundled into individual function
arguments to allow for specifying metadata such as aliasing information on
individual pointers;</p></li>
<li><p>the conversion of <code class="docutils literal notranslate"><span class="pre">memref</span></code>-typed arguments is subject to
<a class="reference external" href="TargetLLVMIR.md#calling-conventions">calling conventions</a>.</p></li>
<li><p>if a function type has boolean attribute <code class="docutils literal notranslate"><span class="pre">func.varargs</span></code> being set, the
converted LLVM function will be variadic.</p></li>
</ul>
<p>Examples:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>// Zero-ary function type with no results:
() -&gt; ()
// is converted to a zero-ary function with `void` result.
!llvm.func&lt;void ()&gt;

// Unary function with one result:
(i32) -&gt; (i64)
// has its argument and result type converted, before creating the LLVM dialect
// function type.
!llvm.func&lt;i64 (i32)&gt;

// Binary function with one result:
(i32, f32) -&gt; (i64)
// has its arguments handled separately
!llvm.func&lt;i64 (i32, f32)&gt;

// Binary function with two results:
(i32, f32) -&gt; (i64, f64)
// has its result aggregated into a structure type.
!llvm.func&lt;struct&lt;(i64, f64)&gt; (i32, f32)&gt;

// Function-typed arguments or results in higher-order functions:
(() -&gt; ()) -&gt; (() -&gt; ())
// are converted into pointers to functions.
!llvm.func&lt;ptr&lt;func&lt;void ()&gt;&gt; (ptr&lt;func&lt;void ()&gt;&gt;)&gt;

// These rules apply recursively: a function type taking a function that takes
// another function
( ( (i32) -&gt; (i64) ) -&gt; () ) -&gt; ()
// is converted into a function type taking a pointer-to-function that takes
// another point-to-function.
!llvm.func&lt;void (ptr&lt;func&lt;void (ptr&lt;func&lt;i64 (i32)&gt;&gt;)&gt;&gt;)&gt;

// A memref descriptor appearing as function argument:
(memref&lt;f32&gt;) -&gt; ()
// gets converted into a list of individual scalar components of a descriptor.
!llvm.func&lt;void (ptr&lt;f32&gt;, ptr&lt;f32&gt;, i64)&gt;

// The list of arguments is linearized and one can freely mix memref and other
// types in this list:
(memref&lt;f32&gt;, f32) -&gt; ()
// which gets converted into a flat list.
!llvm.func&lt;void (ptr&lt;f32&gt;, ptr&lt;f32&gt;, i64, f32)&gt;

// For nD ranked memref descriptors:
(memref&lt;?x?xf32&gt;) -&gt; ()
// the converted signature will contain 2n+1 `index`-typed integer arguments,
// offset, n sizes and n strides, per memref argument type.
!llvm.func&lt;void (ptr&lt;f32&gt;, ptr&lt;f32&gt;, i64, i64, i64, i64, i64)&gt;

// Same rules apply to unranked descriptors:
(memref&lt;*xf32&gt;) -&gt; ()
// which get converted into their components.
!llvm.func&lt;void (i64, ptr&lt;i8&gt;)&gt;

// However, returning a memref from a function is not affected:
() -&gt; (memref&lt;?xf32&gt;)
// gets converted to a function returning a descriptor structure.
!llvm.func&lt;struct&lt;(ptr&lt;f32&gt;, ptr&lt;f32&gt;, i64, array&lt;1xi64&gt;, array&lt;1xi64&gt;)&gt; ()&gt;

// If multiple memref-typed results are returned:
() -&gt; (memref&lt;f32&gt;, memref&lt;f64&gt;)
// their descriptor structures are additionally packed into another structure,
// potentially with other non-memref typed results.
!llvm.func&lt;struct&lt;(struct&lt;(ptr&lt;f32&gt;, ptr&lt;f32&gt;, i64)&gt;,
                   struct&lt;(ptr&lt;double&gt;, ptr&lt;double&gt;, i64)&gt;)&gt; ()&gt;

// If &quot;func.varargs&quot; attribute is set:
(i32) -&gt; () attributes { &quot;func.varargs&quot; = true }
// the corresponding LLVM function will be variadic:
!llvm.func&lt;void (i32, ...)&gt;
</pre></div>
</div>
<p>Conversion patterns are available to convert built-in function operations and
standard call operations targeting those functions using these conversion rules.</p>
</section>
<section id="multi-dimensional-vector-types">
<h4>Multi-dimensional Vector Types<a class="headerlink" href="#multi-dimensional-vector-types" title="此标题的永久链接">¶</a></h4>
<p>LLVM IR only supports <em>one-dimensional</em> vectors, unlike MLIR where vectors can
be multi-dimensional. Vector types cannot be nested in either IR. In the
one-dimensional case, MLIR vectors are converted to LLVM IR vectors of the same
size with element type converted using these conversion rules. In the
n-dimensional case, MLIR vectors are converted to (n-1)-dimensional array types
of one-dimensional vectors.</p>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>vector&lt;4x8 x f32&gt;
// -&gt;
!llvm.array&lt;4 x vector&lt;8 x f32&gt;&gt;

memref&lt;2 x vector&lt;4x8 x f32&gt;
// -&gt;
!llvm.struct&lt;(ptr&lt;array&lt;4 x vector&lt;8xf32&gt;&gt;&gt;, ptr&lt;array&lt;4 x vector&lt;8xf32&gt;&gt;&gt;
              i64, array&lt;1 x i64&gt;, array&lt;1 x i64&gt;)&gt;
</pre></div>
</div>
</section>
<section id="tensor-types">
<h4>Tensor Types<a class="headerlink" href="#tensor-types" title="此标题的永久链接">¶</a></h4>
<p>Tensor types cannot be converted to the LLVM dialect. Operations on tensors must
be <a class="reference internal" href="Bufferization.html"><span class="doc">bufferized</span></a> before being converted.</p>
</section>
</section>
<section id="calling-conventions">
<h3>Calling Conventions<a class="headerlink" href="#calling-conventions" title="此标题的永久链接">¶</a></h3>
<p>Calling conventions provides a mechanism to customize the conversion of function
and function call operations without changing how individual types are handled
elsewhere. They are implemented simultaneously by the default type converter and
by the conversion patterns for the relevant operations.</p>
<section id="function-result-packing">
<h4>Function Result Packing<a class="headerlink" href="#function-result-packing" title="此标题的永久链接">¶</a></h4>
<p>In case of multi-result functions, the returned values are inserted into a
structure-typed value before being returned and extracted from it at the call
site. This transformation is a part of the conversion and is transparent to the
defines and uses of the values being returned.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>func.func @foo(%arg0: i32, %arg1: i64) -&gt; (i32, i64) {
  return %arg0, %arg1 : i32, i64
}
func.func @bar() {
  %0 = arith.constant 42 : i32
  %1 = arith.constant 17 : i64
  %2:2 = call @foo(%0, %1) : (i32, i64) -&gt; (i32, i64)
  &quot;use_i32&quot;(%2#0) : (i32) -&gt; ()
  &quot;use_i64&quot;(%2#1) : (i64) -&gt; ()
}

// is transformed into

llvm.func @foo(%arg0: i32, %arg1: i64) -&gt; !llvm.struct&lt;(i32, i64)&gt; {
  // insert the vales into a structure
  %0 = llvm.mlir.undef : !llvm.struct&lt;(i32, i64)&gt;
  %1 = llvm.insertvalue %arg0, %0[0] : !llvm.struct&lt;(i32, i64)&gt;
  %2 = llvm.insertvalue %arg1, %1[1] : !llvm.struct&lt;(i32, i64)&gt;

  // return the structure value
  llvm.return %2 : !llvm.struct&lt;(i32, i64)&gt;
}
llvm.func @bar() {
  %0 = llvm.mlir.constant(42 : i32) : i32
  %1 = llvm.mlir.constant(17) : i64

  // call and extract the values from the structure
  %2 = llvm.call @bar(%0, %1)
     : (i32, i32) -&gt; !llvm.struct&lt;(i32, i64)&gt;
  %3 = llvm.extractvalue %2[0] : !llvm.struct&lt;(i32, i64)&gt;
  %4 = llvm.extractvalue %2[1] : !llvm.struct&lt;(i32, i64)&gt;

  // use as before
  &quot;use_i32&quot;(%3) : (i32) -&gt; ()
  &quot;use_i64&quot;(%4) : (i64) -&gt; ()
}
</pre></div>
</div>
</section>
<section id="default-calling-convention-for-ranked-memref">
<h4>Default Calling Convention for Ranked MemRef<a class="headerlink" href="#default-calling-convention-for-ranked-memref" title="此标题的永久链接">¶</a></h4>
<p>The default calling convention converts <code class="docutils literal notranslate"><span class="pre">memref</span></code>-typed function arguments to
LLVM dialect literal structs
<a class="reference external" href="TargetLLVMIR.md#ranked-memref-types">defined above</a> before unbundling them into
individual scalar arguments.</p>
<p>Examples:</p>
<p>This convention is implemented in the conversion of <code class="docutils literal notranslate"><span class="pre">func.func</span></code> and <code class="docutils literal notranslate"><span class="pre">func.call</span></code> to
the LLVM dialect, with the former unpacking the descriptor into a set of
individual values and the latter packing those values back into a descriptor so
as to make it transparently usable by other operations. Conversions from other
dialects should take this convention into account.</p>
<p>This specific convention is motivated by the necessity to specify alignment and
aliasing attributes on the raw pointers underpinning the memref.</p>
<p>Examples:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>func.func @foo(%arg0: memref&lt;?xf32&gt;) -&gt; () {
  &quot;use&quot;(%arg0) : (memref&lt;?xf32&gt;) -&gt; ()
  return
}

// Gets converted to the following
// (using type alias for brevity):
!llvm.memref_1d = !llvm.struct&lt;(ptr&lt;f32&gt;, ptr&lt;f32&gt;, i64, array&lt;1xi64&gt;, array&lt;1xi64&gt;)&gt;

llvm.func @foo(%arg0: !llvm.ptr&lt;f32&gt;,  // Allocated pointer.
               %arg1: !llvm.ptr&lt;f32&gt;,  // Aligned pointer.
               %arg2: i64,             // Offset.
               %arg3: i64,             // Size in dim 0.
               %arg4: i64) {           // Stride in dim 0.
  // Populate memref descriptor structure.
  %0 = llvm.mlir.undef :
  %1 = llvm.insertvalue %arg0, %0[0] : !llvm.memref_1d
  %2 = llvm.insertvalue %arg1, %1[1] : !llvm.memref_1d
  %3 = llvm.insertvalue %arg2, %2[2] : !llvm.memref_1d
  %4 = llvm.insertvalue %arg3, %3[3, 0] : !llvm.memref_1d
  %5 = llvm.insertvalue %arg4, %4[4, 0] : !llvm.memref_1d

  // Descriptor is now usable as a single value.
  &quot;use&quot;(%5) : (!llvm.memref_1d) -&gt; ()
  llvm.return
}
</pre></div>
</div>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>func.func @bar() {
  %0 = &quot;get&quot;() : () -&gt; (memref&lt;?xf32&gt;)
  call @foo(%0) : (memref&lt;?xf32&gt;) -&gt; ()
  return
}

// Gets converted to the following
// (using type alias for brevity):
!llvm.memref_1d = !llvm.struct&lt;(ptr&lt;f32&gt;, ptr&lt;f32&gt;, i64, array&lt;1xi64&gt;, array&lt;1xi64&gt;)&gt;

llvm.func @bar() {
  %0 = &quot;get&quot;() : () -&gt; !llvm.memref_1d

  // Unpack the memref descriptor.
  %1 = llvm.extractvalue %0[0] : !llvm.memref_1d
  %2 = llvm.extractvalue %0[1] : !llvm.memref_1d
  %3 = llvm.extractvalue %0[2] : !llvm.memref_1d
  %4 = llvm.extractvalue %0[3, 0] : !llvm.memref_1d
  %5 = llvm.extractvalue %0[4, 0] : !llvm.memref_1d

  // Pass individual values to the callee.
  llvm.call @foo(%1, %2, %3, %4, %5) : (!llvm.memref_1d) -&gt; ()
  llvm.return
}
</pre></div>
</div>
</section>
<section id="default-calling-convention-for-unranked-memref">
<h4>Default Calling Convention for Unranked MemRef<a class="headerlink" href="#default-calling-convention-for-unranked-memref" title="此标题的永久链接">¶</a></h4>
<p>For unranked memrefs, the list of function arguments always contains two
elements, same as the unranked memref descriptor: an integer rank, and a
type-erased (<code class="docutils literal notranslate"><span class="pre">!llvm&lt;&quot;i8*&quot;&gt;</span></code>) pointer to the ranked memref descriptor. Note that
while the <em>calling convention</em> does not require allocation, <em>casting</em> to
unranked memref does since one cannot take an address of an SSA value containing
the ranked memref, which must be stored in some memory instead. The caller is in
charge of ensuring the thread safety and management of the allocated memory, in
particular the deallocation.</p>
<p>Example</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>llvm.func @foo(%arg0: memref&lt;*xf32&gt;) -&gt; () {
  &quot;use&quot;(%arg0) : (memref&lt;*xf32&gt;) -&gt; ()
  return
}

// Gets converted to the following.

llvm.func @foo(%arg0: i64              // Rank.
               %arg1: !llvm.ptr&lt;i8&gt;) { // Type-erased pointer to descriptor.
  // Pack the unranked memref descriptor.
  %0 = llvm.mlir.undef : !llvm.struct&lt;(i64, ptr&lt;i8&gt;)&gt;
  %1 = llvm.insertvalue %arg0, %0[0] : !llvm.struct&lt;(i64, ptr&lt;i8&gt;)&gt;
  %2 = llvm.insertvalue %arg1, %1[1] : !llvm.struct&lt;(i64, ptr&lt;i8&gt;)&gt;

  &quot;use&quot;(%2) : (!llvm.struct&lt;(i64, ptr&lt;i8&gt;)&gt;) -&gt; ()
  llvm.return
}
</pre></div>
</div>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>llvm.func @bar() {
  %0 = &quot;get&quot;() : () -&gt; (memref&lt;*xf32&gt;)
  call @foo(%0): (memref&lt;*xf32&gt;) -&gt; ()
  return
}

// Gets converted to the following.

llvm.func @bar() {
  %0 = &quot;get&quot;() : () -&gt; (!llvm.struct&lt;(i64, ptr&lt;i8&gt;)&gt;)

  // Unpack the memref descriptor.
  %1 = llvm.extractvalue %0[0] : !llvm.struct&lt;(i64, ptr&lt;i8&gt;)&gt;
  %2 = llvm.extractvalue %0[1] : !llvm.struct&lt;(i64, ptr&lt;i8&gt;)&gt;

  // Pass individual values to the callee.
  llvm.call @foo(%1, %2) : (i64, !llvm.ptr&lt;i8&gt;)
  llvm.return
}
</pre></div>
</div>
<p><strong>Lifetime.</strong> The second element of the unranked memref descriptor points to
some memory in which the ranked memref descriptor is stored. By convention, this
memory is allocated on stack and has the lifetime of the function. (<em>Note:</em> due
to function-length lifetime, creation of multiple unranked memref descriptors,
e.g., in a loop, may lead to stack overflows.) If an unranked descriptor has to
be returned from a function, the ranked descriptor it points to is copied into
dynamically allocated memory, and the pointer in the unranked descriptor is
updated accordingly. The allocation happens immediately before returning. It is
the responsibility of the caller to free the dynamically allocated memory. The
default conversion of <code class="docutils literal notranslate"><span class="pre">func.call</span></code> and <code class="docutils literal notranslate"><span class="pre">func.call_indirect</span></code> copies the ranked
descriptor to newly allocated memory on the caller’s stack. Thus, the convention
of the ranked memref descriptor pointed to by an unranked memref descriptor
being stored on stack is respected.</p>
</section>
<section id="bare-pointer-calling-convention-for-ranked-memref">
<h4>Bare Pointer Calling Convention for Ranked MemRef<a class="headerlink" href="#bare-pointer-calling-convention-for-ranked-memref" title="此标题的永久链接">¶</a></h4>
<p>The “bare pointer” calling convention converts <code class="docutils literal notranslate"><span class="pre">memref</span></code>-typed function arguments
to a <em>single</em> pointer to the aligned data. Note that this does <em>not</em> apply to
uses of <code class="docutils literal notranslate"><span class="pre">memref</span></code> outside of function signatures, the default descriptor
structures are still used. This convention further restricts the supported cases
to the following.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">memref</span></code> types with default layout.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">memref</span></code> types with all dimensions statically known.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">memref</span></code> values allocated in such a way that the allocated and aligned
pointer match. Alternatively, the same function must handle allocation and
deallocation since only one pointer is passed to any callee.</p></li>
</ul>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>func.func @callee(memref&lt;2x4xf32&gt;) {

func.func @caller(%0 : memref&lt;2x4xf32&gt;) {
  call @callee(%0) : (memref&lt;2x4xf32&gt;) -&gt; ()
}

// -&gt;

!descriptor = !llvm.struct&lt;(ptr&lt;f32&gt;, ptr&lt;f32&gt;, i64,
                            array&lt;2xi64&gt;, array&lt;2xi64&gt;)&gt;

llvm.func @callee(!llvm.ptr&lt;f32&gt;)

llvm.func @caller(%arg0: !llvm.ptr&lt;f32&gt;) {
  // A descriptor value is defined at the function entry point.
  %0 = llvm.mlir.undef : !descriptor

  // Both the allocated and aligned pointer are set up to the same value.
  %1 = llvm.insertelement %arg0, %0[0] : !descriptor
  %2 = llvm.insertelement %arg0, %1[1] : !descriptor

  // The offset is set up to zero.
  %3 = llvm.mlir.constant(0 : index) : i64
  %4 = llvm.insertelement %3, %2[2] : !descriptor

  // The sizes and strides are derived from the statically known values.
  %5 = llvm.mlir.constant(2 : index) : i64
  %6 = llvm.mlir.constant(4 : index) : i64
  %7 = llvm.insertelement %5, %4[3, 0] : !descriptor
  %8 = llvm.insertelement %6, %7[3, 1] : !descriptor
  %9 = llvm.mlir.constant(1 : index) : i64
  %10 = llvm.insertelement %9, %8[4, 0] : !descriptor
  %11 = llvm.insertelement %10, %9[4, 1] : !descriptor

  // The function call corresponds to extracting the aligned data pointer.
  %12 = llvm.extractelement %11[1] : !descriptor
  llvm.call @callee(%12) : (!llvm.ptr&lt;f32&gt;) -&gt; ()
}
</pre></div>
</div>
</section>
<section id="bare-pointer-calling-convention-for-unranked-memref">
<h4>Bare Pointer Calling Convention For Unranked MemRef<a class="headerlink" href="#bare-pointer-calling-convention-for-unranked-memref" title="此标题的永久链接">¶</a></h4>
<p>The “bare pointer” calling convention does not support unranked memrefs as their
shape cannot be known at compile time.</p>
</section>
</section>
<section id="generic-alloction-and-deallocation-functions">
<h3>Generic alloction and deallocation functions<a class="headerlink" href="#generic-alloction-and-deallocation-functions" title="此标题的永久链接">¶</a></h3>
<p>When converting the Memref dialect, allocations and deallocations are converted
into calls to <code class="docutils literal notranslate"><span class="pre">malloc</span></code> (<code class="docutils literal notranslate"><span class="pre">aligned_alloc</span></code> if aligned allocations are requested)
and <code class="docutils literal notranslate"><span class="pre">free</span></code>. However, it is possible to convert them to more generic functions
which can be implemented by a runtime library, thus allowing custom allocation
strategies or runtime profiling. When the conversion pass is  instructed to
perform such operation, the names of the calles are
<code class="docutils literal notranslate"><span class="pre">_mlir_memref_to_llvm_alloc</span></code>, <code class="docutils literal notranslate"><span class="pre">_mlir_memref_to_llvm_aligned_alloc</span></code> and
<code class="docutils literal notranslate"><span class="pre">_mlir_memref_to_llvm_free</span></code>. Their signatures are the same of <code class="docutils literal notranslate"><span class="pre">malloc</span></code>,
<code class="docutils literal notranslate"><span class="pre">aligned_alloc</span></code> and <code class="docutils literal notranslate"><span class="pre">free</span></code>.</p>
</section>
<section id="c-compatible-wrapper-emission">
<h3>C-compatible wrapper emission<a class="headerlink" href="#c-compatible-wrapper-emission" title="此标题的永久链接">¶</a></h3>
<p>In practical cases, it may be desirable to have externally-facing functions with
a single attribute corresponding to a MemRef argument. When interfacing with
LLVM IR produced from C, the code needs to respect the corresponding calling
convention. The conversion to the LLVM dialect provides an option to generate
wrapper functions that take memref descriptors as pointers-to-struct compatible
with data types produced by Clang when compiling C sources. The generation of
such wrapper functions can additionally be controlled at a function granularity
by setting the <code class="docutils literal notranslate"><span class="pre">llvm.emit_c_interface</span></code> unit attribute.</p>
<p>More specifically, a memref argument is converted into a pointer-to-struct
argument of type <code class="docutils literal notranslate"><span class="pre">{T*,</span> <span class="pre">T*,</span> <span class="pre">i64,</span> <span class="pre">i64[N],</span> <span class="pre">i64[N]}*</span></code> in the wrapper function, where
<code class="docutils literal notranslate"><span class="pre">T</span></code> is the converted element type and <code class="docutils literal notranslate"><span class="pre">N</span></code> is the memref rank. This type is
compatible with that produced by Clang for the following C++ structure template
instantiations or their equivalents in C.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">N</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">MemRefDescriptor</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">allocated</span><span class="p">;</span>
<span class="w">  </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">aligned</span><span class="p">;</span>
<span class="w">  </span><span class="kt">intptr_t</span><span class="w"> </span><span class="n">offset</span><span class="p">;</span>
<span class="w">  </span><span class="kt">intptr_t</span><span class="w"> </span><span class="n">sizes</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="w">  </span><span class="kt">intptr_t</span><span class="w"> </span><span class="n">strides</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Furthermore, we also rewrite function results to pointer parameters if the
rewritten function result has a struct type. The special result parameter is
added as the first parameter and is of pointer-to-struct type.</p>
<p>If enabled, the option will do the following. For <em>external</em> functions declared
in the MLIR module.</p>
<ol class="simple">
<li><p>Declare a new function <code class="docutils literal notranslate"><span class="pre">_mlir_ciface_&lt;original</span> <span class="pre">name&gt;</span></code> where memref arguments
are converted to pointer-to-struct and the remaining arguments are converted
as usual. Results are converted to a special argument if they are of struct
type.</p></li>
<li><p>Add a body to the original function (making it non-external) that</p>
<ol class="simple">
<li><p>allocates memref descriptors,</p></li>
<li><p>populates them,</p></li>
<li><p>potentially allocates space for the result struct, and</p></li>
<li><p>passes the pointers to these into the newly declared interface function,
then</p></li>
<li><p>collects the result of the call (potentially from the result struct),
and</p></li>
<li><p>returns it to the caller.</p></li>
</ol>
</li>
</ol>
<p>For (non-external) functions defined in the MLIR module.</p>
<ol class="simple">
<li><p>Define a new function <code class="docutils literal notranslate"><span class="pre">_mlir_ciface_&lt;original</span> <span class="pre">name&gt;</span></code> where memref arguments
are converted to pointer-to-struct and the remaining arguments are converted
as usual. Results are converted to a special argument if they are of struct
type.</p></li>
<li><p>Populate the body of the newly defined function with IR that</p>
<ol class="simple">
<li><p>loads descriptors from pointers;</p></li>
<li><p>unpacks descriptor into individual non-aggregate values;</p></li>
<li><p>passes these values into the original function;</p></li>
<li><p>collects the results of the call and</p></li>
<li><p>either copies the results into the result struct or returns them to the
caller.</p></li>
</ol>
</li>
</ol>
<p>Examples:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>
func.func @qux(%arg0: memref&lt;?x?xf32&gt;)

// Gets converted into the following
// (using type alias for brevity):
!llvm.memref_2d = !llvm.struct&lt;(ptr&lt;f32&gt;, ptr&lt;f32&gt;, i64, array&lt;2xi64&gt;, array&lt;2xi64&gt;)&gt;

// Function with unpacked arguments.
llvm.func @qux(%arg0: !llvm.ptr&lt;f32&gt;, %arg1: !llvm.ptr&lt;f32&gt;,
               %arg2: i64, %arg3: i64, %arg4: i64,
               %arg5: i64, %arg6: i64) {
  // Populate memref descriptor (as per calling convention).
  %0 = llvm.mlir.undef : !llvm.memref_2d
  %1 = llvm.insertvalue %arg0, %0[0] : !llvm.memref_2d
  %2 = llvm.insertvalue %arg1, %1[1] : !llvm.memref_2d
  %3 = llvm.insertvalue %arg2, %2[2] : !llvm.memref_2d
  %4 = llvm.insertvalue %arg3, %3[3, 0] : !llvm.memref_2d
  %5 = llvm.insertvalue %arg5, %4[4, 0] : !llvm.memref_2d
  %6 = llvm.insertvalue %arg4, %5[3, 1] : !llvm.memref_2d
  %7 = llvm.insertvalue %arg6, %6[4, 1] : !llvm.memref_2d

  // Store the descriptor in a stack-allocated space.
  %8 = llvm.mlir.constant(1 : index) : i64
  %9 = llvm.alloca %8 x !llvm.memref_2d
     : (i64) -&gt; !llvm.ptr&lt;struct&lt;(ptr&lt;f32&gt;, ptr&lt;f32&gt;, i64,
                                        array&lt;2xi64&gt;, array&lt;2xi64&gt;)&gt;&gt;
  llvm.store %7, %9 : !llvm.ptr&lt;struct&lt;(ptr&lt;f32&gt;, ptr&lt;f32&gt;, i64,
                                        array&lt;2xi64&gt;, array&lt;2xi64&gt;)&gt;&gt;

  // Call the interface function.
  llvm.call @_mlir_ciface_qux(%9)
     : (!llvm.ptr&lt;struct&lt;(ptr&lt;f32&gt;, ptr&lt;f32&gt;, i64,
                          array&lt;2xi64&gt;, array&lt;2xi64&gt;)&gt;&gt;) -&gt; ()

  // The stored descriptor will be freed on return.
  llvm.return
}

// Interface function.
llvm.func @_mlir_ciface_qux(!llvm.ptr&lt;struct&lt;(ptr&lt;f32&gt;, ptr&lt;f32&gt;, i64,
                                              array&lt;2xi64&gt;, array&lt;2xi64&gt;)&gt;&gt;)
</pre></div>
</div>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>func.func @foo(%arg0: memref&lt;?x?xf32&gt;) {
  return
}

// Gets converted into the following
// (using type alias for brevity):
!llvm.memref_2d = !llvm.struct&lt;(ptr&lt;f32&gt;, ptr&lt;f32&gt;, i64, array&lt;2xi64&gt;, array&lt;2xi64&gt;)&gt;
!llvm.memref_2d_ptr = !llvm.ptr&lt;struct&lt;(ptr&lt;f32&gt;, ptr&lt;f32&gt;, i64, array&lt;2xi64&gt;, array&lt;2xi64&gt;)&gt;&gt;

// Function with unpacked arguments.
llvm.func @foo(%arg0: !llvm.ptr&lt;f32&gt;, %arg1: !llvm.ptr&lt;f32&gt;,
               %arg2: i64, %arg3: i64, %arg4: i64,
               %arg5: i64, %arg6: i64) {
  llvm.return
}

// Interface function callable from C.
llvm.func @_mlir_ciface_foo(%arg0: !llvm.memref_2d_ptr) {
  // Load the descriptor.
  %0 = llvm.load %arg0 : !llvm.memref_2d_ptr

  // Unpack the descriptor as per calling convention.
  %1 = llvm.extractvalue %0[0] : !llvm.memref_2d
  %2 = llvm.extractvalue %0[1] : !llvm.memref_2d
  %3 = llvm.extractvalue %0[2] : !llvm.memref_2d
  %4 = llvm.extractvalue %0[3, 0] : !llvm.memref_2d
  %5 = llvm.extractvalue %0[3, 1] : !llvm.memref_2d
  %6 = llvm.extractvalue %0[4, 0] : !llvm.memref_2d
  %7 = llvm.extractvalue %0[4, 1] : !llvm.memref_2d
  llvm.call @foo(%1, %2, %3, %4, %5, %6, %7)
    : (!llvm.ptr&lt;f32&gt;, !llvm.ptr&lt;f32&gt;, i64, i64, i64,
       i64, i64) -&gt; ()
  llvm.return
}
</pre></div>
</div>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>func.func @foo(%arg0: memref&lt;?x?xf32&gt;) -&gt; memref&lt;?x?xf32&gt; {
  return %arg0 : memref&lt;?x?xf32&gt;
}

// Gets converted into the following
// (using type alias for brevity):
!llvm.memref_2d = !llvm.struct&lt;(ptr&lt;f32&gt;, ptr&lt;f32&gt;, i64, array&lt;2xi64&gt;, array&lt;2xi64&gt;)&gt;
!llvm.memref_2d_ptr = !llvm.ptr&lt;struct&lt;(ptr&lt;f32&gt;, ptr&lt;f32&gt;, i64, array&lt;2xi64&gt;, array&lt;2xi64&gt;)&gt;&gt;

// Function with unpacked arguments.
llvm.func @foo(%arg0: !llvm.ptr&lt;f32&gt;, %arg1: !llvm.ptr&lt;f32&gt;, %arg2: i64,
               %arg3: i64, %arg4: i64, %arg5: i64, %arg6: i64)
    -&gt; !llvm.memref_2d {
  %0 = llvm.mlir.undef : !llvm.memref_2d
  %1 = llvm.insertvalue %arg0, %0[0] : !llvm.memref_2d
  %2 = llvm.insertvalue %arg1, %1[1] : !llvm.memref_2d
  %3 = llvm.insertvalue %arg2, %2[2] : !llvm.memref_2d
  %4 = llvm.insertvalue %arg3, %3[3, 0] : !llvm.memref_2d
  %5 = llvm.insertvalue %arg5, %4[4, 0] : !llvm.memref_2d
  %6 = llvm.insertvalue %arg4, %5[3, 1] : !llvm.memref_2d
  %7 = llvm.insertvalue %arg6, %6[4, 1] : !llvm.memref_2d
  llvm.return %7 : !llvm.memref_2d
}

// Interface function callable from C.
llvm.func @_mlir_ciface_foo(%arg0: !llvm.memref_2d_ptr, %arg1: !llvm.memref_2d_ptr) {
  %0 = llvm.load %arg1 : !llvm.memref_2d_ptr
  %1 = llvm.extractvalue %0[0] : !llvm.memref_2d
  %2 = llvm.extractvalue %0[1] : !llvm.memref_2d
  %3 = llvm.extractvalue %0[2] : !llvm.memref_2d
  %4 = llvm.extractvalue %0[3, 0] : !llvm.memref_2d
  %5 = llvm.extractvalue %0[3, 1] : !llvm.memref_2d
  %6 = llvm.extractvalue %0[4, 0] : !llvm.memref_2d
  %7 = llvm.extractvalue %0[4, 1] : !llvm.memref_2d
  %8 = llvm.call @foo(%1, %2, %3, %4, %5, %6, %7)
    : (!llvm.ptr&lt;f32&gt;, !llvm.ptr&lt;f32&gt;, i64, i64, i64, i64, i64) -&gt; !llvm.memref_2d
  llvm.store %8, %arg0 : !llvm.memref_2d_ptr
  llvm.return
}
</pre></div>
</div>
<p>Rationale: Introducing auxiliary functions for C-compatible interfaces is
preferred to modifying the calling convention since it will minimize the effect
of C compatibility on intra-module calls or calls between MLIR-generated
functions. In particular, when calling external functions from an MLIR module in
a (parallel) loop, the fact of storing a memref descriptor on stack can lead to
stack exhaustion and/or concurrent access to the same address. Auxiliary
interface function serves as an allocation scope in this case. Furthermore, when
targeting accelerators with separate memory spaces such as GPUs, stack-allocated
descriptors passed by pointer would have to be transferred to the device memory,
which introduces significant overhead. In such situations, auxiliary interface
functions are executed on host and only pass the values through device function
invocation mechanism.</p>
<p>Limitation: Right now we cannot generate C interface for variadic functions,
regardless of being non-external or external. Because C functions are unable to
“forward” variadic arguments like this:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">bar</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="p">...)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// ERROR: no way to forward variadic arguments.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">bar</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="address-computation">
<h3>Address Computation<a class="headerlink" href="#address-computation" title="此标题的永久链接">¶</a></h3>
<p>Accesses to a memref element are transformed into an access to an element of the
buffer pointed to by the descriptor. The position of the element in the buffer
is calculated by linearizing memref indices in row-major order (lexically first
index is the slowest varying, similar to C, but accounting for strides). The
computation of the linear address is emitted as arithmetic operation in the LLVM
IR dialect. Strides are extracted from the memref descriptor.</p>
<p>Examples:</p>
<p>An access to a memref with indices:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>%0 = memref.load %m[%1,%2,%3,%4] : memref&lt;?x?x4x8xf32, offset: ?&gt;
</pre></div>
</div>
<p>is transformed into the equivalent of the following code:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>// Compute the linearized index from strides.
// When strides or, in absence of explicit strides, the corresponding sizes are
// dynamic, extract the stride value from the descriptor.
%stride1 = llvm.extractvalue[4, 0] : !llvm.struct&lt;(ptr&lt;f32&gt;, ptr&lt;f32&gt;, i64,
                                                   array&lt;4xi64&gt;, array&lt;4xi64&gt;)&gt;
%addr1 = arith.muli %stride1, %1 : i64

// When the stride or, in absence of explicit strides, the trailing sizes are
// known statically, this value is used as a constant. The natural value of
// strides is the product of all sizes following the current dimension.
%stride2 = llvm.mlir.constant(32 : index) : i64
%addr2 = arith.muli %stride2, %2 : i64
%addr3 = arith.addi %addr1, %addr2 : i64

%stride3 = llvm.mlir.constant(8 : index) : i64
%addr4 = arith.muli %stride3, %3 : i64
%addr5 = arith.addi %addr3, %addr4 : i64

// Multiplication with the known unit stride can be omitted.
%addr6 = arith.addi %addr5, %4 : i64

// If the linear offset is known to be zero, it can also be omitted. If it is
// dynamic, it is extracted from the descriptor.
%offset = llvm.extractvalue[2] : !llvm.struct&lt;(ptr&lt;f32&gt;, ptr&lt;f32&gt;, i64,
                                               array&lt;4xi64&gt;, array&lt;4xi64&gt;)&gt;
%addr7 = arith.addi %addr6, %offset : i64

// All accesses are based on the aligned pointer.
%aligned = llvm.extractvalue[1] : !llvm.struct&lt;(ptr&lt;f32&gt;, ptr&lt;f32&gt;, i64,
                                                array&lt;4xi64&gt;, array&lt;4xi64&gt;)&gt;

// Get the address of the data pointer.
%ptr = llvm.getelementptr %aligned[%addr8]
     : !llvm.struct&lt;(ptr&lt;f32&gt;, ptr&lt;f32&gt;, i64, array&lt;4xi64&gt;, array&lt;4xi64&gt;)&gt;
     -&gt; !llvm.ptr&lt;f32&gt;

// Perform the actual load.
%0 = llvm.load %ptr : !llvm.ptr&lt;f32&gt;
</pre></div>
</div>
<p>For stores, the address computation code is identical and only the actual store
operation is different.</p>
<p>Note: the conversion does not perform any sort of common subexpression
elimination when emitting memref accesses.</p>
</section>
<section id="utility-classes">
<h3>Utility Classes<a class="headerlink" href="#utility-classes" title="此标题的永久链接">¶</a></h3>
<p>Utility classes common to many conversions to the LLVM dialect can be found
under <code class="docutils literal notranslate"><span class="pre">lib/Conversion/LLVMCommon</span></code>. They include the following.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">LLVMConversionTarget</span></code> specifies all LLVM dialect operations as legal.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">LLVMTypeConverter</span></code> implements the default type conversion as described
above.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ConvertOpToLLVMPattern</span></code> extends the conversion pattern class with LLVM
dialect-specific functionality.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">VectorConvertOpToLLVMPattern</span></code> extends the previous class to automatically
unroll operations on higher-dimensional vectors into lists of operations on
one-dimensional vectors before.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">StructBuilder</span></code> provides a convenient API for building IR that creates or
accesses values of LLVM dialect structure types; it is derived by
<code class="docutils literal notranslate"><span class="pre">MemRefDescriptor</span></code>, <code class="docutils literal notranslate"><span class="pre">UrankedMemrefDescriptor</span></code> and <code class="docutils literal notranslate"><span class="pre">ComplexBuilder</span></code> for the
built-in types convertible to LLVM dialect structure types.</p></li>
</ul>
</section>
</section>
<section id="translation-to-llvm-ir">
<h2>Translation to LLVM IR<a class="headerlink" href="#translation-to-llvm-ir" title="此标题的永久链接">¶</a></h2>
<p>MLIR modules containing <code class="docutils literal notranslate"><span class="pre">llvm.func</span></code>, <code class="docutils literal notranslate"><span class="pre">llvm.mlir.global</span></code> and <code class="docutils literal notranslate"><span class="pre">llvm.metadata</span></code>
operations can be translated to LLVM IR modules using the following scheme.</p>
<ul class="simple">
<li><p>Module-level globals are translated to LLVM IR global values.</p></li>
<li><p>Module-level metadata are translated to LLVM IR metadata, which can be later
augmented with additional metadata defined on specific ops.</p></li>
<li><p>All functions are declared in the module so that they can be referenced.</p></li>
<li><p>Each function is then translated separately and has access to the complete
mappings between MLIR and LLVM IR globals, metadata, and functions.</p></li>
<li><p>Within a function, blocks are traversed in topological order and translated
to LLVM IR basic blocks. In each basic block, PHI nodes are created for each
of the block arguments, but not connected to their source blocks.</p></li>
<li><p>Within each block, operations are translated in their order. Each operation
has access to the same mappings as the function and additionally to the
mapping of values between MLIR and LLVM IR, including PHI nodes. Operations
with regions are responsible for translated the regions they contain.</p></li>
<li><p>After operations in a function are translated, the PHI nodes of blocks in
this function are connected to their source values, which are now available.</p></li>
</ul>
<p>The translation mechanism provides extension hooks for translating custom
operations to LLVM IR via a dialect interface <code class="docutils literal notranslate"><span class="pre">LLVMTranslationDialectInterface</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">convertOperation</span></code> translates an operation that belongs to the current
dialect to LLVM IR given an <code class="docutils literal notranslate"><span class="pre">IRBuilderBase</span></code> and various mappings;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">amendOperation</span></code> performs additional actions on an operation if it contains
a dialect attribute that belongs to the current dialect, for example sets up
instruction-level metadata.</p></li>
</ul>
<p>Dialects containing operations or attributes that want to be translated to LLVM
IR must provide an implementation of this interface and register it with the
system. Note that registration may happen without creating the dialect, for
example, in a separate library to avoid the need for the “main” dialect library
to depend on LLVM IR libraries. The implementations of these methods may used
the
<a class="reference external" href="https://mlir.llvm.org/doxygen/classmlir_1_1LLVM_1_1ModuleTranslation.html"><code class="docutils literal notranslate"><span class="pre">ModuleTranslation</span></code></a>
object provided to them which holds the state of the translation and contains
numerous utilities.</p>
<p>Note that this extension mechanism is <em>intentionally restrictive</em>. LLVM IR has a
small, relatively stable set of instructions and types that MLIR intends to
model fully. Therefore, the extension mechanism is provided only for LLVM IR
constructs that are more often extended – intrinsics and metadata. The primary
goal of the extension mechanism is to support sets of intrinsics, for example
those representing a particular instruction set. The extension mechanism does
not allow for customizing type or block translation, nor does it support custom
module-level operations. Such transformations should be performed within MLIR
and target the corresponding MLIR constructs.</p>
</section>
<section id="translation-from-llvm-ir">
<h2>Translation from LLVM IR<a class="headerlink" href="#translation-from-llvm-ir" title="此标题的永久链接">¶</a></h2>
<p>An experimental flow allows one to import a substantially limited subset of LLVM
IR into MLIR, producing LLVM dialect operations.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="n">mlir</span><span class="o">-</span><span class="n">translate</span> <span class="o">-</span><span class="n">import</span><span class="o">-</span><span class="n">llvm</span> <span class="n">filename</span><span class="o">.</span><span class="n">ll</span>
</pre></div>
</div>
</section>
</section>


          </div>
          <div class="page-nav">
            <div class="inner"><ul class="page-nav">
</ul><div class="footer" role="contentinfo">
      &#169; 版权所有 2023, yaoyue123.
    <br>
    Created using <a href="http://sphinx-doc.org/">Sphinx</a> 6.1.3 with <a href="https://github.com/schettino72/sphinx_press_theme">Press Theme</a> 0.8.0.
</div>
            </div>
          </div>
      </page>
    </div></div>
    
    
  </body>
</html>