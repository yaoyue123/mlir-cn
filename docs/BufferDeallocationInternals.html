<!DOCTYPE html>
<html  lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

      <title>Buffer Deallocation - Internals</title>
    
          <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
          <link rel="stylesheet" href="../_static/theme.css " type="text/css" />
      
      <!-- sphinx script_files -->
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script src="../_static/translations.js"></script>

      
      <!-- bundled in js (rollup iife) -->
      <!-- <script src="../_static/theme-vendors.js"></script> -->
      <script src="../_static/theme.js" defer></script>
    
  <link rel="index" title="索引" href="../genindex.html" />
  <link rel="search" title="搜索" href="../search.html" /> 
  </head>

  <body>
    <div id="app">
    <div class="theme-container" :class="pageClasses"><navbar @toggle-sidebar="toggleSidebar">
  <router-link to="../index.html" class="home-link">
    
      <span class="site-name">MLIR 中文文档</span>
    
  </router-link>

  <div class="links">
    <navlinks class="can-hide">



    </navlinks>
  </div>
</navbar>

      
      <div class="sidebar-mask" @click="toggleSidebar(false)">
      </div>
        <sidebar @toggle-sidebar="toggleSidebar">
          
          <navlinks>
            



            
          </navlinks><div id="searchbox" class="searchbox" role="search">
  <div class="caption"><span class="caption-text">快速搜索</span>
    <div class="searchformwrapper">
      <form class="search" action="../search.html" method="get">
        <input type="text" name="q" />
        <input type="submit" value="搜索" />
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div><div class="sidebar-links" role="navigation" aria-label="main navigation">
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../index.html#mlir">欢迎使用 mlir 中文文档</a></span>
      </p>
      <ul class="">
        
          <li class="toctree-l1 ">
            
              <a href="../_index.html" class="reference internal ">开始使用MLIR</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/CreatingADialect.html" class="reference internal ">Creating a Dialect</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/DataFlowAnalysis.html" class="reference internal ">Writing DataFlow Analyses in MLIR</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/QuickstartRewrites.html" class="reference internal ">Quickstart tutorial to adding MLIR graph rewrite</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-1.html" class="reference internal ">第1章：Toy语言和AST（抽象语法树）</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-2.html" class="reference internal ">Chapter 2: Emitting Basic MLIR</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-3.html" class="reference internal ">Chapter 3: High-level Language-Specific Analysis and Transformation</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-4.html" class="reference internal ">Chapter 4: Enabling Generic Transformation with Interfaces</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-5.html" class="reference internal ">Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-6.html" class="reference internal ">Chapter 6: Lowering to LLVM and CodeGeneration</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-7.html" class="reference internal ">Chapter 7: Adding a Composite Type to Toy</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/_index.html" class="reference internal ">Toy 入门教程</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/UnderstandingTheIRStructure.html" class="reference internal ">Understanding the IR Structure</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/_index.html" class="reference internal ">Tutorials</a>
            

            
          </li>

        
      </ul>
    </div>
  
</div>
        </sidebar>

      <page>
          <div class="body-header" role="navigation" aria-label="navigation">
  
  <ul class="breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
    
    <li>Buffer Deallocation - Internals</li>
  </ul>
  

  <ul class="page-nav">
</ul>
  
</div>
<hr>
          <div class="content" role="main" v-pre>
            
  <section id="buffer-deallocation-internals">
<h1>Buffer Deallocation - Internals<a class="headerlink" href="#buffer-deallocation-internals" title="此标题的永久链接">¶</a></h1>
<p>This section covers the internal functionality of the BufferDeallocation
transformation. The transformation consists of several passes. The main pass
called BufferDeallocation can be applied via “-buffer-deallocation” on MLIR
programs.</p>
<p>[TOC]</p>
<section id="requirements">
<h2>Requirements<a class="headerlink" href="#requirements" title="此标题的永久链接">¶</a></h2>
<p>In order to use BufferDeallocation on an arbitrary dialect, several control-flow
interfaces have to be implemented when using custom operations. This is
particularly important to understand the implicit control-flow dependencies
between different parts of the input program. Without implementing the following
interfaces, control-flow relations cannot be discovered properly and the
resulting program can become invalid:</p>
<ul class="simple">
<li><p>Branch-like terminators should implement the <code class="docutils literal notranslate"><span class="pre">BranchOpInterface</span></code> to query
and manipulate associated operands.</p></li>
<li><p>Operations involving structured control flow have to implement the
<code class="docutils literal notranslate"><span class="pre">RegionBranchOpInterface</span></code> to model inter-region control flow.</p></li>
<li><p>Terminators yielding values to their parent operation (in particular in the
scope of nested regions within <code class="docutils literal notranslate"><span class="pre">RegionBranchOpInterface</span></code>-based operations),
should implement the <code class="docutils literal notranslate"><span class="pre">ReturnLike</span></code> trait to represent logical “value
returns”.</p></li>
</ul>
<p>Example dialects that are fully compatible are the “std” and “scf” dialects with
respect to all implemented interfaces.</p>
<p>During Bufferization, we convert immutable value types (tensors) to mutable
types (memref). This conversion is done in several steps and in all of these
steps the IR has to fulfill SSA like properties. The usage of memref has to be
in the following consecutive order: allocation, write-buffer, read- buffer. In
this case, there are only buffer reads allowed after the initial full buffer
write is done. In particular, there must be no partial write to a buffer after
the initial write has been finished. However, partial writes in the initializing
is allowed (fill buffer step by step in a loop e.g.). This means, all buffer
writes needs to dominate all buffer reads.</p>
<p>Example for breaking the invariant:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>func.func @condBranch(%arg0: i1, %arg1: memref&lt;2xf32&gt;) {
  %0 = memref.alloc() : memref&lt;2xf32&gt;
  cf.cond_br %arg0, ^bb1, ^bb2
^bb1:
  cf.br ^bb3()
^bb2:
  partial_write(%0, %0)
  cf.br ^bb3()
^bb3():
  test.copy(%0, %arg1) : (memref&lt;2xf32&gt;, memref&lt;2xf32&gt;) -&gt; ()
  return
}
</pre></div>
</div>
<p>The maintenance of the SSA like properties is only needed in the bufferization
process. Afterwards, for example in optimization processes, the property is no
longer needed.</p>
</section>
<section id="detection-of-buffer-allocations">
<h2>Detection of Buffer Allocations<a class="headerlink" href="#detection-of-buffer-allocations" title="此标题的永久链接">¶</a></h2>
<p>The first step of the BufferDeallocation transformation is to identify
manageable allocation operations that implement the <code class="docutils literal notranslate"><span class="pre">SideEffects</span></code> interface.
Furthermore, these ops need to apply the effect <code class="docutils literal notranslate"><span class="pre">MemoryEffects::Allocate</span></code> to a
particular result value while not using the resource
<code class="docutils literal notranslate"><span class="pre">SideEffects::AutomaticAllocationScopeResource</span></code> (since it is currently reserved
for allocations, like <code class="docutils literal notranslate"><span class="pre">Alloca</span></code> that will be automatically deallocated by a
parent scope). Allocations that have not been detected in this phase will not be
tracked internally, and thus, not deallocated automatically. However,
BufferDeallocation is fully compatible with “hybrid” setups in which tracked and
untracked allocations are mixed:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>func.func @mixedAllocation(%arg0: i1) {
   %0 = memref.alloca() : memref&lt;2xf32&gt;  // aliases: %2
   %1 = memref.alloc() : memref&lt;2xf32&gt;  // aliases: %2
   cf.cond_br %arg0, ^bb1, ^bb2
^bb1:
  use(%0)
  cf.br ^bb3(%0 : memref&lt;2xf32&gt;)
^bb2:
  use(%1)
  cf.br ^bb3(%1 : memref&lt;2xf32&gt;)
^bb3(%2: memref&lt;2xf32&gt;):
  ...
}
</pre></div>
</div>
<p>Example of using a conditional branch with alloc and alloca. BufferDeallocation
can detect and handle the different allocation types that might be intermixed.</p>
<p>Note: the current version does not support allocation operations returning
multiple result buffers.</p>
</section>
<section id="conversion-from-allocop-to-allocaop">
<h2>Conversion from AllocOp to AllocaOp<a class="headerlink" href="#conversion-from-allocop-to-allocaop" title="此标题的永久链接">¶</a></h2>
<p>The PromoteBuffersToStack-pass converts AllocOps to AllocaOps, if possible. In
some cases, it can be useful to use such stack-based buffers instead of
heap-based buffers. The conversion is restricted to several constraints like:</p>
<ul class="simple">
<li><p>Control flow</p></li>
<li><p>Buffer Size</p></li>
<li><p>Dynamic Size</p></li>
</ul>
<p>If a buffer is leaving a block, we are not allowed to convert it into an alloca.
If the size of the buffer is large, we could convert it, but regarding stack
overflow, it makes sense to limit the size of these buffers and only convert
small ones. The size can be set via a pass option. The current default value is
1KB. Furthermore, we can not convert buffers with dynamic size, since the
dimension is not known a priori.</p>
</section>
<section id="movement-and-placement-of-allocations">
<h2>Movement and Placement of Allocations<a class="headerlink" href="#movement-and-placement-of-allocations" title="此标题的永久链接">¶</a></h2>
<p>Using the buffer hoisting pass, all buffer allocations are moved as far upwards
as possible in order to group them and make upcoming optimizations easier by
limiting the search space. Such a movement is shown in the following graphs. In
addition, we are able to statically free an alloc, if we move it into a
dominator of all of its uses. This simplifies further optimizations (e.g. buffer
fusion) in the future. However, movement of allocations is limited by external
data dependencies (in particular in the case of allocations of dynamically
shaped types). Furthermore, allocations can be moved out of nested regions, if
necessary. In order to move allocations to valid locations with respect to their
uses only, we leverage Liveness information.</p>
<p>The following code snippets shows a conditional branch before running the
BufferHoisting pass:</p>
<p><img alt="branch_example_pre_move" src="includes/img/branch_example_pre_move.svg" /></p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>func.func @condBranch(%arg0: i1, %arg1: memref&lt;2xf32&gt;, %arg2: memref&lt;2xf32&gt;) {
  cf.cond_br %arg0, ^bb1, ^bb2
^bb1:
  cf.br ^bb3(%arg1 : memref&lt;2xf32&gt;)
^bb2:
  %0 = memref.alloc() : memref&lt;2xf32&gt;  // aliases: %1
  use(%0)
  cf.br ^bb3(%0 : memref&lt;2xf32&gt;)
^bb3(%1: memref&lt;2xf32&gt;):  // %1 could be %0 or %arg1
  test.copy(%1, %arg2) : (memref&lt;2xf32&gt;, memref&lt;2xf32&gt;) -&gt; ()
  return
}
</pre></div>
</div>
<p>Applying the BufferHoisting pass on this program results in the following piece
of code:</p>
<p><img alt="branch_example_post_move" src="includes/img/branch_example_post_move.svg" /></p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>func.func @condBranch(%arg0: i1, %arg1: memref&lt;2xf32&gt;, %arg2: memref&lt;2xf32&gt;) {
  %0 = memref.alloc() : memref&lt;2xf32&gt;  // moved to bb0
  cf.cond_br %arg0, ^bb1, ^bb2
^bb1:
  cf.br ^bb3(%arg1 : memref&lt;2xf32&gt;)
^bb2:
   use(%0)
   cf.br ^bb3(%0 : memref&lt;2xf32&gt;)
^bb3(%1: memref&lt;2xf32&gt;):
  test.copy(%1, %arg2) : (memref&lt;2xf32&gt;, memref&lt;2xf32&gt;) -&gt; ()
  return
}
</pre></div>
</div>
<p>The alloc is moved from bb2 to the beginning and it is passed as an argument to
bb3.</p>
<p>The following example demonstrates an allocation using dynamically shaped types.
Due to the data dependency of the allocation to %0, we cannot move the
allocation out of bb2 in this case:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>func.func @condBranchDynamicType(
  %arg0: i1,
  %arg1: memref&lt;?xf32&gt;,
  %arg2: memref&lt;?xf32&gt;,
  %arg3: index) {
  cf.cond_br %arg0, ^bb1, ^bb2(%arg3: index)
^bb1:
  cf.br ^bb3(%arg1 : memref&lt;?xf32&gt;)
^bb2(%0: index):
  %1 = memref.alloc(%0) : memref&lt;?xf32&gt;   // cannot be moved upwards to the data
                                   // dependency to %0
  use(%1)
  cf.br ^bb3(%1 : memref&lt;?xf32&gt;)
^bb3(%2: memref&lt;?xf32&gt;):
  test.copy(%2, %arg2) : (memref&lt;?xf32&gt;, memref&lt;?xf32&gt;) -&gt; ()
  return
}
</pre></div>
</div>
</section>
<section id="introduction-of-clones">
<h2>Introduction of Clones<a class="headerlink" href="#introduction-of-clones" title="此标题的永久链接">¶</a></h2>
<p>In order to guarantee that all allocated buffers are freed properly, we have to
pay attention to the control flow and all potential aliases a buffer allocation
can have. Since not all allocations can be safely freed with respect to their
aliases (see the following code snippet), it is often required to introduce
copies to eliminate them. Consider the following example in which the
allocations have already been placed:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>func.func @branch(%arg0: i1) {
  %0 = memref.alloc() : memref&lt;2xf32&gt;  // aliases: %2
  cf.cond_br %arg0, ^bb1, ^bb2
^bb1:
  %1 = memref.alloc() : memref&lt;2xf32&gt;  // resides here for demonstration purposes
                                // aliases: %2
  cf.br ^bb3(%1 : memref&lt;2xf32&gt;)
^bb2:
  use(%0)
  cf.br ^bb3(%0 : memref&lt;2xf32&gt;)
^bb3(%2: memref&lt;2xf32&gt;):
  …
  return
}
</pre></div>
</div>
<p>The first alloc can be safely freed after the live range of its post-dominator
block (bb3). The alloc in bb1 has an alias %2 in bb3 that also keeps this buffer
alive until the end of bb3. Since we cannot determine the actual branches that
will be taken at runtime, we have to ensure that all buffers are freed correctly
in bb3 regardless of the branches we will take to reach the exit block. This
makes it necessary to introduce a copy for %2, which allows us to free %alloc0
in bb0 and %alloc1 in bb1. Afterwards, we can continue processing all aliases of
%2 (none in this case) and we can safely free %2 at the end of the sample
program. This sample demonstrates that not all allocations can be safely freed
in their associated post-dominator blocks. Instead, we have to pay attention to
all of their aliases.</p>
<p>Applying the BufferDeallocation pass to the program above yields the following
result:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>func.func @branch(%arg0: i1) {
  %0 = memref.alloc() : memref&lt;2xf32&gt;
  cf.cond_br %arg0, ^bb1, ^bb2
^bb1:
  %1 = memref.alloc() : memref&lt;2xf32&gt;
  %3 = bufferization.clone %1 : (memref&lt;2xf32&gt;) -&gt; (memref&lt;2xf32&gt;)
  memref.dealloc %1 : memref&lt;2xf32&gt; // %1 can be safely freed here
  cf.br ^bb3(%3 : memref&lt;2xf32&gt;)
^bb2:
  use(%0)
  %4 = bufferization.clone %0 : (memref&lt;2xf32&gt;) -&gt; (memref&lt;2xf32&gt;)
  cf.br ^bb3(%4 : memref&lt;2xf32&gt;)
^bb3(%2: memref&lt;2xf32&gt;):
  …
  memref.dealloc %2 : memref&lt;2xf32&gt; // free temp buffer %2
  memref.dealloc %0 : memref&lt;2xf32&gt; // %0 can be safely freed here
  return
}
</pre></div>
</div>
<p>Note that a temporary buffer for %2 was introduced to free all allocations
properly. Note further that the unnecessary allocation of %3 can be easily
removed using one of the post-pass transformations or the canonicalization pass.</p>
<p>The presented example also works with dynamically shaped types.</p>
<p>BufferDeallocation performs a fix-point iteration taking all aliases of all
tracked allocations into account. We initialize the general iteration process
using all tracked allocations and their associated aliases. As soon as we
encounter an alias that is not properly dominated by our allocation, we mark
this alias as <em>critical</em> (needs to be freed and tracked by the internal
fix-point iteration). The following sample demonstrates the presence of critical
and non-critical aliases:</p>
<p><img alt="nested_branch_example_pre_move" src="includes/img/nested_branch_example_pre_move.svg" /></p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>func.func @condBranchDynamicTypeNested(
  %arg0: i1,
  %arg1: memref&lt;?xf32&gt;,  // aliases: %3, %4
  %arg2: memref&lt;?xf32&gt;,
  %arg3: index) {
  cf.cond_br %arg0, ^bb1, ^bb2(%arg3: index)
^bb1:
  cf.br ^bb6(%arg1 : memref&lt;?xf32&gt;)
^bb2(%0: index):
  %1 = memref.alloc(%0) : memref&lt;?xf32&gt;   // cannot be moved upwards due to the data
                                   // dependency to %0
                                   // aliases: %2, %3, %4
  use(%1)
  cf.cond_br %arg0, ^bb3, ^bb4
^bb3:
  cf.br ^bb5(%1 : memref&lt;?xf32&gt;)
^bb4:
  cf.br ^bb5(%1 : memref&lt;?xf32&gt;)
^bb5(%2: memref&lt;?xf32&gt;):  // non-crit. alias of %1, since %1 dominates %2
  cf.br ^bb6(%2 : memref&lt;?xf32&gt;)
^bb6(%3: memref&lt;?xf32&gt;):  // crit. alias of %arg1 and %2 (in other words %1)
  cf.br ^bb7(%3 : memref&lt;?xf32&gt;)
^bb7(%4: memref&lt;?xf32&gt;):  // non-crit. alias of %3, since %3 dominates %4
  test.copy(%4, %arg2) : (memref&lt;?xf32&gt;, memref&lt;?xf32&gt;) -&gt; ()
  return
}
</pre></div>
</div>
<p>Applying BufferDeallocation yields the following output:</p>
<p><img alt="nested_branch_example_post_move" src="includes/img/nested_branch_example_post_move.svg" /></p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>func.func @condBranchDynamicTypeNested(
  %arg0: i1,
  %arg1: memref&lt;?xf32&gt;,
  %arg2: memref&lt;?xf32&gt;,
  %arg3: index) {
  cf.cond_br %arg0, ^bb1, ^bb2(%arg3 : index)
^bb1:
  // temp buffer required due to alias %3
  %5 = bufferization.clone %arg1 : (memref&lt;?xf32&gt;) -&gt; (memref&lt;?xf32&gt;)
  cf.br ^bb6(%5 : memref&lt;?xf32&gt;)
^bb2(%0: index):
  %1 = memref.alloc(%0) : memref&lt;?xf32&gt;
  use(%1)
  cf.cond_br %arg0, ^bb3, ^bb4
^bb3:
  cf.br ^bb5(%1 : memref&lt;?xf32&gt;)
^bb4:
  cf.br ^bb5(%1 : memref&lt;?xf32&gt;)
^bb5(%2: memref&lt;?xf32&gt;):
  %6 = bufferization.clone %1 : (memref&lt;?xf32&gt;) -&gt; (memref&lt;?xf32&gt;)
  memref.dealloc %1 : memref&lt;?xf32&gt;
  cf.br ^bb6(%6 : memref&lt;?xf32&gt;)
^bb6(%3: memref&lt;?xf32&gt;):
  cf.br ^bb7(%3 : memref&lt;?xf32&gt;)
^bb7(%4: memref&lt;?xf32&gt;):
  test.copy(%4, %arg2) : (memref&lt;?xf32&gt;, memref&lt;?xf32&gt;) -&gt; ()
  memref.dealloc %3 : memref&lt;?xf32&gt;  // free %3, since %4 is a non-crit. alias of %3
  return
}
</pre></div>
</div>
<p>Since %3 is a critical alias, BufferDeallocation introduces an additional
temporary copy in all predecessor blocks. %3 has an additional (non-critical)
alias %4 that extends the live range until the end of bb7. Therefore, we can
free %3 after its last use, while taking all aliases into account. Note that %4
does not need to be freed, since we did not introduce a copy for it.</p>
<p>The actual introduction of buffer copies is done after the fix-point iteration
has been terminated and all critical aliases have been detected. A critical
alias can be either a block argument or another value that is returned by an
operation. Copies for block arguments are handled by analyzing all predecessor
blocks. This is primarily done by querying the <code class="docutils literal notranslate"><span class="pre">BranchOpInterface</span></code> of the
associated branch terminators that can jump to the current block. Consider the
following example which involves a simple branch and the critical block argument
%2:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  custom.br ^bb1(..., %0, : ...)
  ...
  custom.br ^bb1(..., %1, : ...)
  ...
^bb1(%2: memref&lt;2xf32&gt;):
  ...
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">BranchOpInterface</span></code> allows us to determine the actual values that will be
passed to block bb1 and its argument %2 by analyzing its predecessor blocks.
Once we have resolved the values %0 and %1 (that are associated with %2 in this
sample), we can introduce a temporary buffer and clone its contents into the new
buffer. Afterwards, we rewire the branch operands to use the newly allocated
buffer instead. However, blocks can have implicitly defined predecessors by
parent ops that implement the <code class="docutils literal notranslate"><span class="pre">RegionBranchOpInterface</span></code>. This can be the case if
this block argument belongs to the entry block of a region. In this setting, we
have to identify all predecessor regions defined by the parent operation. For
every region, we need to get all terminator operations implementing the
<code class="docutils literal notranslate"><span class="pre">ReturnLike</span></code> trait, indicating that they can branch to our current block.
Finally, we can use a similar functionality as described above to add the
temporary copy. This time, we can modify the terminator operands directly
without touching a high-level interface.</p>
<p>Consider the following inner-region control-flow sample that uses an imaginary
“custom.region_if” operation. It either executes the “then” or “else” region and
always continues to the “join” region. The “custom.region_if_yield” operation
returns a result to the parent operation. This sample demonstrates the use of
the <code class="docutils literal notranslate"><span class="pre">RegionBranchOpInterface</span></code> to determine predecessors in order to infer the
high-level control flow:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>func.func @inner_region_control_flow(
  %arg0 : index,
  %arg1 : index) -&gt; memref&lt;?x?xf32&gt; {
  %0 = memref.alloc(%arg0, %arg0) : memref&lt;?x?xf32&gt;
  %1 = custom.region_if %0 : memref&lt;?x?xf32&gt; -&gt; (memref&lt;?x?xf32&gt;)
   then(%arg2 : memref&lt;?x?xf32&gt;) {  // aliases: %arg4, %1
    custom.region_if_yield %arg2 : memref&lt;?x?xf32&gt;
   } else(%arg3 : memref&lt;?x?xf32&gt;) {  // aliases: %arg4, %1
    custom.region_if_yield %arg3 : memref&lt;?x?xf32&gt;
   } join(%arg4 : memref&lt;?x?xf32&gt;) {  // aliases: %1
    custom.region_if_yield %arg4 : memref&lt;?x?xf32&gt;
   }
  return %1 : memref&lt;?x?xf32&gt;
}
</pre></div>
</div>
<p><img alt="region_branch_example_pre_move" src="includes/img/region_branch_example_pre_move.svg" /></p>
<p>Non-block arguments (other values) can become aliases when they are returned by
dialect-specific operations. BufferDeallocation supports this behavior via the
<code class="docutils literal notranslate"><span class="pre">RegionBranchOpInterface</span></code>. Consider the following example that uses an “scf.if”
operation to determine the value of %2 at runtime which creates an alias:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>func.func @nested_region_control_flow(%arg0 : index, %arg1 : index) -&gt; memref&lt;?x?xf32&gt; {
  %0 = arith.cmpi &quot;eq&quot;, %arg0, %arg1 : index
  %1 = memref.alloc(%arg0, %arg0) : memref&lt;?x?xf32&gt;
  %2 = scf.if %0 -&gt; (memref&lt;?x?xf32&gt;) {
    scf.yield %1 : memref&lt;?x?xf32&gt;   // %2 will be an alias of %1
  } else {
    %3 = memref.alloc(%arg0, %arg1) : memref&lt;?x?xf32&gt;  // nested allocation in a div.
                                                // branch
    use(%3)
    scf.yield %1 : memref&lt;?x?xf32&gt;   // %2 will be an alias of %1
  }
  return %2 : memref&lt;?x?xf32&gt;
}
</pre></div>
</div>
<p>In this example, a dealloc is inserted to release the buffer within the else
block since it cannot be accessed by the remainder of the program. Accessing the
<code class="docutils literal notranslate"><span class="pre">RegionBranchOpInterface</span></code>, allows us to infer that %2 is a non-critical alias of
%1 which does not need to be tracked.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>func.func @nested_region_control_flow(%arg0: index, %arg1: index) -&gt; memref&lt;?x?xf32&gt; {
    %0 = arith.cmpi &quot;eq&quot;, %arg0, %arg1 : index
    %1 = memref.alloc(%arg0, %arg0) : memref&lt;?x?xf32&gt;
    %2 = scf.if %0 -&gt; (memref&lt;?x?xf32&gt;) {
      scf.yield %1 : memref&lt;?x?xf32&gt;
    } else {
      %3 = memref.alloc(%arg0, %arg1) : memref&lt;?x?xf32&gt;
      use(%3)
      memref.dealloc %3 : memref&lt;?x?xf32&gt;  // %3 can be safely freed here
      scf.yield %1 : memref&lt;?x?xf32&gt;
    }
    return %2 : memref&lt;?x?xf32&gt;
}
</pre></div>
</div>
<p>Analogous to the previous case, we have to detect all terminator operations in
all attached regions of “scf.if” that provides a value to its parent operation
(in this sample via scf.yield). Querying the <code class="docutils literal notranslate"><span class="pre">RegionBranchOpInterface</span></code> allows us
to determine the regions that “return” a result to their parent operation. Like
before, we have to update all <code class="docutils literal notranslate"><span class="pre">ReturnLike</span></code> terminators as described above.
Reconsider a slightly adapted version of the “custom.region_if” example from
above that uses a nested allocation:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>func.func @inner_region_control_flow_div(
  %arg0 : index,
  %arg1 : index) -&gt; memref&lt;?x?xf32&gt; {
  %0 = memref.alloc(%arg0, %arg0) : memref&lt;?x?xf32&gt;
  %1 = custom.region_if %0 : memref&lt;?x?xf32&gt; -&gt; (memref&lt;?x?xf32&gt;)
   then(%arg2 : memref&lt;?x?xf32&gt;) {  // aliases: %arg4, %1
    custom.region_if_yield %arg2 : memref&lt;?x?xf32&gt;
   } else(%arg3 : memref&lt;?x?xf32&gt;) {
    %2 = memref.alloc(%arg0, %arg1) : memref&lt;?x?xf32&gt;  // aliases: %arg4, %1
    custom.region_if_yield %2 : memref&lt;?x?xf32&gt;
   } join(%arg4 : memref&lt;?x?xf32&gt;) {  // aliases: %1
    custom.region_if_yield %arg4 : memref&lt;?x?xf32&gt;
   }
  return %1 : memref&lt;?x?xf32&gt;
}
</pre></div>
</div>
<p>Since the allocation %2 happens in a divergent branch and cannot be safely
deallocated in a post-dominator, %arg4 will be considered a critical alias.
Furthermore, %arg4 is returned to its parent operation and has an alias %1. This
causes BufferDeallocation to introduce additional copies:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>func.func @inner_region_control_flow_div(
  %arg0 : index,
  %arg1 : index) -&gt; memref&lt;?x?xf32&gt; {
  %0 = memref.alloc(%arg0, %arg0) : memref&lt;?x?xf32&gt;
  %1 = custom.region_if %0 : memref&lt;?x?xf32&gt; -&gt; (memref&lt;?x?xf32&gt;)
   then(%arg2 : memref&lt;?x?xf32&gt;) {
    %4 = bufferization.clone %arg2 : (memref&lt;?x?xf32&gt;) -&gt; (memref&lt;?x?xf32&gt;)
    custom.region_if_yield %4 : memref&lt;?x?xf32&gt;
   } else(%arg3 : memref&lt;?x?xf32&gt;) {
    %2 = memref.alloc(%arg0, %arg1) : memref&lt;?x?xf32&gt;
    %5 = bufferization.clone %2 : (memref&lt;?x?xf32&gt;) -&gt; (memref&lt;?x?xf32&gt;)
    memref.dealloc %2 : memref&lt;?x?xf32&gt;
    custom.region_if_yield %5 : memref&lt;?x?xf32&gt;
   } join(%arg4: memref&lt;?x?xf32&gt;) {
    %4 = bufferization.clone %arg4 : (memref&lt;?x?xf32&gt;) -&gt; (memref&lt;?x?xf32&gt;)
    memref.dealloc %arg4 : memref&lt;?x?xf32&gt;
    custom.region_if_yield %4 : memref&lt;?x?xf32&gt;
   }
  memref.dealloc %0 : memref&lt;?x?xf32&gt;  // %0 can be safely freed here
  return %1 : memref&lt;?x?xf32&gt;
}
</pre></div>
</div>
</section>
<section id="placement-of-deallocs">
<h2>Placement of Deallocs<a class="headerlink" href="#placement-of-deallocs" title="此标题的永久链接">¶</a></h2>
<p>After introducing allocs and copies, deallocs have to be placed to free
allocated memory and avoid memory leaks. The deallocation needs to take place
after the last use of the given value. The position can be determined by
calculating the common post-dominator of all values using their remaining
non-critical aliases. A special-case is the presence of back edges: since such
edges can cause memory leaks when a newly allocated buffer flows back to another
part of the program. In these cases, we need to free the associated buffer
instances from the previous iteration by inserting additional deallocs.</p>
<p>Consider the following “scf.for” use case containing a nested structured
control-flow if:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>func.func @loop_nested_if(
  %lb: index,
  %ub: index,
  %step: index,
  %buf: memref&lt;2xf32&gt;,
  %res: memref&lt;2xf32&gt;) {
  %0 = scf.for %i = %lb to %ub step %step
    iter_args(%iterBuf = %buf) -&gt; memref&lt;2xf32&gt; {
    %1 = arith.cmpi &quot;eq&quot;, %i, %ub : index
    %2 = scf.if %1 -&gt; (memref&lt;2xf32&gt;) {
      %3 = memref.alloc() : memref&lt;2xf32&gt;  // makes %2 a critical alias due to a
                                    // divergent allocation
      use(%3)
      scf.yield %3 : memref&lt;2xf32&gt;
    } else {
      scf.yield %iterBuf : memref&lt;2xf32&gt;
    }
    scf.yield %2 : memref&lt;2xf32&gt;
  }
  test.copy(%0, %res) : (memref&lt;2xf32&gt;, memref&lt;2xf32&gt;) -&gt; ()
  return
}
</pre></div>
</div>
<p>In this example, the <em>then</em> branch of the nested “scf.if” operation returns a
newly allocated buffer.</p>
<p>Since this allocation happens in the scope of a divergent branch, %2 becomes a
critical alias that needs to be handled. As before, we have to insert additional
copies to eliminate this alias using copies of %3 and %iterBuf. This guarantees
that %2 will be a newly allocated buffer that is returned in each iteration.
However, “returning” %2 to its alias %iterBuf turns %iterBuf into a critical
alias as well. In other words, we have to create a copy of %2 to pass it to
%iterBuf. Since this jump represents a back edge, and %2 will always be a new
buffer, we have to free the buffer from the previous iteration to avoid memory
leaks:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>func.func @loop_nested_if(
  %lb: index,
  %ub: index,
  %step: index,
  %buf: memref&lt;2xf32&gt;,
  %res: memref&lt;2xf32&gt;) {
  %4 = bufferization.clone %buf : (memref&lt;2xf32&gt;) -&gt; (memref&lt;2xf32&gt;)
  %0 = scf.for %i = %lb to %ub step %step
    iter_args(%iterBuf = %4) -&gt; memref&lt;2xf32&gt; {
    %1 = arith.cmpi &quot;eq&quot;, %i, %ub : index
    %2 = scf.if %1 -&gt; (memref&lt;2xf32&gt;) {
      %3 = memref.alloc() : memref&lt;2xf32&gt; // makes %2 a critical alias
      use(%3)
      %5 = bufferization.clone %3 : (memref&lt;2xf32&gt;) -&gt; (memref&lt;2xf32&gt;)
      memref.dealloc %3 : memref&lt;2xf32&gt;
      scf.yield %5 : memref&lt;2xf32&gt;
    } else {
      %6 = bufferization.clone %iterBuf : (memref&lt;2xf32&gt;) -&gt; (memref&lt;2xf32&gt;)
      scf.yield %6 : memref&lt;2xf32&gt;
    }
    %7 = bufferization.clone %2 : (memref&lt;2xf32&gt;) -&gt; (memref&lt;2xf32&gt;)
    memref.dealloc %2 : memref&lt;2xf32&gt;
    memref.dealloc %iterBuf : memref&lt;2xf32&gt; // free backedge iteration variable
    scf.yield %7 : memref&lt;2xf32&gt;
  }
  test.copy(%0, %res) : (memref&lt;2xf32&gt;, memref&lt;2xf32&gt;) -&gt; ()
  memref.dealloc %0 : memref&lt;2xf32&gt; // free temp copy %0
  return
}
</pre></div>
</div>
<p>Example for loop-like control flow. The CFG contains back edges that have to be
handled to avoid memory leaks. The bufferization is able to free the backedge
iteration variable %iterBuf.</p>
</section>
<section id="private-analyses-implementations">
<h2>Private Analyses Implementations<a class="headerlink" href="#private-analyses-implementations" title="此标题的永久链接">¶</a></h2>
<p>The BufferDeallocation transformation relies on one primary control-flow
analysis: BufferPlacementAliasAnalysis. Furthermore, we also use dominance and
liveness to place and move nodes. The liveness analysis determines the live
range of a given value. Within this range, a value is alive and can or will be
used in the course of the program. After this range, the value is dead and can
be discarded - in our case, the buffer can be freed. To place the allocs, we
need to know from which position a value will be alive. The allocs have to be
placed in front of this position. However, the most important analysis is the
alias analysis that is needed to introduce copies and to place all
deallocations.</p>
</section>
</section>
<section id="post-phase">
<h1>Post Phase<a class="headerlink" href="#post-phase" title="此标题的永久链接">¶</a></h1>
<p>In order to limit the complexity of the BufferDeallocation transformation, some
tiny code-polishing/optimization transformations are not applied on-the-fly
during placement. Currently, a canonicalization pattern is added to the clone
operation to reduce the appearance of unnecessary clones.</p>
<p>Note: further transformations might be added to the post-pass phase in the
future.</p>
<section id="clone-canonicalization">
<h2>Clone Canonicalization<a class="headerlink" href="#clone-canonicalization" title="此标题的永久链接">¶</a></h2>
<p>During placement of clones it may happen, that unnecessary clones are inserted.
If these clones appear with their corresponding dealloc operation within the
same block, we can use the canonicalizer to remove these unnecessary operations.
Note, that this step needs to take place after the insertion of clones and
deallocs in the buffer deallocation step. The canonicalization inludes both, the
newly created target value from the clone operation and the source operation.</p>
</section>
<section id="canonicalization-of-the-source-buffer-of-the-clone-operation">
<h2>Canonicalization of the Source Buffer of the Clone Operation<a class="headerlink" href="#canonicalization-of-the-source-buffer-of-the-clone-operation" title="此标题的永久链接">¶</a></h2>
<p>In this case, the source of the clone operation can be used instead of its
target. The unused allocation and deallocation operations that are defined for
this clone operation are also removed. Here is a working example generated by
the BufferDeallocation pass that allocates a buffer with dynamic size. A deeper
analysis of this sample reveals that the highlighted operations are redundant
and can be removed.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>func.func @dynamic_allocation(%arg0: index, %arg1: index) -&gt; memref&lt;?x?xf32&gt; {
  %1 = memref.alloc(%arg0, %arg1) : memref&lt;?x?xf32&gt;
  %2 = bufferization.clone %1 : (memref&lt;?x?xf32&gt;) -&gt; (memref&lt;?x?xf32&gt;)
  memref.dealloc %1 : memref&lt;?x?xf32&gt;
  return %2 : memref&lt;?x?xf32&gt;
}
</pre></div>
</div>
<p>Will be transformed to:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>func.func @dynamic_allocation(%arg0: index, %arg1: index) -&gt; memref&lt;?x?xf32&gt; {
  %1 = memref.alloc(%arg0, %arg1) : memref&lt;?x?xf32&gt;
  return %1 : memref&lt;?x?xf32&gt;
}
</pre></div>
</div>
<p>In this case, the additional copy %2 can be replaced with its original source
buffer %1. This also applies to the associated dealloc operation of %1.</p>
</section>
<section id="canonicalization-of-the-target-buffer-of-the-clone-operation">
<h2>Canonicalization of the Target Buffer of the Clone Operation<a class="headerlink" href="#canonicalization-of-the-target-buffer-of-the-clone-operation" title="此标题的永久链接">¶</a></h2>
<p>In this case, the target buffer of the clone operation can be used instead of
its source. The unused deallocation operation that is defined for this clone
operation is also removed.</p>
<p>Consider the following example where a generic test operation writes the result
to %temp and then copies %temp to %result. However, these two operations can be
merged into a single step. Canonicalization removes the clone operation and
%temp, and replaces the uses of %temp with %result:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>func.func @reuseTarget(%arg0: memref&lt;2xf32&gt;, %result: memref&lt;2xf32&gt;){
  %temp = memref.alloc() : memref&lt;2xf32&gt;
  test.generic {
    args_in = 1 : i64,
    args_out = 1 : i64,
    indexing_maps = [#map0, #map0],
    iterator_types = [&quot;parallel&quot;]} %arg0, %temp {
  ^bb0(%gen2_arg0: f32, %gen2_arg1: f32):
    %tmp2 = math.exp %gen2_arg0 : f32
    test.yield %tmp2 : f32
  }: memref&lt;2xf32&gt;, memref&lt;2xf32&gt;
  %result = bufferization.clone %temp : (memref&lt;2xf32&gt;) -&gt; (memref&lt;2xf32&gt;)
  memref.dealloc %temp : memref&lt;2xf32&gt;
  return
}
</pre></div>
</div>
<p>Will be transformed to:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>func.func @reuseTarget(%arg0: memref&lt;2xf32&gt;, %result: memref&lt;2xf32&gt;){
  test.generic {
    args_in = 1 : i64,
    args_out = 1 : i64,
    indexing_maps = [#map0, #map0],
    iterator_types = [&quot;parallel&quot;]} %arg0, %result {
  ^bb0(%gen2_arg0: f32, %gen2_arg1: f32):
    %tmp2 = math.exp %gen2_arg0 : f32
    test.yield %tmp2 : f32
  }: memref&lt;2xf32&gt;, memref&lt;2xf32&gt;
  return
}
</pre></div>
</div>
</section>
<section id="known-limitations">
<h2>Known Limitations<a class="headerlink" href="#known-limitations" title="此标题的永久链接">¶</a></h2>
<p>BufferDeallocation introduces additional clones from “memref” dialect
(“bufferization.clone”). Analogous, all deallocations use the “memref”
dialect-free operation “memref.dealloc”. The actual copy process is realized
using “test.copy”. Furthermore, buffers are essentially immutable after their
creation in a block. Another limitations are known in the case using
unstructered control flow.</p>
</section>
</section>


          </div>
          <div class="page-nav">
            <div class="inner"><ul class="page-nav">
</ul><div class="footer" role="contentinfo">
      &#169; 版权所有 2023, yaoyue123.
    <br>
    Created using <a href="http://sphinx-doc.org/">Sphinx</a> 6.1.3 with <a href="https://github.com/schettino72/sphinx_press_theme">Press Theme</a> 0.8.0.
</div>
            </div>
          </div>
      </page>
    </div></div>
    
    
  </body>
</html>