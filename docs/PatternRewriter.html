<!DOCTYPE html>
<html  lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

      <title>Pattern Rewriting : Generic DAG-to-DAG Rewriting</title>
    
          <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
          <link rel="stylesheet" href="../_static/theme.css " type="text/css" />
      
      <!-- sphinx script_files -->
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script src="../_static/translations.js"></script>

      
      <!-- bundled in js (rollup iife) -->
      <!-- <script src="../_static/theme-vendors.js"></script> -->
      <script src="../_static/theme.js" defer></script>
    
  <link rel="index" title="索引" href="../genindex.html" />
  <link rel="search" title="搜索" href="../search.html" /> 
  </head>

  <body>
    <div id="app">
    <div class="theme-container" :class="pageClasses"><navbar @toggle-sidebar="toggleSidebar">
  <router-link to="../index.html" class="home-link">
    
      <span class="site-name">MLIR 中文文档</span>
    
  </router-link>

  <div class="links">
    <navlinks class="can-hide">



    </navlinks>
  </div>
</navbar>

      
      <div class="sidebar-mask" @click="toggleSidebar(false)">
      </div>
        <sidebar @toggle-sidebar="toggleSidebar">
          
          <navlinks>
            



            
          </navlinks><div id="searchbox" class="searchbox" role="search">
  <div class="caption"><span class="caption-text">快速搜索</span>
    <div class="searchformwrapper">
      <form class="search" action="../search.html" method="get">
        <input type="text" name="q" />
        <input type="submit" value="搜索" />
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div><div class="sidebar-links" role="navigation" aria-label="main navigation">
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../index.html#mlir">欢迎使用 mlir 中文文档</a></span>
      </p>
      <ul class="">
        
          <li class="toctree-l1 ">
            
              <a href="../_index.html" class="reference internal ">开始使用</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/CreatingADialect.html" class="reference internal ">Creating a Dialect</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/DataFlowAnalysis.html" class="reference internal ">Writing DataFlow Analyses in MLIR</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/QuickstartRewrites.html" class="reference internal ">Quickstart tutorial to adding MLIR graph rewrite</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-1.html" class="reference internal ">Chapter 1: Toy Language and AST</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-2.html" class="reference internal ">Chapter 2: Emitting Basic MLIR</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-3.html" class="reference internal ">Chapter 3: High-level Language-Specific Analysis and Transformation</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-4.html" class="reference internal ">Chapter 4: Enabling Generic Transformation with Interfaces</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-5.html" class="reference internal ">Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-6.html" class="reference internal ">Chapter 6: Lowering to LLVM and CodeGeneration</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-7.html" class="reference internal ">Chapter 7: Adding a Composite Type to Toy</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/_index.html" class="reference internal ">Toy Tutorial</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/UnderstandingTheIRStructure.html" class="reference internal ">Understanding the IR Structure</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/_index.html" class="reference internal ">Tutorials</a>
            

            
          </li>

        
      </ul>
    </div>
  
</div>
        </sidebar>

      <page>
          <div class="body-header" role="navigation" aria-label="navigation">
  
  <ul class="breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
    
    <li>Pattern Rewriting : Generic DAG-to-DAG Rewriting</li>
  </ul>
  

  <ul class="page-nav">
</ul>
  
</div>
<hr>
          <div class="content" role="main" v-pre>
            
  <section id="pattern-rewriting-generic-dag-to-dag-rewriting">
<h1>Pattern Rewriting : Generic DAG-to-DAG Rewriting<a class="headerlink" href="#pattern-rewriting-generic-dag-to-dag-rewriting" title="此标题的永久链接">¶</a></h1>
<p>[TOC]</p>
<p>This document details the design and API of the pattern rewriting infrastructure
present in MLIR, a general DAG-to-DAG transformation framework. This framework
is widely used throughout MLIR for canonicalization, conversion, and general
transformation.</p>
<p>For an introduction to DAG-to-DAG transformation, and the rationale behind this
framework please take a look at the
<a class="reference internal" href="Rationale/RationaleGenericDAGRewriter.html"><span class="doc">Generic DAG Rewriter Rationale</span></a>.</p>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="此标题的永久链接">¶</a></h2>
<p>The pattern rewriting framework can largely be decomposed into two parts:
Pattern Definition and Pattern Application.</p>
</section>
<section id="defining-patterns">
<h2>Defining Patterns<a class="headerlink" href="#defining-patterns" title="此标题的永久链接">¶</a></h2>
<p>Patterns are defined by inheriting from the <code class="docutils literal notranslate"><span class="pre">RewritePattern</span></code> class. This class
represents the base class of all rewrite patterns within MLIR, and is comprised
of the following components:</p>
<section id="benefit">
<h3>Benefit<a class="headerlink" href="#benefit" title="此标题的永久链接">¶</a></h3>
<p>This is the expected benefit of applying a given pattern. This benefit is static
upon construction of the pattern, but may be computed dynamically at pattern
initialization time, e.g. allowing the benefit to be derived from domain
specific information (like the target architecture). This limitation allows for
performing pattern fusion and compiling patterns into an efficient state
machine, and
<a class="reference external" href="https://dl.acm.org/citation.cfm?id=3179501">Thier, Ertl, and Krall</a> have shown
that match predicates eliminate the need for dynamically computed costs in
almost all cases: you can simply instantiate the same pattern one time for each
possible cost and use the predicate to guard the match.</p>
</section>
<section id="root-operation-name-optional">
<h3>Root Operation Name (Optional)<a class="headerlink" href="#root-operation-name-optional" title="此标题的永久链接">¶</a></h3>
<p>The name of the root operation that this pattern matches against. If specified,
only operations with the given root name will be provided to the <code class="docutils literal notranslate"><span class="pre">match</span></code> and
<code class="docutils literal notranslate"><span class="pre">rewrite</span></code> implementation. If not specified, any operation type may be provided.
The root operation name should be provided whenever possible, because it
simplifies the analysis of patterns when applying a cost model. To match any
operation type, a special tag must be provided to make the intent explicit:
<code class="docutils literal notranslate"><span class="pre">MatchAnyOpTypeTag</span></code>.</p>
</section>
<section id="match-and-rewrite-implementation">
<h3><code class="docutils literal notranslate"><span class="pre">match</span></code> and <code class="docutils literal notranslate"><span class="pre">rewrite</span></code> implementation<a class="headerlink" href="#match-and-rewrite-implementation" title="此标题的永久链接">¶</a></h3>
<p>This is the chunk of code that matches a given root <code class="docutils literal notranslate"><span class="pre">Operation</span></code> and performs a
rewrite of the IR. A <code class="docutils literal notranslate"><span class="pre">RewritePattern</span></code> can specify this implementation either via
separate <code class="docutils literal notranslate"><span class="pre">match</span></code> and <code class="docutils literal notranslate"><span class="pre">rewrite</span></code> methods, or via a combined <code class="docutils literal notranslate"><span class="pre">matchAndRewrite</span></code>
method. When using the combined <code class="docutils literal notranslate"><span class="pre">matchAndRewrite</span></code> method, no IR mutation should
take place before the match is deemed successful. The combined <code class="docutils literal notranslate"><span class="pre">matchAndRewrite</span></code>
is useful when non-trivially recomputable information is required by the
matching and rewriting phase. See below for examples:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyPattern</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">RewritePattern</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="c1">/// This overload constructs a pattern that only matches operations with the</span>
<span class="w">  </span><span class="c1">/// root name of `MyOp`.</span>
<span class="w">  </span><span class="n">MyPattern</span><span class="p">(</span><span class="n">PatternBenefit</span><span class="w"> </span><span class="n">benefit</span><span class="p">,</span><span class="w"> </span><span class="n">MLIRContext</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="w">      </span><span class="o">:</span><span class="w"> </span><span class="n">RewritePattern</span><span class="p">(</span><span class="n">MyOp</span><span class="o">::</span><span class="n">getOperationName</span><span class="p">(),</span><span class="w"> </span><span class="n">benefit</span><span class="p">,</span><span class="w"> </span><span class="n">context</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="w">  </span><span class="c1">/// This overload constructs a pattern that matches any operation type.</span>
<span class="w">  </span><span class="n">MyPattern</span><span class="p">(</span><span class="n">PatternBenefit</span><span class="w"> </span><span class="n">benefit</span><span class="p">)</span>
<span class="w">      </span><span class="o">:</span><span class="w"> </span><span class="n">RewritePattern</span><span class="p">(</span><span class="n">benefit</span><span class="p">,</span><span class="w"> </span><span class="n">MatchAnyOpTypeTag</span><span class="p">())</span><span class="w"> </span><span class="p">{}</span>

<span class="w">  </span><span class="c1">/// In this section, the `match` and `rewrite` implementation is specified</span>
<span class="w">  </span><span class="c1">/// using the separate hooks.</span>
<span class="w">  </span><span class="n">LogicalResult</span><span class="w"> </span><span class="n">match</span><span class="p">(</span><span class="n">Operation</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// The `match` method returns `success()` if the pattern is a match, failure</span>
<span class="w">    </span><span class="c1">// otherwise.</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">rewrite</span><span class="p">(</span><span class="n">Operation</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="n">PatternRewriter</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rewriter</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// The `rewrite` method performs mutations on the IR rooted at `op` using</span>
<span class="w">    </span><span class="c1">// the provided rewriter. All mutations must go through the provided</span>
<span class="w">    </span><span class="c1">// rewriter.</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">/// In this section, the `match` and `rewrite` implementation is specified</span>
<span class="w">  </span><span class="c1">/// using a single hook.</span>
<span class="w">  </span><span class="n">LogicalResult</span><span class="w"> </span><span class="n">matchAndRewrite</span><span class="p">(</span><span class="n">Operation</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="n">PatternRewriter</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rewriter</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// The `matchAndRewrite` method performs both the matching and the mutation.</span>
<span class="w">    </span><span class="c1">// Note that the match must reach a successful point before IR mutation may</span>
<span class="w">    </span><span class="c1">// take place.</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<section id="restrictions">
<h4>Restrictions<a class="headerlink" href="#restrictions" title="此标题的永久链接">¶</a></h4>
<p>Within the <code class="docutils literal notranslate"><span class="pre">match</span></code> section of a pattern, the following constraints apply:</p>
<ul class="simple">
<li><p>No mutation of the IR is allowed.</p></li>
</ul>
<p>Within the <code class="docutils literal notranslate"><span class="pre">rewrite</span></code> section of a pattern, the following constraints apply:</p>
<ul class="simple">
<li><p>All IR mutations, including creation, <em>must</em> be performed by the given
<code class="docutils literal notranslate"><span class="pre">PatternRewriter</span></code>. This class provides hooks for performing all of the
possible mutations that may take place within a pattern. For example, this
means that an operation should not be erased via its <code class="docutils literal notranslate"><span class="pre">erase</span></code> method. To
erase an operation, the appropriate <code class="docutils literal notranslate"><span class="pre">PatternRewriter</span></code> hook (in this case
<code class="docutils literal notranslate"><span class="pre">eraseOp</span></code>) should be used instead.</p></li>
<li><p>The root operation is required to either be: updated in-place, replaced, or
erased.</p></li>
</ul>
</section>
</section>
<section id="application-recursion">
<h3>Application Recursion<a class="headerlink" href="#application-recursion" title="此标题的永久链接">¶</a></h3>
<p>Recursion is an important topic in the context of pattern rewrites, as a pattern
may often be applicable to its own result. For example, imagine a pattern that
peels a single iteration from a loop operation. If the loop has multiple
peelable iterations, this pattern may apply multiple times during the
application process. By looking at the implementation of this pattern, the bound
for recursive application may be obvious, e.g. there are no peelable iterations
within the loop, but from the perspective of the pattern driver this recursion
is potentially dangerous. Often times the recursive application of a pattern
indicates a bug in the matching logic. These types of bugs generally do not
cause crashes, but create infinite loops within the application process. Given
this, the pattern rewriting infrastructure conservatively assumes that no
patterns have a proper bounded recursion, and will fail if recursion is
detected. A pattern that is known to have proper support for handling recursion
can signal this by calling <code class="docutils literal notranslate"><span class="pre">setHasBoundedRewriteRecursion</span></code> when initializing the
pattern. This will signal to the pattern driver that recursive application of
this pattern may happen, and the pattern is equipped to safely handle it.</p>
</section>
<section id="debug-names-and-labels">
<h3>Debug Names and Labels<a class="headerlink" href="#debug-names-and-labels" title="此标题的永久链接">¶</a></h3>
<p>To aid in debugging, patterns may specify: a debug name (via <code class="docutils literal notranslate"><span class="pre">setDebugName</span></code>),
which should correspond to an identifier that uniquely identifies the specific
pattern; and a set of debug labels (via <code class="docutils literal notranslate"><span class="pre">addDebugLabels</span></code>), which correspond to
identifiers that uniquely identify groups of patterns. This information is used
by various utilities to aid in the debugging of pattern rewrites, e.g. in debug
logs, to provide pattern filtering, etc. A simple code example is shown below:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyPattern</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">RewritePattern</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="c1">/// Inherit constructors from RewritePattern.</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">RewritePattern</span><span class="o">::</span><span class="n">RewritePattern</span><span class="p">;</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">initialize</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">setDebugName</span><span class="p">(</span><span class="s">&quot;MyPattern&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">addDebugLabels</span><span class="p">(</span><span class="s">&quot;MyRewritePass&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// ...</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">populateMyPatterns</span><span class="p">(</span><span class="n">RewritePatternSet</span><span class="w"> </span><span class="o">&amp;</span><span class="n">patterns</span><span class="p">,</span><span class="w"> </span><span class="n">MLIRContext</span><span class="w"> </span><span class="o">*</span><span class="n">ctx</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Debug labels may also be attached to patterns during insertion. This allows</span>
<span class="w">  </span><span class="c1">// for easily attaching common labels to groups of patterns.</span>
<span class="w">  </span><span class="n">patterns</span><span class="p">.</span><span class="n">addWithLabel</span><span class="o">&lt;</span><span class="n">MyPattern</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;MyRewritePatterns&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">ctx</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="initialization">
<h3>Initialization<a class="headerlink" href="#initialization" title="此标题的永久链接">¶</a></h3>
<p>Several pieces of pattern state require explicit initialization by the pattern,
for example setting <code class="docutils literal notranslate"><span class="pre">setHasBoundedRewriteRecursion</span></code> if a pattern safely handles
recursive application. This pattern state can be initialized either in the
constructor of the pattern or via the utility <code class="docutils literal notranslate"><span class="pre">initialize</span></code> hook. Using the
<code class="docutils literal notranslate"><span class="pre">initialize</span></code> hook removes the need to redefine pattern constructors just to
inject additional pattern state initialization. An example is shown below:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyPattern</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">RewritePattern</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="c1">/// Inherit the constructors from RewritePattern.</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">RewritePattern</span><span class="o">::</span><span class="n">RewritePattern</span><span class="p">;</span>

<span class="w">  </span><span class="c1">/// Initialize the pattern.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">initialize</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">/// Signal that this pattern safely handles recursive application.</span>
<span class="w">    </span><span class="n">setHasBoundedRewriteRecursion</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// ...</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="construction">
<h3>Construction<a class="headerlink" href="#construction" title="此标题的永久链接">¶</a></h3>
<p>Constructing a RewritePattern should be performed by using the static
<code class="docutils literal notranslate"><span class="pre">RewritePattern::create&lt;T&gt;</span></code> utility method. This method ensures that the pattern
is properly initialized and prepared for insertion into a <code class="docutils literal notranslate"><span class="pre">RewritePatternSet</span></code>.</p>
</section>
</section>
<section id="pattern-rewriter">
<h2>Pattern Rewriter<a class="headerlink" href="#pattern-rewriter" title="此标题的永久链接">¶</a></h2>
<p>A <code class="docutils literal notranslate"><span class="pre">PatternRewriter</span></code> is a special class that allows for a pattern to communicate
with the driver of pattern application. As noted above, <em>all</em> IR mutations,
including creations, are required to be performed via the <code class="docutils literal notranslate"><span class="pre">PatternRewriter</span></code>
class. This is required because the underlying pattern driver may have state
that would be invalidated when a mutation takes place. Examples of some of the
more prevalent <code class="docutils literal notranslate"><span class="pre">PatternRewriter</span></code> API is shown below, please refer to the
<a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/IR/PatternMatch.h#L235">class documentation</a>
for a more up-to-date listing of the available API:</p>
<ul class="simple">
<li><p>Erase an Operation : <code class="docutils literal notranslate"><span class="pre">eraseOp</span></code></p></li>
</ul>
<p>This method erases an operation that either has no results, or whose results are
all known to have no uses.</p>
<ul class="simple">
<li><p>Notify why a <code class="docutils literal notranslate"><span class="pre">match</span></code> failed : <code class="docutils literal notranslate"><span class="pre">notifyMatchFailure</span></code></p></li>
</ul>
<p>This method allows for providing a diagnostic message within a <code class="docutils literal notranslate"><span class="pre">matchAndRewrite</span></code>
as to why a pattern failed to match. How this message is displayed back to the
user is determined by the specific pattern driver.</p>
<ul class="simple">
<li><p>Replace an Operation : <code class="docutils literal notranslate"><span class="pre">replaceOp</span></code>/<code class="docutils literal notranslate"><span class="pre">replaceOpWithNewOp</span></code></p></li>
</ul>
<p>This method replaces an operation’s results with a set of provided values, and
erases the operation.</p>
<ul class="simple">
<li><p>Update an Operation in-place : <code class="docutils literal notranslate"><span class="pre">(start|cancel|finalize)RootUpdate</span></code></p></li>
</ul>
<p>This is a collection of methods that provide a transaction-like API for updating
the attributes, location, operands, or successors of an operation in-place
within a pattern. An in-place update transaction is started with
<code class="docutils literal notranslate"><span class="pre">startRootUpdate</span></code>, and may either be canceled or finalized with
<code class="docutils literal notranslate"><span class="pre">cancelRootUpdate</span></code> and <code class="docutils literal notranslate"><span class="pre">finalizeRootUpdate</span></code> respectively. A convenience wrapper,
<code class="docutils literal notranslate"><span class="pre">updateRootInPlace</span></code>, is provided that wraps a <code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">finalize</span></code> around a
callback.</p>
<ul class="simple">
<li><p>OpBuilder API</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">PatternRewriter</span></code> inherits from the <code class="docutils literal notranslate"><span class="pre">OpBuilder</span></code> class, and thus provides all
of the same functionality present within an <code class="docutils literal notranslate"><span class="pre">OpBuilder</span></code>. This includes operation
creation, as well as many useful attribute and type construction methods.</p>
</section>
<section id="pattern-application">
<h2>Pattern Application<a class="headerlink" href="#pattern-application" title="此标题的永久链接">¶</a></h2>
<p>After a set of patterns have been defined, they are collected and provided to a
specific driver for application. A driver consists of several high level parts:</p>
<ul class="simple">
<li><p>Input <code class="docutils literal notranslate"><span class="pre">RewritePatternSet</span></code></p></li>
</ul>
<p>The input patterns to a driver are provided in the form of an
<code class="docutils literal notranslate"><span class="pre">RewritePatternSet</span></code>. This class provides a simplified API for building a
list of patterns.</p>
<ul class="simple">
<li><p>Driver-specific <code class="docutils literal notranslate"><span class="pre">PatternRewriter</span></code></p></li>
</ul>
<p>To ensure that the driver state does not become invalidated by IR mutations
within the pattern rewriters, a driver must provide a <code class="docutils literal notranslate"><span class="pre">PatternRewriter</span></code> instance
with the necessary hooks overridden. If a driver does not need to hook into
certain mutations, a default implementation is provided that will perform the
mutation directly.</p>
<ul class="simple">
<li><p>Pattern Application and Cost Model</p></li>
</ul>
<p>Each driver is responsible for defining its own operation visitation order as
well as pattern cost model, but the final application is performed via a
<code class="docutils literal notranslate"><span class="pre">PatternApplicator</span></code> class. This class takes as input the
<code class="docutils literal notranslate"><span class="pre">RewritePatternSet</span></code> and transforms the patterns based upon a provided
cost model. This cost model computes a final benefit for a given pattern, using
whatever driver specific information necessary. After a cost model has been
computed, the driver may begin to match patterns against operations using
<code class="docutils literal notranslate"><span class="pre">PatternApplicator::matchAndRewrite</span></code>.</p>
<p>An example is shown below:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyPattern</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">RewritePattern</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">MyPattern</span><span class="p">(</span><span class="n">PatternBenefit</span><span class="w"> </span><span class="n">benefit</span><span class="p">,</span><span class="w"> </span><span class="n">MLIRContext</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="w">      </span><span class="o">:</span><span class="w"> </span><span class="n">RewritePattern</span><span class="p">(</span><span class="n">MyOp</span><span class="o">::</span><span class="n">getOperationName</span><span class="p">(),</span><span class="w"> </span><span class="n">benefit</span><span class="p">,</span><span class="w"> </span><span class="n">context</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="p">};</span>

<span class="c1">/// Populate the pattern list.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">collectMyPatterns</span><span class="p">(</span><span class="n">RewritePatternSet</span><span class="w"> </span><span class="o">&amp;</span><span class="n">patterns</span><span class="p">,</span><span class="w"> </span><span class="n">MLIRContext</span><span class="w"> </span><span class="o">*</span><span class="n">ctx</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">patterns</span><span class="p">.</span><span class="n">add</span><span class="o">&lt;</span><span class="n">MyPattern</span><span class="o">&gt;</span><span class="p">(</span><span class="cm">/*benefit=*/</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">ctx</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">/// Define a custom PatternRewriter for use by the driver.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MyPatternRewriter</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">PatternRewriter</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="n">MyPatternRewriter</span><span class="p">(</span><span class="n">MLIRContext</span><span class="w"> </span><span class="o">*</span><span class="n">ctx</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">PatternRewriter</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>

<span class="w">  </span><span class="c1">/// Override the necessary PatternRewriter hooks here.</span>
<span class="p">};</span>

<span class="c1">/// Apply the custom driver to `op`.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">applyMyPatternDriver</span><span class="p">(</span><span class="n">Operation</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">,</span>
<span class="w">                          </span><span class="k">const</span><span class="w"> </span><span class="n">FrozenRewritePatternSet</span><span class="w"> </span><span class="o">&amp;</span><span class="n">patterns</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Initialize the custom PatternRewriter.</span>
<span class="w">  </span><span class="n">MyPatternRewriter</span><span class="w"> </span><span class="n">rewriter</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">getContext</span><span class="p">());</span>

<span class="w">  </span><span class="c1">// Create the applicator and apply our cost model.</span>
<span class="w">  </span><span class="n">PatternApplicator</span><span class="w"> </span><span class="n">applicator</span><span class="p">(</span><span class="n">patterns</span><span class="p">);</span>
<span class="w">  </span><span class="n">applicator</span><span class="p">.</span><span class="n">applyCostModel</span><span class="p">([](</span><span class="k">const</span><span class="w"> </span><span class="n">Pattern</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pattern</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Apply a default cost model.</span>
<span class="w">    </span><span class="c1">// Note: This is just for demonstration, if the default cost model is truly</span>
<span class="w">    </span><span class="c1">//       desired `applicator.applyDefaultCostModel()` should be used</span>
<span class="w">    </span><span class="c1">//       instead.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">pattern</span><span class="p">.</span><span class="n">getBenefit</span><span class="p">();</span>
<span class="w">  </span><span class="p">});</span>

<span class="w">  </span><span class="c1">// Try to match and apply a pattern.</span>
<span class="w">  </span><span class="n">LogicalResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">applicator</span><span class="p">.</span><span class="n">matchAndRewrite</span><span class="p">(</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="n">rewriter</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">failed</span><span class="p">(</span><span class="n">result</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// ... No patterns were applied.</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// ... A pattern was successfully applied.</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="common-pattern-drivers">
<h2>Common Pattern Drivers<a class="headerlink" href="#common-pattern-drivers" title="此标题的永久链接">¶</a></h2>
<p>MLIR provides several common pattern drivers that serve a variety of different
use cases.</p>
<section id="dialect-conversion-driver">
<h3>Dialect Conversion Driver<a class="headerlink" href="#dialect-conversion-driver" title="此标题的永久链接">¶</a></h3>
<p>This driver provides a framework in which to perform operation conversions
between, and within dialects using a concept of “legality”. This framework
allows for transforming illegal operations to those supported by a provided
conversion target, via a set of pattern-based operation rewriting patterns. This
framework also provides support for type conversions. More information on this
driver can be found <a class="reference internal" href="DialectConversion.html"><span class="doc">here</span></a>.</p>
</section>
<section id="greedy-pattern-rewrite-driver">
<h3>Greedy Pattern Rewrite Driver<a class="headerlink" href="#greedy-pattern-rewrite-driver" title="此标题的永久链接">¶</a></h3>
<p>This driver processes ops in a worklist-driven fashion and greedily applies the
patterns that locally have the most benefit. The benefit of a pattern is decided
solely by the benefit specified on the pattern, and the relative order of the
pattern within the pattern list (when two patterns have the same local benefit).
Patterns are iteratively applied to operations until a fixed point is reached or
until the configurable maximum number of iterations exhausted, at which point
the driver finishes.</p>
<p>This driver comes in two fashions:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">applyPatternsAndFoldGreedily</span></code> (”region-based driver”) applies patterns to
all ops in a given region or a given container op (but not the container op
itself). I.e., the worklist is initialized with all containing ops.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">applyOpPatternsAndFold</span></code> (”op-based driver”) applies patterns to the
provided list of operations. I.e., the worklist is initialized with the
specified list of ops.</p></li>
</ul>
<p>The driver is configurable via <code class="docutils literal notranslate"><span class="pre">GreedyRewriteConfig</span></code>. The region-based driver
supports two modes for populating the initial worklist:</p>
<ul class="simple">
<li><p>Top-down traversal: Traverse the container op/region top down and in
pre-order. This is generally more efficient in compile time.</p></li>
<li><p>Bottom-up traversal: This is the default setting. It builds the initial
worklist with a postorder traversal and then reverses the worklist. This may
match larger patterns with ambiguous pattern sets.</p></li>
</ul>
<p>By default, ops that were modified in-place and newly created are added back to
the worklist. Ops that are outside of the configurable “scope” of the driver are
not added to the worklist. Furthermore, “strict mode” can exclude certain ops
from being added to the worklist throughout the rewrite process:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">GreedyRewriteStrictness::AnyOp</span></code>: No ops are excluded (apart from the ones
that are out of scope).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GreedyRewriteStrictness::ExistingAndNewOps</span></code>: Only pre-existing ops (with
which the worklist was initialized) and newly created ops are added to the
worklist.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">GreedyRewriteStrictness::ExistingOps</span></code>: Only pre-existing ops (with which
the worklist was initialized) are added to the worklist.</p></li>
</ul>
<p>Note: This driver listens for IR changes via the callbacks provided by
<code class="docutils literal notranslate"><span class="pre">RewriterBase</span></code>. It is important that patterns announce all IR changes to the
rewriter and do not bypass the rewriter API by modifying ops directly.</p>
<p>Note: This driver is the one used by the <a class="reference internal" href="Canonicalization.html"><span class="doc">canonicalization</span></a>
<a class="reference external" href="Passes.md/#-canonicalize-canonicalize-operations">pass</a> in MLIR.</p>
</section>
<section id="debugging">
<h3>Debugging<a class="headerlink" href="#debugging" title="此标题的永久链接">¶</a></h3>
<p>To debug the execution of the greedy pattern rewrite driver,
<code class="docutils literal notranslate"><span class="pre">-debug-only=greedy-rewriter</span></code> may be used. This command line flag activates
LLVM’s debug logging infrastructure solely for the greedy pattern rewriter. The
output is formatted as a tree structure, mirroring the structure of the pattern
application process. This output contains all of the actions performed by the
rewriter, how operations get processed and patterns are applied, and why they
fail.</p>
<p>Example output is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//===-------------------------------------------===//</span>
<span class="n">Processing</span> <span class="n">operation</span> <span class="p">:</span> <span class="s1">&#39;cf.cond_br&#39;</span><span class="p">(</span><span class="mh">0x60f000001120</span><span class="p">)</span> <span class="p">{</span>
  <span class="s2">&quot;cf.cond_br&quot;</span><span class="p">(</span><span class="o">%</span><span class="n">arg0</span><span class="p">)[</span><span class="o">^</span><span class="n">bb2</span><span class="p">,</span> <span class="o">^</span><span class="n">bb2</span><span class="p">]</span> <span class="p">{</span><span class="n">operand_segment_sizes</span> <span class="o">=</span> <span class="n">array</span><span class="o">&lt;</span><span class="n">i32</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span><span class="p">}</span> <span class="p">:</span> <span class="p">(</span><span class="n">i1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">()</span>

  <span class="o">*</span> <span class="n">Pattern</span> <span class="n">SimplifyConstCondBranchPred</span> <span class="p">:</span> <span class="s1">&#39;cf.cond_br -&gt; ()&#39;</span> <span class="p">{</span>
  <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">failure</span> <span class="p">:</span> <span class="n">pattern</span> <span class="n">failed</span> <span class="n">to</span> <span class="n">match</span>

  <span class="o">*</span> <span class="n">Pattern</span> <span class="n">SimplifyCondBranchIdenticalSuccessors</span> <span class="p">:</span> <span class="s1">&#39;cf.cond_br -&gt; ()&#39;</span> <span class="p">{</span>
    <span class="o">**</span> <span class="n">Insert</span>  <span class="p">:</span> <span class="s1">&#39;cf.br&#39;</span><span class="p">(</span><span class="mh">0x60b000003690</span><span class="p">)</span>
    <span class="o">**</span> <span class="n">Replace</span> <span class="p">:</span> <span class="s1">&#39;cf.cond_br&#39;</span><span class="p">(</span><span class="mh">0x60f000001120</span><span class="p">)</span>
  <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">success</span> <span class="p">:</span> <span class="n">pattern</span> <span class="n">applied</span> <span class="n">successfully</span>
<span class="p">}</span> <span class="o">-&gt;</span> <span class="n">success</span> <span class="p">:</span> <span class="n">pattern</span> <span class="n">matched</span>
<span class="o">//===-------------------------------------------===//</span>
</pre></div>
</div>
<p>This output is describing the processing of a <code class="docutils literal notranslate"><span class="pre">cf.cond_br</span></code> operation. We first
try to apply the <code class="docutils literal notranslate"><span class="pre">SimplifyConstCondBranchPred</span></code>, which fails. From there, another
pattern (<code class="docutils literal notranslate"><span class="pre">SimplifyCondBranchIdenticalSuccessors</span></code>) is applied that matches the
<code class="docutils literal notranslate"><span class="pre">cf.cond_br</span></code> and replaces it with a <code class="docutils literal notranslate"><span class="pre">cf.br</span></code>.</p>
</section>
</section>
<section id="id1">
<h2>Debugging<a class="headerlink" href="#id1" title="此标题的永久链接">¶</a></h2>
<section id="pattern-filtering">
<h3>Pattern Filtering<a class="headerlink" href="#pattern-filtering" title="此标题的永久链接">¶</a></h3>
<p>To simplify test case definition and reduction, the <code class="docutils literal notranslate"><span class="pre">FrozenRewritePatternSet</span></code>
class provides built-in support for filtering which patterns should be provided
to the pattern driver for application. Filtering behavior is specified by
providing a <code class="docutils literal notranslate"><span class="pre">disabledPatterns</span></code> and <code class="docutils literal notranslate"><span class="pre">enabledPatterns</span></code> list when constructing the
<code class="docutils literal notranslate"><span class="pre">FrozenRewritePatternSet</span></code>. The <code class="docutils literal notranslate"><span class="pre">disabledPatterns</span></code> list should contain a set of
debug names or labels for patterns that are disabled during pattern application,
i.e. which patterns should be filtered out. The <code class="docutils literal notranslate"><span class="pre">enabledPatterns</span></code> list should
contain a set of debug names or labels for patterns that are enabled during
pattern application, patterns that do not satisfy this constraint are filtered
out. Note that patterns specified by the <code class="docutils literal notranslate"><span class="pre">disabledPatterns</span></code> list will be
filtered out even if they match criteria in the <code class="docutils literal notranslate"><span class="pre">enabledPatterns</span></code> list. An
example is shown below:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">MyPass::initialize</span><span class="p">(</span><span class="n">MLIRContext</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// No patterns are explicitly disabled.</span>
<span class="w">  </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">disabledPatterns</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// Enable only patterns with a debug name or label of `MyRewritePatterns`.</span>
<span class="w">  </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">enabledPatterns</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;MyRewritePatterns&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="n">RewritePatternSet</span><span class="w"> </span><span class="n">rewritePatterns</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="w">  </span><span class="n">frozenPatterns</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FrozenRewritePatternSet</span><span class="p">(</span><span class="n">rewritePatterns</span><span class="p">,</span><span class="w"> </span><span class="n">disabledPatterns</span><span class="p">,</span>
<span class="w">                                           </span><span class="n">enabledPatterns</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="common-pass-utilities">
<h3>Common Pass Utilities<a class="headerlink" href="#common-pass-utilities" title="此标题的永久链接">¶</a></h3>
<p>Passes that utilize rewrite patterns should aim to provide a common set of
options and toggles to simplify the debugging experience when switching between
different passes/projects/etc. To aid in this endeavor, MLIR provides a common
set of utilities that can be easily included when defining a custom pass. These
are defined in <code class="docutils literal notranslate"><span class="pre">mlir/RewritePassUtil.td</span></code>; an example usage is shown below:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def MyRewritePass : Pass&lt;&quot;...&quot;&gt; {
  let summary = &quot;...&quot;;
  let constructor = &quot;createMyRewritePass()&quot;;

  // Inherit the common pattern rewrite options from `RewritePassUtils`.
  let options = RewritePassUtils.options;
}
</pre></div>
</div>
<section id="rewrite-pass-options">
<h4>Rewrite Pass Options<a class="headerlink" href="#rewrite-pass-options" title="此标题的永久链接">¶</a></h4>
<p>This section documents common pass options that are useful for controlling the
behavior of rewrite pattern application.</p>
<section id="id2">
<h5>Pattern Filtering<a class="headerlink" href="#id2" title="此标题的永久链接">¶</a></h5>
<p>Two common pattern filtering options are exposed, <code class="docutils literal notranslate"><span class="pre">disable-patterns</span></code> and
<code class="docutils literal notranslate"><span class="pre">enable-patterns</span></code>, matching the behavior of the <code class="docutils literal notranslate"><span class="pre">disabledPatterns</span></code> and
<code class="docutils literal notranslate"><span class="pre">enabledPatterns</span></code> lists described in the <a class="reference external" href="#pattern-filtering">Pattern Filtering</a>
section above. A snippet of the tablegen definition of these options is shown
below:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>ListOption&lt;&quot;disabledPatterns&quot;, &quot;disable-patterns&quot;, &quot;std::string&quot;,
           &quot;Labels of patterns that should be filtered out during application&quot;&gt;,
ListOption&lt;&quot;enabledPatterns&quot;, &quot;enable-patterns&quot;, &quot;std::string&quot;,
           &quot;Labels of patterns that should be used during application, all &quot;
           &quot;other patterns are filtered out&quot;&gt;,
</pre></div>
</div>
<p>These options may be used to provide filtering behavior when constructing any
<code class="docutils literal notranslate"><span class="pre">FrozenRewritePatternSet</span></code>s within the pass:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">MyRewritePass::initialize</span><span class="p">(</span><span class="n">MLIRContext</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">RewritePatternSet</span><span class="w"> </span><span class="n">rewritePatterns</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// ...</span>

<span class="w">  </span><span class="c1">// When constructing the `FrozenRewritePatternSet`, we provide the filter</span>
<span class="w">  </span><span class="c1">// list options.</span>
<span class="w">  </span><span class="n">frozenPatterns</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FrozenRewritePatternSet</span><span class="p">(</span><span class="n">rewritePatterns</span><span class="p">,</span><span class="w"> </span><span class="n">disabledPatterns</span><span class="p">,</span>
<span class="w">                                           </span><span class="n">enabledPatterns</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
</section>
</section>
</section>


          </div>
          <div class="page-nav">
            <div class="inner"><ul class="page-nav">
</ul><div class="footer" role="contentinfo">
      &#169; 版权所有 2023, yaoyue123.
    <br>
    Created using <a href="http://sphinx-doc.org/">Sphinx</a> 6.1.3 with <a href="https://github.com/schettino72/sphinx_press_theme">Press Theme</a> 0.8.0.
</div>
            </div>
          </div>
      </page>
    </div></div>
    
    
  </body>
</html>