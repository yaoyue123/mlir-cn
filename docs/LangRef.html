<!DOCTYPE html>
<html  lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

      <title>MLIR Language Reference</title>
    
          <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
          <link rel="stylesheet" href="../_static/theme.css " type="text/css" />
      
      <!-- sphinx script_files -->
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script src="../_static/translations.js"></script>

      
      <!-- bundled in js (rollup iife) -->
      <!-- <script src="../_static/theme-vendors.js"></script> -->
      <script src="../_static/theme.js" defer></script>
    
  <link rel="index" title="索引" href="../genindex.html" />
  <link rel="search" title="搜索" href="../search.html" /> 
  </head>

  <body>
    <div id="app">
    <div class="theme-container" :class="pageClasses"><navbar @toggle-sidebar="toggleSidebar">
  <router-link to="../index.html" class="home-link">
    
      <span class="site-name">MLIR 中文文档</span>
    
  </router-link>

  <div class="links">
    <navlinks class="can-hide">



    </navlinks>
  </div>
</navbar>

      
      <div class="sidebar-mask" @click="toggleSidebar(false)">
      </div>
        <sidebar @toggle-sidebar="toggleSidebar">
          
          <navlinks>
            



            
          </navlinks><div id="searchbox" class="searchbox" role="search">
  <div class="caption"><span class="caption-text">快速搜索</span>
    <div class="searchformwrapper">
      <form class="search" action="../search.html" method="get">
        <input type="text" name="q" />
        <input type="submit" value="搜索" />
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div><div class="sidebar-links" role="navigation" aria-label="main navigation">
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../index.html#mlir">欢迎使用 mlir 中文文档</a></span>
      </p>
      <ul class="">
        
          <li class="toctree-l1 ">
            
              <a href="../_index.html" class="reference internal ">开始使用MLIR</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/CreatingADialect.html" class="reference internal ">Creating a Dialect</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/DataFlowAnalysis.html" class="reference internal ">Writing DataFlow Analyses in MLIR</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/QuickstartRewrites.html" class="reference internal ">Quickstart tutorial to adding MLIR graph rewrite</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-1.html" class="reference internal ">第1章：Toy语言和AST（抽象语法树）</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-2.html" class="reference internal ">Chapter 2: Emitting Basic MLIR</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-3.html" class="reference internal ">Chapter 3: High-level Language-Specific Analysis and Transformation</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-4.html" class="reference internal ">Chapter 4: Enabling Generic Transformation with Interfaces</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-5.html" class="reference internal ">Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-6.html" class="reference internal ">Chapter 6: Lowering to LLVM and CodeGeneration</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-7.html" class="reference internal ">Chapter 7: Adding a Composite Type to Toy</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/_index.html" class="reference internal ">Toy 入门教程</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/UnderstandingTheIRStructure.html" class="reference internal ">Understanding the IR Structure</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/_index.html" class="reference internal ">Tutorials</a>
            

            
          </li>

        
      </ul>
    </div>
  
</div>
        </sidebar>

      <page>
          <div class="body-header" role="navigation" aria-label="navigation">
  
  <ul class="breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
    
    <li>MLIR Language Reference</li>
  </ul>
  

  <ul class="page-nav">
</ul>
  
</div>
<hr>
          <div class="content" role="main" v-pre>
            
  <section id="mlir-language-reference">
<h1>MLIR Language Reference<a class="headerlink" href="#mlir-language-reference" title="此标题的永久链接">¶</a></h1>
<p>MLIR (Multi-Level IR) is a compiler intermediate representation with
similarities to traditional three-address SSA representations (like
<a class="reference external" href="http://llvm.org/docs/LangRef.html">LLVM IR</a> or
<a class="reference external" href="https://github.com/apple/swift/blob/main/docs/SIL.rst">SIL</a>), but which
introduces notions from polyhedral loop optimization as first-class concepts.
This hybrid design is optimized to represent, analyze, and transform high level
dataflow graphs as well as target-specific code generated for high performance
data parallel systems. Beyond its representational capabilities, its single
continuous design provides a framework to lower from dataflow graphs to
high-performance target-specific code.</p>
<p>This document defines and describes the key concepts in MLIR, and is intended to
be a dry reference document - the
<a class="reference internal" href="Rationale/Rationale.html"><span class="doc">rationale documentation</span></a>,
<a class="reference external" href="../getting_started/Glossary">glossary</a>, and other content are hosted
elsewhere.</p>
<p>MLIR is designed to be used in three different forms: a human-readable textual
form suitable for debugging, an in-memory form suitable for programmatic
transformations and analysis, and a compact serialized form suitable for storage
and transport. The different forms all describe the same semantic content. This
document describes the human-readable textual form.</p>
<p>[TOC]</p>
<section id="high-level-structure">
<h2>High-Level Structure<a class="headerlink" href="#high-level-structure" title="此标题的永久链接">¶</a></h2>
<p>MLIR is fundamentally based on a graph-like data structure of nodes, called
<em>Operations</em>, and edges, called <em>Values</em>. Each Value is the result of exactly
one Operation or Block Argument, and has a <em>Value Type</em> defined by the
<a class="reference external" href="#type-system">type system</a>. <a class="reference external" href="#operations">Operations</a> are contained in
<a class="reference external" href="#blocks">Blocks</a> and Blocks are contained in <a class="reference external" href="#regions">Regions</a>. Operations
are also ordered within their containing block and Blocks are ordered in their
containing region, although this order may or may not be semantically meaningful
in a given <a class="reference external" href="Interfaces.md/#regionkindinterfaces">kind of region</a>). Operations
may also contain regions, enabling hierarchical structures to be represented.</p>
<p>Operations can represent many different concepts, from higher-level concepts
like function definitions, function calls, buffer allocations, view or slices of
buffers, and process creation, to lower-level concepts like target-independent
arithmetic, target-specific instructions, configuration registers, and logic
gates. These different concepts are represented by different operations in MLIR
and the set of operations usable in MLIR can be arbitrarily extended.</p>
<p>MLIR also provides an extensible framework for transformations on operations,
using familiar concepts of compiler <a class="reference internal" href="Passes.html"><span class="doc">Passes</span></a>. Enabling an arbitrary
set of passes on an arbitrary set of operations results in a significant scaling
challenge, since each transformation must potentially take into account the
semantics of any operation. MLIR addresses this complexity by allowing operation
semantics to be described abstractly using <a class="reference internal" href="Traits.html"><span class="doc">Traits</span></a> and
<a class="reference internal" href="Interfaces.html"><span class="doc">Interfaces</span></a>, enabling transformations to operate on operations
more generically. Traits often describe verification constraints on valid IR,
enabling complex invariants to be captured and checked. (see
<a class="reference external" href="Tutorials/Toy/Ch-2.md/#op-vs-operation-using-mlir-operations">Op vs Operation</a>)</p>
<p>One obvious application of MLIR is to represent an
<a class="reference external" href="https://en.wikipedia.org/wiki/Static_single_assignment_form">SSA-based</a> IR,
like the LLVM core IR, with appropriate choice of operation types to define
Modules, Functions, Branches, Memory Allocation, and verification constraints to
ensure the SSA Dominance property. MLIR includes a collection of dialects which
defines just such structures. However, MLIR is intended to be general enough to
represent other compiler-like data structures, such as Abstract Syntax Trees in
a language frontend, generated instructions in a target-specific backend, or
circuits in a High-Level Synthesis tool.</p>
<p>Here’s an example of an MLIR module:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>// Compute A*B using an implementation of multiply kernel and print the
// result using a TensorFlow op. The dimensions of A and B are partially
// known. The shapes are assumed to match.
func.func @mul(%A: tensor&lt;100x?xf32&gt;, %B: tensor&lt;?x50xf32&gt;) -&gt; (tensor&lt;100x50xf32&gt;) {
  // Compute the inner dimension of %A using the dim operation.
  %n = memref.dim %A, 1 : tensor&lt;100x?xf32&gt;

  // Allocate addressable &quot;buffers&quot; and copy tensors %A and %B into them.
  %A_m = memref.alloc(%n) : memref&lt;100x?xf32&gt;
  memref.tensor_store %A to %A_m : memref&lt;100x?xf32&gt;

  %B_m = memref.alloc(%n) : memref&lt;?x50xf32&gt;
  memref.tensor_store %B to %B_m : memref&lt;?x50xf32&gt;

  // Call function @multiply passing memrefs as arguments,
  // and getting returned the result of the multiplication.
  %C_m = call @multiply(%A_m, %B_m)
          : (memref&lt;100x?xf32&gt;, memref&lt;?x50xf32&gt;) -&gt; (memref&lt;100x50xf32&gt;)

  memref.dealloc %A_m : memref&lt;100x?xf32&gt;
  memref.dealloc %B_m : memref&lt;?x50xf32&gt;

  // Load the buffer data into a higher level &quot;tensor&quot; value.
  %C = memref.tensor_load %C_m : memref&lt;100x50xf32&gt;
  memref.dealloc %C_m : memref&lt;100x50xf32&gt;

  // Call TensorFlow built-in function to print the result tensor.
  &quot;tf.Print&quot;(%C){message: &quot;mul result&quot;} : (tensor&lt;100x50xf32&gt;) -&gt; (tensor&lt;100x50xf32&gt;)

  return %C : tensor&lt;100x50xf32&gt;
}

// A function that multiplies two memrefs and returns the result.
func.func @multiply(%A: memref&lt;100x?xf32&gt;, %B: memref&lt;?x50xf32&gt;)
          -&gt; (memref&lt;100x50xf32&gt;)  {
  // Compute the inner dimension of %A.
  %n = memref.dim %A, 1 : memref&lt;100x?xf32&gt;

  // Allocate memory for the multiplication result.
  %C = memref.alloc() : memref&lt;100x50xf32&gt;

  // Multiplication loop nest.
  affine.for %i = 0 to 100 {
     affine.for %j = 0 to 50 {
        memref.store 0 to %C[%i, %j] : memref&lt;100x50xf32&gt;
        affine.for %k = 0 to %n {
           %a_v  = memref.load %A[%i, %k] : memref&lt;100x?xf32&gt;
           %b_v  = memref.load %B[%k, %j] : memref&lt;?x50xf32&gt;
           %prod = arith.mulf %a_v, %b_v : f32
           %c_v  = memref.load %C[%i, %j] : memref&lt;100x50xf32&gt;
           %sum  = arith.addf %c_v, %prod : f32
           memref.store %sum, %C[%i, %j] : memref&lt;100x50xf32&gt;
        }
     }
  }
  return %C : memref&lt;100x50xf32&gt;
}
</pre></div>
</div>
</section>
<section id="notation">
<h2>Notation<a class="headerlink" href="#notation" title="此标题的永久链接">¶</a></h2>
<p>MLIR has a simple and unambiguous grammar, allowing it to reliably round-trip
through a textual form. This is important for development of the compiler - e.g.
for understanding the state of code as it is being transformed and writing test
cases.</p>
<p>This document describes the grammar using
<a class="reference external" href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form">Extended Backus-Naur Form (EBNF)</a>.</p>
<p>This is the EBNF grammar used in this document, presented in yellow boxes.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>alternation ::= expr0 | expr1 | expr2  // Either expr0 or expr1 or expr2.
sequence    ::= expr0 expr1 expr2      // Sequence of expr0 expr1 expr2.
repetition0 ::= expr*  // 0 or more occurrences.
repetition1 ::= expr+  // 1 or more occurrences.
optionality ::= expr?  // 0 or 1 occurrence.
grouping    ::= (expr) // Everything inside parens is grouped together.
literal     ::= `abcd` // Matches the literal `abcd`.
</pre></div>
</div>
<p>Code examples are presented in blue boxes.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// This is an example use of the grammar above:
// This matches things like: ba, bana, boma, banana, banoma, bomana...
example ::= `b` (`an` | `om`)* `a`
</pre></div>
</div>
<section id="common-syntax">
<h3>Common syntax<a class="headerlink" href="#common-syntax" title="此标题的永久链接">¶</a></h3>
<p>The following core grammar productions are used in this document:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// TODO: Clarify the split between lexing (tokens) and parsing (grammar).
digit     ::= [0-9]
hex_digit ::= [0-9a-fA-F]
letter    ::= [a-zA-Z]
id-punct  ::= [$._-]

integer-literal ::= decimal-literal | hexadecimal-literal
decimal-literal ::= digit+
hexadecimal-literal ::= `0x` hex_digit+
float-literal ::= [-+]?[0-9]+[.][0-9]*([eE][-+]?[0-9]+)?
string-literal  ::= `&quot;` [^&quot;\n\f\v\r]* `&quot;`   TODO: define escaping rules
</pre></div>
</div>
<p>Not listed here, but MLIR does support comments. They use standard BCPL syntax,
starting with a <code class="docutils literal notranslate"><span class="pre">//</span></code> and going until the end of the line.</p>
</section>
<section id="top-level-productions">
<h3>Top level Productions<a class="headerlink" href="#top-level-productions" title="此标题的永久链接">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Top</span> <span class="n">level</span> <span class="n">production</span>
<span class="n">toplevel</span> <span class="o">:=</span> <span class="p">(</span><span class="n">operation</span> <span class="o">|</span> <span class="n">attribute</span><span class="o">-</span><span class="n">alias</span><span class="o">-</span><span class="k">def</span> <span class="o">|</span> <span class="nb">type</span><span class="o">-</span><span class="n">alias</span><span class="o">-</span><span class="n">def</span><span class="p">)</span><span class="o">*</span>
</pre></div>
</div>
<p>The production <code class="docutils literal notranslate"><span class="pre">toplevel</span></code> is the top level production that is parsed by any parsing
consuming the MLIR syntax. <a class="reference external" href="#operations">Operations</a>,
<a class="reference external" href="#attribute-value-aliases">Attribute aliases</a>, and <a class="reference external" href="#type-aliases">Type aliases</a>
can be declared on the toplevel.</p>
</section>
<section id="identifiers-and-keywords">
<h3>Identifiers and keywords<a class="headerlink" href="#identifiers-and-keywords" title="此标题的永久链接">¶</a></h3>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// Identifiers
bare-id ::= (letter|[_]) (letter|digit|[_$.])*
bare-id-list ::= bare-id (`,` bare-id)*
value-id ::= `%` suffix-id
alias-name :: = bare-id
suffix-id ::= (digit+ | ((letter|id-punct) (letter|id-punct|digit)*))

symbol-ref-id ::= `@` (suffix-id | string-literal) (`::` symbol-ref-id)?
value-id-list ::= value-id (`,` value-id)*

// Uses of value, e.g. in an operand list to an operation.
value-use ::= value-id
value-use-list ::= value-use (`,` value-use)*
</pre></div>
</div>
<p>Identifiers name entities such as values, types and functions, and are chosen by
the writer of MLIR code. Identifiers may be descriptive (e.g. <code class="docutils literal notranslate"><span class="pre">%batch_size</span></code>,
<code class="docutils literal notranslate"><span class="pre">&#64;matmul</span></code>), or may be non-descriptive when they are auto-generated (e.g. <code class="docutils literal notranslate"><span class="pre">%23</span></code>,
<code class="docutils literal notranslate"><span class="pre">&#64;func42</span></code>). Identifier names for values may be used in an MLIR text file but are
not persisted as part of the IR - the printer will give them anonymous names
like <code class="docutils literal notranslate"><span class="pre">%42</span></code>.</p>
<p>MLIR guarantees identifiers never collide with keywords by prefixing identifiers
with a sigil (e.g. <code class="docutils literal notranslate"><span class="pre">%</span></code>, <code class="docutils literal notranslate"><span class="pre">#</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>, <code class="docutils literal notranslate"><span class="pre">^</span></code>, <code class="docutils literal notranslate"><span class="pre">!</span></code>). In certain unambiguous contexts
(e.g. affine expressions), identifiers are not prefixed, for brevity. New
keywords may be added to future versions of MLIR without danger of collision
with existing identifiers.</p>
<p>Value identifiers are only <a class="reference external" href="#value-scoping">in scope</a> for the (nested) region in
which they are defined and cannot be accessed or referenced outside of that
region. Argument identifiers in mapping functions are in scope for the mapping
body. Particular operations may further limit which identifiers are in scope in
their regions. For instance, the scope of values in a region with
<a class="reference external" href="#control-flow-and-ssacfg-regions">SSA control flow semantics</a> is constrained
according to the standard definition of
<a class="reference external" href="https://en.wikipedia.org/wiki/Dominator_(graph_theory)">SSA dominance</a>.
Another example is the <a class="reference external" href="Traits.md/#isolatedfromabove">IsolatedFromAbove trait</a>,
which restricts directly accessing values defined in containing regions.</p>
<p>Function identifiers and mapping identifiers are associated with
<a class="reference internal" href="SymbolsAndSymbolTables.html"><span class="doc">Symbols</span></a> and have scoping rules dependent on symbol
attributes.</p>
</section>
</section>
<section id="dialects">
<h2>Dialects<a class="headerlink" href="#dialects" title="此标题的永久链接">¶</a></h2>
<p>Dialects are the mechanism by which to engage with and extend the MLIR
ecosystem. They allow for defining new <a class="reference external" href="#operations">operations</a>, as well as
<a class="reference external" href="#attributes">attributes</a> and <a class="reference external" href="#type-system">types</a>. Each dialect is given a
unique <code class="docutils literal notranslate"><span class="pre">namespace</span></code> that is prefixed to each defined attribute/operation/type.
For example, the <a class="reference internal" href="Dialects/Affine.html"><span class="doc">Affine dialect</span></a> defines the namespace:
<code class="docutils literal notranslate"><span class="pre">affine</span></code>.</p>
<p>MLIR allows for multiple dialects, even those outside of the main tree, to
co-exist together within one module. Dialects are produced and consumed by
certain passes. MLIR provides a <a class="reference internal" href="DialectConversion.html"><span class="doc">framework</span></a> to convert
between, and within, different dialects.</p>
<p>A few of the dialects supported by MLIR:</p>
<ul class="simple">
<li><p><a class="reference internal" href="Dialects/Affine.html"><span class="doc">Affine dialect</span></a></p></li>
<li><p><a class="reference internal" href="Dialects/Func.html"><span class="doc">Func dialect</span></a></p></li>
<li><p><a class="reference internal" href="Dialects/GPU.html"><span class="doc">GPU dialect</span></a></p></li>
<li><p><a class="reference internal" href="Dialects/LLVM.html"><span class="doc">LLVM dialect</span></a></p></li>
<li><p><a class="reference internal" href="Dialects/SPIR-V.html"><span class="doc">SPIR-V dialect</span></a></p></li>
<li><p><a class="reference internal" href="Dialects/Vector.html"><span class="doc">Vector dialect</span></a></p></li>
</ul>
<section id="target-specific-operations">
<h3>Target specific operations<a class="headerlink" href="#target-specific-operations" title="此标题的永久链接">¶</a></h3>
<p>Dialects provide a modular way in which targets can expose target-specific
operations directly through to MLIR. As an example, some targets go through
LLVM. LLVM has a rich set of intrinsics for certain target-independent
operations (e.g. addition with overflow check) as well as providing access to
target-specific operations for the targets it supports (e.g. vector permutation
operations). LLVM intrinsics in MLIR are represented via operations that start
with an “llvm.” name.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>// LLVM: %x = call {i16, i1} @llvm.sadd.with.overflow.i16(i16 %a, i16 %b)
%x:2 = &quot;llvm.sadd.with.overflow.i16&quot;(%a, %b) : (i16, i16) -&gt; (i16, i1)
</pre></div>
</div>
<p>These operations only work when targeting LLVM as a backend (e.g. for CPUs and
GPUs), and are required to align with the LLVM definition of these intrinsics.</p>
</section>
</section>
<section id="operations">
<h2>Operations<a class="headerlink" href="#operations" title="此标题的永久链接">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation            ::= op-result-list? (generic-operation | custom-operation)
                         trailing-location?
generic-operation    ::= string-literal `(` value-use-list? `)`  successor-list?
                         region-list? dictionary-attribute? `:` function-type
custom-operation     ::= bare-id custom-operation-format
op-result-list       ::= op-result (`,` op-result)* `=`
op-result            ::= value-id (`:` integer-literal)
successor-list       ::= `[` successor (`,` successor)* `]`
successor            ::= caret-id (`:` block-arg-list)?
region-list          ::= `(` region (`,` region)* `)`
dictionary-attribute ::= `{` (attribute-entry (`,` attribute-entry)*)? `}`
trailing-location    ::= (`loc` `(` location `)`)?
</pre></div>
</div>
<p>MLIR introduces a uniform concept called <em>operations</em> to enable describing many
different levels of abstractions and computations. Operations in MLIR are fully
extensible (there is no fixed list of operations) and have application-specific
semantics. For example, MLIR supports
<a class="reference internal" href="Dialects/MemRef.html"><span class="doc">target-independent operations</span></a>,
<a class="reference internal" href="Dialects/Affine.html"><span class="doc">affine operations</span></a>, and
<a class="reference external" href="#target-specific-operations">target-specific machine operations</a>.</p>
<p>The internal representation of an operation is simple: an operation is
identified by a unique string (e.g. <code class="docutils literal notranslate"><span class="pre">dim</span></code>, <code class="docutils literal notranslate"><span class="pre">tf.Conv2d</span></code>, <code class="docutils literal notranslate"><span class="pre">x86.repmovsb</span></code>,
<code class="docutils literal notranslate"><span class="pre">ppc.eieio</span></code>, etc), can return zero or more results, take zero or more operands,
has a dictionary of <a class="reference external" href="#attributes">attributes</a>, has zero or more successors, and
zero or more enclosed <a class="reference external" href="#regions">regions</a>. The generic printing form includes
all these elements literally, with a function type to indicate the types of the
results and operands.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>// An operation that produces two results.
// The results of %result can be accessed via the &lt;name&gt; `#` &lt;opNo&gt; syntax.
%result:2 = &quot;foo_div&quot;() : () -&gt; (f32, i32)

// Pretty form that defines a unique name for each result.
%foo, %bar = &quot;foo_div&quot;() : () -&gt; (f32, i32)

// Invoke a TensorFlow function called tf.scramble with two inputs
// and an attribute &quot;fruit&quot;.
%2 = &quot;tf.scramble&quot;(%result#0, %bar) {fruit = &quot;banana&quot;} : (f32, i32) -&gt; f32
</pre></div>
</div>
<p>In addition to the basic syntax above, dialects may register known operations.
This allows those dialects to support <em>custom assembly form</em> for parsing and
printing operations. In the operation sets listed below, we show both forms.</p>
<section id="builtin-operations">
<h3>Builtin Operations<a class="headerlink" href="#builtin-operations" title="此标题的永久链接">¶</a></h3>
<p>The <a class="reference internal" href="Dialects/Builtin.html"><span class="doc">builtin dialect</span></a> defines a select few operations that
are widely applicable by MLIR dialects, such as a universal conversion cast
operation that simplifies inter/intra dialect conversion. This dialect also
defines a top-level <code class="docutils literal notranslate"><span class="pre">module</span></code> operation, that represents a useful IR container.</p>
</section>
</section>
<section id="blocks">
<h2>Blocks<a class="headerlink" href="#blocks" title="此标题的永久链接">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>block           ::= block-label operation+
block-label     ::= block-id block-arg-list? `:`
block-id        ::= caret-id
caret-id        ::= `^` suffix-id
value-id-and-type ::= value-id `:` type

// Non-empty list of names and types.
value-id-and-type-list ::= value-id-and-type (`,` value-id-and-type)*

block-arg-list ::= `(` value-id-and-type-list? `)`
</pre></div>
</div>
<p>A <em>Block</em> is a list of operations. In
<a class="reference external" href="#control-flow-and-ssacfg-regions">SSACFG regions</a>, each block represents a
compiler <a class="reference external" href="https://en.wikipedia.org/wiki/Basic_block">basic block</a> where
instructions inside the block are executed in order and terminator operations
implement control flow branches between basic blocks.</p>
<p>The last operation in a block must be a
<a class="reference external" href="#control-flow-and-ssacfg-regions">terminator operation</a>. A region with a single
block may opt out of this requirement by attaching the <code class="docutils literal notranslate"><span class="pre">NoTerminator</span></code> on the
enclosing op. The top-level <code class="docutils literal notranslate"><span class="pre">ModuleOp</span></code> is an example of such an operation which
defines this trait and whose block body does not have a terminator.</p>
<p>Blocks in MLIR take a list of block arguments, notated in a function-like way.
Block arguments are bound to values specified by the semantics of individual
operations. Block arguments of the entry block of a region are also arguments to
the region and the values bound to these arguments are determined by the
semantics of the containing operation. Block arguments of other blocks are
determined by the semantics of terminator operations, e.g. Branches, which have
the block as a successor. In regions with
<a class="reference external" href="#control-flow-and-ssacfg-regions">control flow</a>, MLIR leverages this structure
to implicitly represent the passage of control-flow dependent values without the
complex nuances of PHI nodes in traditional SSA representations. Note that
values which are not control-flow dependent can be referenced directly and do
not need to be passed through block arguments.</p>
<p>Here is a simple example function showing branches, returns, and block
arguments:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>func.func @simple(i64, i1) -&gt; i64 {
^bb0(%a: i64, %cond: i1): // Code dominated by ^bb0 may refer to %a
  cf.cond_br %cond, ^bb1, ^bb2

^bb1:
  cf.br ^bb3(%a: i64)    // Branch passes %a as the argument

^bb2:
  %b = arith.addi %a, %a : i64
  cf.br ^bb3(%b: i64)    // Branch passes %b as the argument

// ^bb3 receives an argument, named %c, from predecessors
// and passes it on to bb4 along with %a. %a is referenced
// directly from its defining operation and is not passed through
// an argument of ^bb3.
^bb3(%c: i64):
  cf.br ^bb4(%c, %a : i64, i64)

^bb4(%d : i64, %e : i64):
  %0 = arith.addi %d, %e : i64
  return %0 : i64   // Return is also a terminator.
}
</pre></div>
</div>
<p><strong>Context:</strong> The “block argument” representation eliminates a number of special
cases from the IR compared to traditional “PHI nodes are operations” SSA IRs
(like LLVM). For example, the
<a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.524.5461&amp;rep=rep1&amp;type=pdf">parallel copy semantics</a>
of SSA is immediately apparent, and function arguments are no longer a special
case: they become arguments to the entry block
[<a class="reference external" href="Rationale/Rationale.md/#block-arguments-vs-phi-nodes">more rationale</a>]. Blocks
are also a fundamental concept that cannot be represented by operations because
values defined in an operation cannot be accessed outside the operation.</p>
</section>
<section id="regions">
<h2>Regions<a class="headerlink" href="#regions" title="此标题的永久链接">¶</a></h2>
<section id="definition">
<h3>Definition<a class="headerlink" href="#definition" title="此标题的永久链接">¶</a></h3>
<p>A region is an ordered list of MLIR <a class="reference external" href="#blocks">Blocks</a>. The semantics within a
region is not imposed by the IR. Instead, the containing operation defines the
semantics of the regions it contains. MLIR currently defines two kinds of
regions: <a class="reference external" href="#control-flow-and-ssacfg-regions">SSACFG regions</a>, which describe
control flow between blocks, and <a class="reference external" href="#graph-regions">Graph regions</a>, which do not
require control flow between block. The kinds of regions within an operation are
described using the <a class="reference external" href="Interfaces.md/#regionkindinterfaces">RegionKindInterface</a>.</p>
<p>Regions do not have a name or an address, only the blocks contained in a region
do. Regions must be contained within operations and have no type or attributes.
The first block in the region is a special block called the ‘entry block’. The
arguments to the entry block are also the arguments of the region itself. The
entry block cannot be listed as a successor of any other block. The syntax for a
region is as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>region      ::= `{` entry-block? block* `}`
entry-block ::= operation+
</pre></div>
</div>
<p>A function body is an example of a region: it consists of a CFG of blocks and
has additional semantic restrictions that other types of regions may not have.
For example, in a function body, block terminators must either branch to a
different block, or return from a function where the types of the <code class="docutils literal notranslate"><span class="pre">return</span></code>
arguments must match the result types of the function signature. Similarly, the
function arguments must match the types and count of the region arguments. In
general, operations with regions can define these correspondences arbitrarily.</p>
<p>An <em>entry block</em> is a block with no label and no arguments that may occur at
the beginning of a region. It enables a common pattern of using a region to
open a new scope.</p>
</section>
<section id="value-scoping">
<h3>Value Scoping<a class="headerlink" href="#value-scoping" title="此标题的永久链接">¶</a></h3>
<p>Regions provide hierarchical encapsulation of programs: it is impossible to
reference, i.e. branch to, a block which is not in the same region as the source
of the reference, i.e. a terminator operation. Similarly, regions provides a
natural scoping for value visibility: values defined in a region don’t escape to
the enclosing region, if any. By default, operations inside a region can
reference values defined outside of the region whenever it would have been legal
for operands of the enclosing operation to reference those values, but this can
be restricted using traits, such as
<a class="reference external" href="Traits.md/#isolatedfromabove">OpTrait::IsolatedFromAbove</a>, or a custom
verifier.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  &quot;any_op&quot;(%a) ({ // if %a is in-scope in the containing region...
     // then %a is in-scope here too.
    %new_value = &quot;another_op&quot;(%a) : (i64) -&gt; (i64)
  }) : (i64) -&gt; (i64)
</pre></div>
</div>
<p>MLIR defines a generalized ‘hierarchical dominance’ concept that operates across
hierarchy and defines whether a value is ‘in scope’ and can be used by a
particular operation. Whether a value can be used by another operation in the
same region is defined by the kind of region. A value defined in a region can be
used by an operation which has a parent in the same region, if and only if the
parent could use the value. A value defined by an argument to a region can
always be used by any operation deeply contained in the region. A value defined
in a region can never be used outside of the region.</p>
</section>
<section id="control-flow-and-ssacfg-regions">
<h3>Control Flow and SSACFG Regions<a class="headerlink" href="#control-flow-and-ssacfg-regions" title="此标题的永久链接">¶</a></h3>
<p>In MLIR, control flow semantics of a region is indicated by
<a class="reference external" href="Interfaces.md/#regionkindinterfaces">RegionKind::SSACFG</a>. Informally, these
regions support semantics where operations in a region ‘execute sequentially’.
Before an operation executes, its operands have well-defined values. After an
operation executes, the operands have the same values and results also have
well-defined values. After an operation executes, the next operation in the
block executes until the operation is the terminator operation at the end of a
block, in which case some other operation will execute. The determination of the
next instruction to execute is the ‘passing of control flow’.</p>
<p>In general, when control flow is passed to an operation, MLIR does not restrict
when control flow enters or exits the regions contained in that operation.
However, when control flow enters a region, it always begins in the first block
of the region, called the <em>entry</em> block. Terminator operations ending each block
represent control flow by explicitly specifying the successor blocks of the
block. Control flow can only pass to one of the specified successor blocks as in
a <code class="docutils literal notranslate"><span class="pre">branch</span></code> operation, or back to the containing operation as in a <code class="docutils literal notranslate"><span class="pre">return</span></code>
operation. Terminator operations without successors can only pass control back
to the containing operation. Within these restrictions, the particular semantics
of terminator operations is determined by the specific dialect operations
involved. Blocks (other than the entry block) that are not listed as a successor
of a terminator operation are defined to be unreachable and can be removed
without affecting the semantics of the containing operation.</p>
<p>Although control flow always enters a region through the entry block, control
flow may exit a region through any block with an appropriate terminator. The
standard dialect leverages this capability to define operations with
Single-Entry-Multiple-Exit (SEME) regions, possibly flowing through different
blocks in the region and exiting through any block with a <code class="docutils literal notranslate"><span class="pre">return</span></code> operation.
This behavior is similar to that of a function body in most programming
languages. In addition, control flow may also not reach the end of a block or
region, for example if a function call does not return.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>func.func @accelerator_compute(i64, i1) -&gt; i64 { // An SSACFG region
^bb0(%a: i64, %cond: i1): // Code dominated by ^bb0 may refer to %a
  cf.cond_br %cond, ^bb1, ^bb2

^bb1:
  // This def for %value does not dominate ^bb2
  %value = &quot;op.convert&quot;(%a) : (i64) -&gt; i64
  cf.br ^bb3(%a: i64)    // Branch passes %a as the argument

^bb2:
  accelerator.launch() { // An SSACFG region
    ^bb0:
      // Region of code nested under &quot;accelerator.launch&quot;, it can reference %a but
      // not %value.
      %new_value = &quot;accelerator.do_something&quot;(%a) : (i64) -&gt; ()
  }
  // %new_value cannot be referenced outside of the region

^bb3:
  ...
}
</pre></div>
</div>
<section id="operations-with-multiple-regions">
<h4>Operations with Multiple Regions<a class="headerlink" href="#operations-with-multiple-regions" title="此标题的永久链接">¶</a></h4>
<p>An operation containing multiple regions also completely determines the
semantics of those regions. In particular, when control flow is passed to an
operation, it may transfer control flow to any contained region. When control
flow exits a region and is returned to the containing operation, the containing
operation may pass control flow to any region in the same operation. An
operation may also pass control flow to multiple contained regions concurrently.
An operation may also pass control flow into regions that were specified in
other operations, in particular those that defined the values or symbols the
given operation uses as in a call operation. This passage of control is
generally independent of passage of control flow through the basic blocks of the
containing region.</p>
</section>
<section id="closure">
<h4>Closure<a class="headerlink" href="#closure" title="此标题的永久链接">¶</a></h4>
<p>Regions allow defining an operation that creates a closure, for example by
“boxing” the body of the region into a value they produce. It remains up to the
operation to define its semantics. Note that if an operation triggers
asynchronous execution of the region, it is under the responsibility of the
operation caller to wait for the region to be executed guaranteeing that any
directly used values remain live.</p>
</section>
</section>
<section id="graph-regions">
<h3>Graph Regions<a class="headerlink" href="#graph-regions" title="此标题的永久链接">¶</a></h3>
<p>In MLIR, graph-like semantics in a region is indicated by
<a class="reference external" href="Interfaces.md/#regionkindinterfaces">RegionKind::Graph</a>. Graph regions are
appropriate for concurrent semantics without control flow, or for modeling
generic directed graph data structures. Graph regions are appropriate for
representing cyclic relationships between coupled values where there is no
fundamental order to the relationships. For instance, operations in a graph
region may represent independent threads of control with values representing
streams of data. As usual in MLIR, the particular semantics of a region is
completely determined by its containing operation. Graph regions may only
contain a single basic block (the entry block).</p>
<p><strong>Rationale:</strong> Currently graph regions are arbitrarily limited to a single basic
block, although there is no particular semantic reason for this limitation. This
limitation has been added to make it easier to stabilize the pass infrastructure
and commonly used passes for processing graph regions to properly handle
feedback loops. Multi-block regions may be allowed in the future if use cases
that require it arise.</p>
<p>In graph regions, MLIR operations naturally represent nodes, while each MLIR
value represents a multi-edge connecting a single source node and multiple
destination nodes. All values defined in the region as results of operations are
in scope within the region and can be accessed by any other operation in the
region. In graph regions, the order of operations within a block and the order
of blocks in a region is not semantically meaningful and non-terminator
operations may be freely reordered, for instance, by canonicalization. Other
kinds of graphs, such as graphs with multiple source nodes and multiple
destination nodes, can also be represented by representing graph edges as MLIR
operations.</p>
<p>Note that cycles can occur within a single block in a graph region, or between
basic blocks.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>&quot;test.graph_region&quot;() ({ // A Graph region
  %1 = &quot;op1&quot;(%1, %3) : (i32, i32) -&gt; (i32)  // OK: %1, %3 allowed here
  %2 = &quot;test.ssacfg_region&quot;() ({
     %5 = &quot;op2&quot;(%1, %2, %3, %4) : (i32, i32, i32, i32) -&gt; (i32) // OK: %1, %2, %3, %4 all defined in the containing region
  }) : () -&gt; (i32)
  %3 = &quot;op2&quot;(%1, %4) : (i32, i32) -&gt; (i32)  // OK: %4 allowed here
  %4 = &quot;op3&quot;(%1) : (i32) -&gt; (i32)
}) : () -&gt; ()
</pre></div>
</div>
</section>
<section id="arguments-and-results">
<h3>Arguments and Results<a class="headerlink" href="#arguments-and-results" title="此标题的永久链接">¶</a></h3>
<p>The arguments of the first block of a region are treated as arguments of the
region. The source of these arguments is defined by the semantics of the parent
operation. They may correspond to some of the values the operation itself uses.</p>
<p>Regions produce a (possibly empty) list of values. The operation semantics
defines the relation between the region results and the operation results.</p>
</section>
</section>
<section id="type-system">
<h2>Type System<a class="headerlink" href="#type-system" title="此标题的永久链接">¶</a></h2>
<p>Each value in MLIR has a type defined by the type system. MLIR has an open type
system (i.e. there is no fixed list of types), and types may have
application-specific semantics. MLIR dialects may define any number of types
with no restrictions on the abstractions they represent.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>type ::= type-alias | dialect-type | builtin-type

type-list-no-parens ::=  type (`,` type)*
type-list-parens ::= `(` `)`
                   | `(` type-list-no-parens `)`

// This is a common way to refer to a value with a specified type.
ssa-use-and-type ::= ssa-use `:` type
ssa-use ::= value-use

// Non-empty list of names and types.
ssa-use-and-type-list ::= ssa-use-and-type (`,` ssa-use-and-type)*

function-type ::= (type | type-list-parens) `-&gt;` (type | type-list-parens)
</pre></div>
</div>
<section id="type-aliases">
<h3>Type Aliases<a class="headerlink" href="#type-aliases" title="此标题的永久链接">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">type</span><span class="o">-</span><span class="n">alias</span><span class="o">-</span><span class="k">def</span> <span class="p">:</span><span class="o">:=</span> <span class="s1">&#39;!&#39;</span> <span class="n">alias</span><span class="o">-</span><span class="n">name</span> <span class="s1">&#39;=&#39;</span> <span class="nb">type</span>
<span class="nb">type</span><span class="o">-</span><span class="n">alias</span> <span class="p">:</span><span class="o">:=</span> <span class="s1">&#39;!&#39;</span> <span class="n">alias</span><span class="o">-</span><span class="n">name</span>
</pre></div>
</div>
<p>MLIR supports defining named aliases for types. A type alias is an identifier
that can be used in the place of the type that it defines. These aliases <em>must</em>
be defined before their uses. Alias names may not contain a ‘.’, since those
names are reserved for <a class="reference external" href="#dialect-types">dialect types</a>.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>!avx_m128 = vector&lt;4 x f32&gt;

// Using the original type.
&quot;foo&quot;(%x) : vector&lt;4 x f32&gt; -&gt; ()

// Using the type alias.
&quot;foo&quot;(%x) : !avx_m128 -&gt; ()
</pre></div>
</div>
</section>
<section id="dialect-types">
<h3>Dialect Types<a class="headerlink" href="#dialect-types" title="此标题的永久链接">¶</a></h3>
<p>Similarly to operations, dialects may define custom extensions to the type
system.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>dialect-namespace ::= bare-id

dialect-type ::= &#39;!&#39; (opaque-dialect-type | pretty-dialect-type)
opaque-dialect-type ::= dialect-namespace dialect-type-body
pretty-dialect-type ::= dialect-namespace &#39;.&#39; pretty-dialect-type-lead-ident
                                              dialect-type-body?
pretty-dialect-type-lead-ident ::= &#39;[A-Za-z][A-Za-z0-9._]*&#39;

dialect-type-body ::= &#39;&lt;&#39; dialect-type-contents+ &#39;&gt;&#39;
dialect-type-contents ::= dialect-type-body
                            | &#39;(&#39; dialect-type-contents+ &#39;)&#39;
                            | &#39;[&#39; dialect-type-contents+ &#39;]&#39;
                            | &#39;{&#39; dialect-type-contents+ &#39;}&#39;
                            | &#39;[^\[&lt;({\]&gt;)}\0]+&#39;
</pre></div>
</div>
<p>Dialect types are generally specified in an opaque form, where the contents
of the type are defined within a body wrapped with the dialect namespace
and <code class="docutils literal notranslate"><span class="pre">&lt;&gt;</span></code>. Consider the following examples:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>// A tensorflow string type.
!tf&lt;string&gt;

// A type with complex components.
!foo&lt;something&lt;abcd&gt;&gt;

// An even more complex type.
!foo&lt;&quot;a123^^^&quot; + bar&gt;
</pre></div>
</div>
<p>Dialect types that are simple enough may use a prettier format, which unwraps
part of the syntax into an equivalent, but lighter weight form:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>// A tensorflow string type.
!tf.string

// A type with complex components.
!foo.something&lt;abcd&gt;
</pre></div>
</div>
<p>See <a class="reference internal" href="DefiningDialects/AttributesAndTypes.html"><span class="doc">here</span></a> to learn how to define dialect types.</p>
</section>
<section id="builtin-types">
<h3>Builtin Types<a class="headerlink" href="#builtin-types" title="此标题的永久链接">¶</a></h3>
<p>The <a class="reference internal" href="Dialects/Builtin.html"><span class="doc">builtin dialect</span></a> defines a set of types that are
directly usable by any other dialect in MLIR. These types cover a range from
primitive integer and floating-point types, function types, and more.</p>
</section>
</section>
<section id="attributes">
<h2>Attributes<a class="headerlink" href="#attributes" title="此标题的永久链接">¶</a></h2>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>attribute-entry ::= (bare-id | string-literal) `=` attribute-value
attribute-value ::= attribute-alias | dialect-attribute | builtin-attribute
</pre></div>
</div>
<p>Attributes are the mechanism for specifying constant data on operations in
places where a variable is never allowed - e.g. the comparison predicate of a
<a class="reference external" href="Dialects/ArithOps.md#arithcmpi-mlirarithcmpiop"><code class="docutils literal notranslate"><span class="pre">cmpi</span></code> operation</a>. Each operation has an
attribute dictionary, which associates a set of attribute names to attribute
values. MLIR’s builtin dialect provides a rich set of
<a class="reference external" href="#builtin-attribute-values">builtin attribute values</a> out of the box (such as
arrays, dictionaries, strings, etc.). Additionally, dialects can define their
own <a class="reference external" href="#dialect-attribute-values">dialect attribute values</a>.</p>
<p>The top-level attribute dictionary attached to an operation has special
semantics. The attribute entries are considered to be of two different kinds
based on whether their dictionary key has a dialect prefix:</p>
<ul class="simple">
<li><p><em>inherent attributes</em> are inherent to the definition of an operation’s
semantics. The operation itself is expected to verify the consistency of
these attributes. An example is the <code class="docutils literal notranslate"><span class="pre">predicate</span></code> attribute of the
<code class="docutils literal notranslate"><span class="pre">arith.cmpi</span></code> op. These attributes must have names that do not start with a
dialect prefix.</p></li>
<li><p><em>discardable attributes</em> have semantics defined externally to the operation
itself, but must be compatible with the operations’s semantics. These
attributes must have names that start with a dialect prefix. The dialect
indicated by the dialect prefix is expected to verify these attributes. An
example is the <code class="docutils literal notranslate"><span class="pre">gpu.container_module</span></code> attribute.</p></li>
</ul>
<p>Note that attribute values are allowed to themselves be dictionary attributes,
but only the top-level dictionary attribute attached to the operation is subject
to the classification above.</p>
<section id="attribute-value-aliases">
<h3>Attribute Value Aliases<a class="headerlink" href="#attribute-value-aliases" title="此标题的永久链接">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">attribute</span><span class="o">-</span><span class="n">alias</span><span class="o">-</span><span class="k">def</span> <span class="p">:</span><span class="o">:=</span> <span class="s1">&#39;#&#39;</span> <span class="n">alias</span><span class="o">-</span><span class="n">name</span> <span class="s1">&#39;=&#39;</span> <span class="n">attribute</span><span class="o">-</span><span class="n">value</span>
<span class="n">attribute</span><span class="o">-</span><span class="n">alias</span> <span class="p">:</span><span class="o">:=</span> <span class="s1">&#39;#&#39;</span> <span class="n">alias</span><span class="o">-</span><span class="n">name</span>
</pre></div>
</div>
<p>MLIR supports defining named aliases for attribute values. An attribute alias is
an identifier that can be used in the place of the attribute that it defines.
These aliases <em>must</em> be defined before their uses. Alias names may not contain a
‘.’, since those names are reserved for
<a class="reference external" href="#dialect-attribute-values">dialect attributes</a>.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>#map = affine_map&lt;(d0) -&gt; (d0 + 10)&gt;

// Using the original attribute.
%b = affine.apply affine_map&lt;(d0) -&gt; (d0 + 10)&gt; (%a)

// Using the attribute alias.
%b = affine.apply #map(%a)
</pre></div>
</div>
</section>
<section id="dialect-attribute-values">
<h3>Dialect Attribute Values<a class="headerlink" href="#dialect-attribute-values" title="此标题的永久链接">¶</a></h3>
<p>Similarly to operations, dialects may define custom attribute values.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>dialect-namespace ::= bare-id

dialect-attribute ::= &#39;#&#39; (opaque-dialect-attribute | pretty-dialect-attribute)
opaque-dialect-attribute ::= dialect-namespace dialect-attribute-body
pretty-dialect-attribute ::= dialect-namespace &#39;.&#39; pretty-dialect-attribute-lead-ident
                                              dialect-attribute-body?
pretty-dialect-attribute-lead-ident ::= &#39;[A-Za-z][A-Za-z0-9._]*&#39;

dialect-attribute-body ::= &#39;&lt;&#39; dialect-attribute-contents+ &#39;&gt;&#39;
dialect-attribute-contents ::= dialect-attribute-body
                            | &#39;(&#39; dialect-attribute-contents+ &#39;)&#39;
                            | &#39;[&#39; dialect-attribute-contents+ &#39;]&#39;
                            | &#39;{&#39; dialect-attribute-contents+ &#39;}&#39;
                            | &#39;[^\[&lt;({\]&gt;)}\0]+&#39;
</pre></div>
</div>
<p>Dialect attributes are generally specified in an opaque form, where the contents
of the attribute are defined within a body wrapped with the dialect namespace
and <code class="docutils literal notranslate"><span class="pre">&lt;&gt;</span></code>. Consider the following examples:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>// A string attribute.
#foo&lt;string&lt;&quot;&quot;&gt;&gt;

// A complex attribute.
#foo&lt;&quot;a123^^^&quot; + bar&gt;
</pre></div>
</div>
<p>Dialect attributes that are simple enough may use a prettier format, which unwraps
part of the syntax into an equivalent, but lighter weight form:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>// A string attribute.
#foo.string&lt;&quot;&quot;&gt;
</pre></div>
</div>
<p>See <a class="reference internal" href="DefiningDialects/AttributesAndTypes.html"><span class="doc">here</span></a> on how to define dialect attribute values.</p>
</section>
<section id="builtin-attribute-values">
<h3>Builtin Attribute Values<a class="headerlink" href="#builtin-attribute-values" title="此标题的永久链接">¶</a></h3>
<p>The <a class="reference internal" href="Dialects/Builtin.html"><span class="doc">builtin dialect</span></a> defines a set of attribute values
that are directly usable by any other dialect in MLIR. These types cover a range
from primitive integer and floating-point values, attribute dictionaries, dense
multi-dimensional arrays, and more.</p>
</section>
<section id="ir-versioning">
<h3>IR Versioning<a class="headerlink" href="#ir-versioning" title="此标题的永久链接">¶</a></h3>
<p>A dialect can opt-in to handle versioning through the
<code class="docutils literal notranslate"><span class="pre">BytecodeDialectInterface</span></code>. Few hooks are exposed to the dialect to allow
managing a version encoded into the bytecode file. The version is loaded lazily
and allows to retrieve the version information while parsing the input IR, and
gives an opportunity to each dialect for which a version is present to perform
IR upgrades post-parsing through the <code class="docutils literal notranslate"><span class="pre">upgradeFromVersion</span></code> method. Custom
Attribute and Type encodings can also be upgraded according to the dialect
version using readAttribute and readType methods.</p>
<p>There is no restriction on what kind of information a dialect is allowed to
encode to model its versioning. Currently, versioning is supported only for
bytecode formats.</p>
</section>
</section>
</section>


          </div>
          <div class="page-nav">
            <div class="inner"><ul class="page-nav">
</ul><div class="footer" role="contentinfo">
      &#169; 版权所有 2023, yaoyue123.
    <br>
    Created using <a href="http://sphinx-doc.org/">Sphinx</a> 6.1.3 with <a href="https://github.com/schettino72/sphinx_press_theme">Press Theme</a> 0.8.0.
</div>
            </div>
          </div>
      </page>
    </div></div>
    
    
  </body>
</html>