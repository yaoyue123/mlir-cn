<!DOCTYPE html>
<html  lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

      <title>Defining Dialects</title>
    
          <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
          <link rel="stylesheet" href="../../_static/theme.css " type="text/css" />
      
      <!-- sphinx script_files -->
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
        <script src="../../_static/translations.js"></script>

      
      <!-- bundled in js (rollup iife) -->
      <!-- <script src="../../_static/theme-vendors.js"></script> -->
      <script src="../../_static/theme.js" defer></script>
    
  <link rel="index" title="索引" href="../../genindex.html" />
  <link rel="search" title="搜索" href="../../search.html" /> 
  </head>

  <body>
    <div id="app">
    <div class="theme-container" :class="pageClasses"><navbar @toggle-sidebar="toggleSidebar">
  <router-link to="../../index.html" class="home-link">
    
      <span class="site-name">MLIR 中文文档</span>
    
  </router-link>

  <div class="links">
    <navlinks class="can-hide">



    </navlinks>
  </div>
</navbar>

      
      <div class="sidebar-mask" @click="toggleSidebar(false)">
      </div>
        <sidebar @toggle-sidebar="toggleSidebar">
          
          <navlinks>
            



            
          </navlinks><div id="searchbox" class="searchbox" role="search">
  <div class="caption"><span class="caption-text">快速搜索</span>
    <div class="searchformwrapper">
      <form class="search" action="../../search.html" method="get">
        <input type="text" name="q" />
        <input type="submit" value="搜索" />
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div><div class="sidebar-links" role="navigation" aria-label="main navigation">
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../../index.html#mlir">欢迎使用 mlir 中文文档</a></span>
      </p>
      <ul class="">
        
          <li class="toctree-l1 ">
            
              <a href="../../_index.html" class="reference internal ">开始使用MLIR</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/CreatingADialect.html" class="reference internal ">Creating a Dialect</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/DataFlowAnalysis.html" class="reference internal ">Writing DataFlow Analyses in MLIR</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/QuickstartRewrites.html" class="reference internal ">Quickstart tutorial to adding MLIR graph rewrite</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/Toy/Ch-1.html" class="reference internal ">第1章：Toy语言和AST（抽象语法树）</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/Toy/Ch-2.html" class="reference internal ">Chapter 2: Emitting Basic MLIR</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/Toy/Ch-3.html" class="reference internal ">Chapter 3: High-level Language-Specific Analysis and Transformation</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/Toy/Ch-4.html" class="reference internal ">Chapter 4: Enabling Generic Transformation with Interfaces</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/Toy/Ch-5.html" class="reference internal ">Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/Toy/Ch-6.html" class="reference internal ">Chapter 6: Lowering to LLVM and CodeGeneration</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/Toy/Ch-7.html" class="reference internal ">Chapter 7: Adding a Composite Type to Toy</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/Toy/_index.html" class="reference internal ">Toy 入门教程</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/UnderstandingTheIRStructure.html" class="reference internal ">Understanding the IR Structure</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/_index.html" class="reference internal ">Tutorials</a>
            

            
          </li>

        
      </ul>
    </div>
  
</div>
        </sidebar>

      <page>
          <div class="body-header" role="navigation" aria-label="navigation">
  
  <ul class="breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
    
    <li>Defining Dialects</li>
  </ul>
  

  <ul class="page-nav">
</ul>
  
</div>
<hr>
          <div class="content" role="main" v-pre>
            
  <section id="defining-dialects">
<h1>Defining Dialects<a class="headerlink" href="#defining-dialects" title="此标题的永久链接">¶</a></h1>
<p>This document describes how to define <a class="reference external" href="../LangRef.md/#dialects">Dialects</a>.</p>
<p>[TOC]</p>
<section id="langref-refresher">
<h2>LangRef Refresher<a class="headerlink" href="#langref-refresher" title="此标题的永久链接">¶</a></h2>
<p>Before diving into how to define these constructs, below is a quick refresher
from the <a class="reference internal" href="../LangRef.html"><span class="doc">MLIR LangRef</span></a>.</p>
<p>Dialects are the mechanism by which to engage with and extend the MLIR
ecosystem. They allow for defining new <a class="reference external" href="../LangRef.md#attributes">attributes</a>,
<a class="reference external" href="../LangRef.md#operations">operations</a>, and <a class="reference external" href="../LangRef.md#type-system">types</a>.
Dialects are used to model a variety of different abstractions; from traditional
<a class="reference external" href="../Dialects/ArithOps">arithmetic</a> to
<a class="reference external" href="../Dialects/PDLOps">pattern rewrites</a>; and is one of the most fundamental
aspects of MLIR.</p>
</section>
<section id="defining-a-dialect">
<h2>Defining a Dialect<a class="headerlink" href="#defining-a-dialect" title="此标题的永久链接">¶</a></h2>
<p>At the most fundamental level, defining a dialect in MLIR is as simple as
specializing the
<a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/IR/Dialect.h">C++ <code class="docutils literal notranslate"><span class="pre">Dialect</span></code> class</a>.
That being said, MLIR provides a powerful declaratively specification mechanism via
<a class="reference external" href="https://llvm.org/docs/TableGen/index.html">TableGen</a>; a generic language with
tooling to maintain records of domain-specific information; that simplifies the
definition process by automatically generating all of the necessary boilerplate
C++ code, significantly reduces maintainence burden when changing aspects of dialect
definitions, and also provides additional tools on top (such as
documentation generation). Given the above, the declarative specification is the
expected mechanism for defining new dialects, and is the method detailed within
this document. Before continuing, it is highly recommended that users review the
<a class="reference external" href="https://llvm.org/docs/TableGen/ProgRef.html">TableGen Programmer’s Reference</a>
for an introduction to its syntax and constructs.</p>
<p>Below showcases an example simple Dialect definition. We generally recommend defining
the Dialect class in a different <code class="docutils literal notranslate"><span class="pre">.td</span></code> file from the attributes, operations, types,
and other sub-components of the dialect to establish a proper layering between
the various different dialect components. It also prevents situations where you may
inadvertantly generate multiple definitions for some constructs. This recommendation
extends to all of the MLIR constructs, including <a class="reference internal" href="../Interfaces.html"><span class="doc">Interfaces</span></a> for example.</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>// Include the definition of the necessary tablegen constructs for defining
// our dialect. 
include &quot;mlir/IR/DialectBase.td&quot;

// Here is a simple definition of a dialect.
def MyDialect : Dialect {
  let summary = &quot;A short one line description of my dialect.&quot;;
  let description = [{
    My dialect is a very important dialect. This section contains a much more
    detailed description that documents all of the important pieces of information
    to know about the document.
  }];

  /// This is the namespace of the dialect. It is used to encapsulate the sub-components
  /// of the dialect, such as operations (&quot;my_dialect.foo&quot;).
  let name = &quot;my_dialect&quot;;

  /// The C++ namespace that the dialect, and its sub-components, get placed in.
  let cppNamespace = &quot;::my_dialect&quot;;
}
</pre></div>
</div>
<p>The above showcases a very simple description of a dialect, but dialects have lots
of other capabilities that you may or may not need to utilize.</p>
<section id="initialization">
<h3>Initialization<a class="headerlink" href="#initialization" title="此标题的永久链接">¶</a></h3>
<p>Every dialect must implement an initialization hook to add attributes, operations, types,
attach any desired interfaces, or perform any other necessary initialization for the
dialect that should happen on construction. This hook is declared for every dialect to
define, and has the form:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">MyDialect::initialize</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Dialect initialization logic should be defined in here.</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="documentation">
<h3>Documentation<a class="headerlink" href="#documentation" title="此标题的永久链接">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">summary</span></code> and <code class="docutils literal notranslate"><span class="pre">description</span></code> fields allow for providing user documentation
for the dialect. The <code class="docutils literal notranslate"><span class="pre">summary</span></code> field expects a simple single-line string, with the
<code class="docutils literal notranslate"><span class="pre">description</span></code> field used for long and extensive documentation. This documentation can be
used to generate markdown documentation for the dialect and is used by upstream
<a class="reference external" href="https://mlir.llvm.org/docs/Dialects/">MLIR dialects</a>.</p>
</section>
<section id="class-name">
<h3>Class Name<a class="headerlink" href="#class-name" title="此标题的永久链接">¶</a></h3>
<p>The name of the C++ class which gets generated is the same as the name of our TableGen
dialect definition, but with any <code class="docutils literal notranslate"><span class="pre">_</span></code> characters stripped out. This means that if you name
your dialect <code class="docutils literal notranslate"><span class="pre">Foo_Dialect</span></code>, the generated C++ class would be <code class="docutils literal notranslate"><span class="pre">FooDialect</span></code>. In the example
above, we would get a C++ dialect named <code class="docutils literal notranslate"><span class="pre">MyDialect</span></code>.</p>
</section>
<section id="c-namespace">
<h3>C++ Namespace<a class="headerlink" href="#c-namespace" title="此标题的永久链接">¶</a></h3>
<p>The namespace that the C++ class for our dialect, and all of its sub-components, is placed
under is specified by the <code class="docutils literal notranslate"><span class="pre">cppNamespace</span></code> field. By default, uses the name of the dialect as
the only namespace. To avoid placing in any namespace, use <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>. To specify nested namespaces,
use <code class="docutils literal notranslate"><span class="pre">&quot;::&quot;</span></code> as the delimiter between namespace, e.g., given <code class="docutils literal notranslate"><span class="pre">&quot;A::B&quot;</span></code>, C++ classes will be placed
within: <code class="docutils literal notranslate"><span class="pre">namespace</span> <span class="pre">A</span> <span class="pre">{</span> <span class="pre">namespace</span> <span class="pre">B</span> <span class="pre">{</span> <span class="pre">&lt;classes&gt;</span> <span class="pre">}</span> <span class="pre">}</span></code>.</p>
<p>Note that this works in conjunction with the dialect’s C++ code. Depending on how the generated files
are included, you may want to specify a full namespace path or a partial one. In general, it’s best
to use full namespaces whenever you can. This makes it easier for dialects within different namespaces,
and projects, to interact with each other.</p>
</section>
<section id="c-accessor-generation">
<h3>C++ Accessor Generation<a class="headerlink" href="#c-accessor-generation" title="此标题的永久链接">¶</a></h3>
<p>When generating accessors for dialects and their components (attributes, operations, types, etc.),
we prefix the name with <code class="docutils literal notranslate"><span class="pre">get</span></code> and <code class="docutils literal notranslate"><span class="pre">set</span></code> respectively, and transform <code class="docutils literal notranslate"><span class="pre">snake_style</span></code> names to camel
case (<code class="docutils literal notranslate"><span class="pre">UpperCamel</span></code> when prefixed, and <code class="docutils literal notranslate"><span class="pre">lowerCamel</span></code> for individual variable names). For example, if an
operation were defined as:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def MyOp : MyDialect&lt;&quot;op&quot;&gt; {
  let arguments = (ins StrAttr:$value, StrAttr:$other_value);
}
</pre></div>
</div>
<p>It would have accessors generated for the <code class="docutils literal notranslate"><span class="pre">value</span></code> and <code class="docutils literal notranslate"><span class="pre">other_value</span></code> attributes as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">StringAttr</span><span class="w"> </span><span class="nf">MyOp::getValue</span><span class="p">();</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">MyOp::setValue</span><span class="p">(</span><span class="n">StringAttr</span><span class="w"> </span><span class="n">newValue</span><span class="p">);</span>

<span class="n">StringAttr</span><span class="w"> </span><span class="nf">MyOp::getOtherValue</span><span class="p">();</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">MyOp::setOtherValue</span><span class="p">(</span><span class="n">StringAttr</span><span class="w"> </span><span class="n">newValue</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="dependent-dialects">
<h3>Dependent Dialects<a class="headerlink" href="#dependent-dialects" title="此标题的永久链接">¶</a></h3>
<p>MLIR has a very large ecosystem, and contains dialects that server many different purposes. It
is quite common, given the above, that dialects may want to reuse certain components from other
dialects. This may mean generating operations from those dialects during canonicalization, reusing
attributes or types, etc. When a dialect has a dependency on another, i.e. when it constructs and/or
generally relies on the components of another dialect, a dialect dependency should be explicitly
recorded. An explicitly dependency ensures that dependent dialects are loaded alongside the
dialect. Dialect dependencies can be recorded using the <code class="docutils literal notranslate"><span class="pre">dependentDialects</span></code> dialects field:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def MyDialect : Dialect {
  // Here we register the Arithmetic and Func dialect as dependencies of our `MyDialect`.
  let dependentDialects = [
    &quot;arith::ArithDialect&quot;,
    &quot;func::FuncDialect&quot;
  ];
}
</pre></div>
</div>
</section>
<section id="extra-declarations">
<h3>Extra declarations<a class="headerlink" href="#extra-declarations" title="此标题的永久链接">¶</a></h3>
<p>The declarative Dialect definitions try to auto-generate as much logic and methods
as possible. With that said, there will always be long-tail cases that won’t be covered.
For such cases, <code class="docutils literal notranslate"><span class="pre">extraClassDeclaration</span></code> can be used. Code within the <code class="docutils literal notranslate"><span class="pre">extraClassDeclaration</span></code>
field will be copied literally to the generated C++ Dialect class.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">extraClassDeclaration</span></code> is a mechanism intended for long-tail cases by
power users; for not-yet-implemented widely-applicable cases, improving the
infrastructure is preferable.</p>
</section>
<section id="hasconstantmaterializer-materializing-constants-from-attributes">
<h3><code class="docutils literal notranslate"><span class="pre">hasConstantMaterializer</span></code>: Materializing Constants from Attributes<a class="headerlink" href="#hasconstantmaterializer-materializing-constants-from-attributes" title="此标题的永久链接">¶</a></h3>
<p>This field is utilized to materialize a constant operation from an <code class="docutils literal notranslate"><span class="pre">Attribute</span></code> value and
a <code class="docutils literal notranslate"><span class="pre">Type</span></code>. This is generally used when an operation within this dialect has been folded,
and a constant operation should be generated. <code class="docutils literal notranslate"><span class="pre">hasConstantMaterializer</span></code> is used to enable
materialization, and the <code class="docutils literal notranslate"><span class="pre">materializeConstant</span></code> hook is declared on the dialect. This
hook takes in an <code class="docutils literal notranslate"><span class="pre">Attribute</span></code> value, generally returned by <code class="docutils literal notranslate"><span class="pre">fold</span></code>, and produces a
“constant-like” operation that materializes that value. See the
<a class="reference internal" href="../Canonicalization.html"><span class="doc">documentation for canonicalization</span></a> for a more in-depth
introduction to <code class="docutils literal notranslate"><span class="pre">folding</span></code> in MLIR.</p>
<p>Constant materialization logic can then be defined in the source file:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// Hook to materialize a single constant operation from a given attribute value</span>
<span class="c1">/// with the desired resultant type. This method should use the provided builder</span>
<span class="c1">/// to create the operation without changing the insertion position. The</span>
<span class="c1">/// generated operation is expected to be constant-like. On success, this hook</span>
<span class="c1">/// should return the operation generated to represent the constant value.</span>
<span class="c1">/// Otherwise, it should return nullptr on failure.</span>
<span class="n">Operation</span><span class="w"> </span><span class="o">*</span><span class="nf">MyDialect::materializeConstant</span><span class="p">(</span><span class="n">OpBuilder</span><span class="w"> </span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span><span class="w"> </span><span class="n">Attribute</span><span class="w"> </span><span class="n">value</span><span class="p">,</span>
<span class="w">                                          </span><span class="n">Type</span><span class="w"> </span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">Location</span><span class="w"> </span><span class="n">loc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="hasnondefaultdestructor-providing-a-custom-destructor">
<h3><code class="docutils literal notranslate"><span class="pre">hasNonDefaultDestructor</span></code>: Providing a custom destructor<a class="headerlink" href="#hasnondefaultdestructor-providing-a-custom-destructor" title="此标题的永久链接">¶</a></h3>
<p>This field should be used when the Dialect class has a custom destructor, i.e.
when the dialect has some special logic to be run in the <code class="docutils literal notranslate"><span class="pre">~MyDialect</span></code>. In this case,
only the declaration of the destructor is generated for the Dialect class.</p>
</section>
<section id="discardable-attribute-verification">
<h3>Discardable Attribute Verification<a class="headerlink" href="#discardable-attribute-verification" title="此标题的永久链接">¶</a></h3>
<p>As described by the <a class="reference external" href="../LangRef.md#attributes">MLIR Language Reference</a>,
<em>discardable attribute</em> are a type of attribute that has its semantics defined
by the dialect whose name prefixes that of the attribute. For example, if an
operation has an attribute named <code class="docutils literal notranslate"><span class="pre">gpu.contained_module</span></code>, the <code class="docutils literal notranslate"><span class="pre">gpu</span></code> dialect
defines the semantics and invariants, such as when and where it is valid to use,
of that attribute. To hook into this verification for attributes that are prefixed
by our dialect, several hooks on the Dialect may be used:</p>
<section id="hasoperationattrverify">
<h4><code class="docutils literal notranslate"><span class="pre">hasOperationAttrVerify</span></code><a class="headerlink" href="#hasoperationattrverify" title="此标题的永久链接">¶</a></h4>
<p>This field generates the hook for verifying when a discardable attribute of this dialect
has been used within the attribute dictionary of an operation. This hook has the form:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// Verify the use of the given attribute, whose name is prefixed by the namespace of this</span>
<span class="c1">/// dialect, that was used in `op`s dictionary.</span>
<span class="n">LogicalResult</span><span class="w"> </span><span class="nf">MyDialect::verifyOperationAttribute</span><span class="p">(</span><span class="n">Operation</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="n">NamedAttribute</span><span class="w"> </span><span class="n">attribute</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="hasregionargattrverify">
<h4><code class="docutils literal notranslate"><span class="pre">hasRegionArgAttrVerify</span></code><a class="headerlink" href="#hasregionargattrverify" title="此标题的永久链接">¶</a></h4>
<p>This field generates the hook for verifying when a discardable attribute of this dialect
has been used within the attribute dictionary of a region entry block argument. Note that
the block arguments of a region entry block do not themselves have attribute dictionaries,
but some operations may provide special dictionary attributes that correspond to the arguments
of a region. For example, operations that implement <code class="docutils literal notranslate"><span class="pre">FunctionOpInterface</span></code> may have attribute
dictionaries on the operation that correspond to the arguments of entry block of the function.
In these cases, those operations will invoke this hook on the dialect to ensure the attribute
is verified. The hook necessary for the dialect to implement has the form:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// Verify the use of the given attribute, whose name is prefixed by the namespace of this</span>
<span class="c1">/// dialect, that was used on the attribute dictionary of a region entry block argument.</span>
<span class="c1">/// Note: As described above, when a region entry block has a dictionary is up to the individual</span>
<span class="c1">/// operation to define. </span>
<span class="n">LogicalResult</span><span class="w"> </span><span class="nf">MyDialect::verifyRegionArgAttribute</span><span class="p">(</span><span class="n">Operation</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">regionIndex</span><span class="p">,</span>
<span class="w">                                                  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">argIndex</span><span class="p">,</span><span class="w"> </span><span class="n">NamedAttribute</span><span class="w"> </span><span class="n">attribute</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="hasregionresultattrverify">
<h4><code class="docutils literal notranslate"><span class="pre">hasRegionResultAttrVerify</span></code><a class="headerlink" href="#hasregionresultattrverify" title="此标题的永久链接">¶</a></h4>
<p>This field generates the hook for verifying when a discardable attribute of this dialect
has been used within the attribute dictionary of a region result. Note that the results of a
region do not themselves have attribute dictionaries, but some operations may provide special
dictionary attributes that correspond to the results of a region. For example, operations that
implement <code class="docutils literal notranslate"><span class="pre">FunctionOpInterface</span></code> may have attribute dictionaries on the operation that correspond
to the results of the function. In these cases, those operations will invoke this hook on the
dialect to ensure the attribute is verified. The hook necessary for the dialect to implement
has the form:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// Generate verification for the given attribute, whose name is prefixed by the namespace</span>
<span class="c1">/// of this dialect, that was used on the attribute dictionary of a region result.</span>
<span class="c1">/// Note: As described above, when a region entry block has a dictionary is up to the individual</span>
<span class="c1">/// operation to define. </span>
<span class="n">LogicalResult</span><span class="w"> </span><span class="nf">MyDialect::verifyRegionResultAttribute</span><span class="p">(</span><span class="n">Operation</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">regionIndex</span><span class="p">,</span>
<span class="w">                                                     </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">argIndex</span><span class="p">,</span><span class="w"> </span><span class="n">NamedAttribute</span><span class="w"> </span><span class="n">attribute</span><span class="p">);</span>
</pre></div>
</div>
</section>
</section>
<section id="operation-interface-fallback">
<h3>Operation Interface Fallback<a class="headerlink" href="#operation-interface-fallback" title="此标题的永久链接">¶</a></h3>
<p>Some dialects have an open ecosystem and don’t register all of the possible operations. In such
cases it is still possible to provide support for implementing an <code class="docutils literal notranslate"><span class="pre">OpInterface</span></code> for these
operations. When an operation isn’t registered or does not provide an implementation for an
interface, the query will fallback to the dialect itself. The <code class="docutils literal notranslate"><span class="pre">hasOperationInterfaceFallback</span></code>
field may be used to declare this fallback for operations:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// Return an interface model for the interface with the given `typeId` for the operation</span>
<span class="c1">/// with the given name.</span>
<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">MyDialect::getRegisteredInterfaceForOp</span><span class="p">(</span><span class="n">TypeID</span><span class="w"> </span><span class="n">typeID</span><span class="p">,</span><span class="w"> </span><span class="n">StringAttr</span><span class="w"> </span><span class="n">opName</span><span class="p">);</span>
</pre></div>
</div>
<p>For a more detail description of the expected usages of this hook, view the detailed
<a class="reference external" href="../Interfaces.md#dialect-fallback-for-opinterface">interface documentation</a>.</p>
</section>
<section id="default-attribute-type-parsers-and-printers">
<h3>Default Attribute/Type Parsers and Printers<a class="headerlink" href="#default-attribute-type-parsers-and-printers" title="此标题的永久链接">¶</a></h3>
<p>When a dialect registers an Attribute or Type, it must also override the respective
<code class="docutils literal notranslate"><span class="pre">Dialect::parseAttribute</span></code>/<code class="docutils literal notranslate"><span class="pre">Dialect::printAttribute</span></code> or
<code class="docutils literal notranslate"><span class="pre">Dialect::parseType</span></code>/<code class="docutils literal notranslate"><span class="pre">Dialect::printType</span></code> methods. In these cases, the dialect must
explicitly handle the parsing and printing of each individual attribute or type within
the dialect. If all of the attributes and types of the dialect provide a mnemonic,
however, these methods may be autogenerated by using the
<code class="docutils literal notranslate"><span class="pre">useDefaultAttributePrinterParser</span></code> and <code class="docutils literal notranslate"><span class="pre">useDefaultTypePrinterParser</span></code> fields. By default,
these fields are set to <code class="docutils literal notranslate"><span class="pre">1</span></code>(enabled), meaning that if a dialect needs to explicitly handle the
parser and printer of its Attributes and Types it should set these to <code class="docutils literal notranslate"><span class="pre">0</span></code> as necessary.</p>
</section>
<section id="dialect-wide-canonicalization-patterns">
<h3>Dialect-wide Canonicalization Patterns<a class="headerlink" href="#dialect-wide-canonicalization-patterns" title="此标题的永久链接">¶</a></h3>
<p>Generally, <a class="reference internal" href="../Canonicalization.html"><span class="doc">canonicalization</span></a> patterns are specific to individual
operations within a dialect. There are some cases, however, that prompt canonicalization
patterns to be added to the dialect-level. For example, if a dialect defines a canonicalization
pattern that operates on an interface or trait, it can be beneficial to only add this pattern
once, instead of duplicating per-operation that implements that interface. To enable the
generation of this hook, the <code class="docutils literal notranslate"><span class="pre">hasCanonicalizer</span></code> field may be used. This will declare
the <code class="docutils literal notranslate"><span class="pre">getCanonicalizationPatterns</span></code> method on the dialect, which has the form:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// Return the canonicalization patterns for this dialect:</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">MyDialect::getCanonicalizationPatterns</span><span class="p">(</span><span class="n">RewritePatternSet</span><span class="w"> </span><span class="o">&amp;</span><span class="n">results</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>See the documentation for <a class="reference internal" href="../Canonicalization.html"><span class="doc">Canonicalization in MLIR</span></a> for a much more
detailed description about canonicalization patterns.</p>
</section>
</section>
<section id="defining-an-extensible-dialect">
<h2>Defining an Extensible dialect<a class="headerlink" href="#defining-an-extensible-dialect" title="此标题的永久链接">¶</a></h2>
<p>This section documents the design and API of the extensible dialects. Extensible
dialects are dialects that can be extended with new operations and types defined
at runtime. This allows for users to define dialects via with meta-programming,
or from another language, without having to recompile C++ code.</p>
<section id="id1">
<h3>Defining an extensible dialect<a class="headerlink" href="#id1" title="此标题的永久链接">¶</a></h3>
<p>Dialects defined in C++ can be extended with new operations, types, etc., at
runtime by inheriting from <code class="docutils literal notranslate"><span class="pre">mlir::ExtensibleDialect</span></code> instead of <code class="docutils literal notranslate"><span class="pre">mlir::Dialect</span></code>
(note that <code class="docutils literal notranslate"><span class="pre">ExtensibleDialect</span></code> inherits from <code class="docutils literal notranslate"><span class="pre">Dialect</span></code>). The <code class="docutils literal notranslate"><span class="pre">ExtensibleDialect</span></code>
class contains the necessary fields and methods to extend the dialect at
runtime.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyDialect</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">mlir</span><span class="o">::</span><span class="n">ExtensibleDialect</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For dialects defined in TableGen, this is done by setting the <code class="docutils literal notranslate"><span class="pre">isExtensible</span></code>
flag to <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def Test_Dialect : Dialect {
  let isExtensible = 1;
  ...
}
</pre></div>
</div>
<p>An extensible <code class="docutils literal notranslate"><span class="pre">Dialect</span></code> can be casted back to <code class="docutils literal notranslate"><span class="pre">ExtensibleDialect</span></code> using
<code class="docutils literal notranslate"><span class="pre">llvm::dyn_cast</span></code>, or <code class="docutils literal notranslate"><span class="pre">llvm::cast</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">extensibleDialect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">ExtensibleDialect</span><span class="o">&gt;</span><span class="p">(</span><span class="n">dialect</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="defining-a-dynamic-dialect">
<h3>Defining a dynamic dialect<a class="headerlink" href="#defining-a-dynamic-dialect" title="此标题的永久链接">¶</a></h3>
<p>Dynamic dialects are extensible dialects that can be defined at runtime. They
are only populated with dynamic operations, types, and attributes. They can be
registered in a <code class="docutils literal notranslate"><span class="pre">DialectRegistry</span></code> with <code class="docutils literal notranslate"><span class="pre">insertDynamic</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">populateDialect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="n">MLIRContext</span><span class="w"> </span><span class="o">*</span><span class="n">ctx</span><span class="p">,</span><span class="w"> </span><span class="n">DynamicDialect</span><span class="o">*</span><span class="w"> </span><span class="n">dialect</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Code that will be ran when the dynamic dialect is created and loaded.</span>
<span class="w">  </span><span class="c1">// For instance, this is where we register the dynamic operations, types, and</span>
<span class="w">  </span><span class="c1">// attributes of the dialect.</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>

<span class="n">registry</span><span class="p">.</span><span class="n">insertDynamic</span><span class="p">(</span><span class="s">&quot;dialectName&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">populateDialect</span><span class="p">);</span>
</pre></div>
</div>
<p>Once a dynamic dialect is registered in the <code class="docutils literal notranslate"><span class="pre">MLIRContext</span></code>, it can be retrieved
with <code class="docutils literal notranslate"><span class="pre">getOrLoadDialect</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Dialect</span><span class="w"> </span><span class="o">*</span><span class="n">dialect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">getOrLoadDialect</span><span class="p">(</span><span class="s">&quot;dialectName&quot;</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="defining-an-operation-at-runtime">
<h3>Defining an operation at runtime<a class="headerlink" href="#defining-an-operation-at-runtime" title="此标题的永久链接">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">DynamicOpDefinition</span></code> class represents the definition of an operation
defined at runtime. It is created using the <code class="docutils literal notranslate"><span class="pre">DynamicOpDefinition::get</span></code>
functions. An operation defined at runtime must provide a name, a dialect in
which the operation will be registered in, an operation verifier. It may also
optionally define a custom parser and a printer, fold hook, and more.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// The operation name, without the dialect name prefix.</span>
<span class="n">StringRef</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;my_operation_name&quot;</span><span class="p">;</span>

<span class="c1">// The dialect defining the operation.</span>
<span class="n">Dialect</span><span class="o">*</span><span class="w"> </span><span class="n">dialect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">getOrLoadDialect</span><span class="o">&lt;</span><span class="n">MyDialect</span><span class="o">&gt;</span><span class="p">();</span>

<span class="c1">// Operation verifier definition.</span>
<span class="n">AbstractOperation</span><span class="o">::</span><span class="n">VerifyInvariantsFn</span><span class="w"> </span><span class="n">verifyFn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="n">Operation</span><span class="o">*</span><span class="w"> </span><span class="n">op</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Logic for the operation verification.</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>

<span class="c1">// Parser function definition.</span>
<span class="n">AbstractOperation</span><span class="o">::</span><span class="n">ParseAssemblyFn</span><span class="w"> </span><span class="n">parseFn</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="p">[](</span><span class="n">OpAsmParser</span><span class="w"> </span><span class="o">&amp;</span><span class="n">parser</span><span class="p">,</span><span class="w"> </span><span class="n">OperationState</span><span class="w"> </span><span class="o">&amp;</span><span class="n">state</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Parse the operation, given that the name is already parsed.</span>
<span class="w">        </span><span class="p">...</span><span class="w">    </span>
<span class="p">};</span>

<span class="c1">// Printer function</span>
<span class="k">auto</span><span class="w"> </span><span class="n">printFn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="n">Operation</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="n">OpAsmPrinter</span><span class="w"> </span><span class="o">&amp;</span><span class="n">printer</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printer</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">op</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">();</span>
<span class="w">        </span><span class="c1">// Print the operation, given that the name is already printed.</span>
<span class="w">        </span><span class="p">...</span>
<span class="p">};</span>

<span class="c1">// General folder implementation, see AbstractOperation::foldHook for more</span>
<span class="c1">// information.</span>
<span class="k">auto</span><span class="w"> </span><span class="n">foldHookFn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="n">Operation</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">Attribute</span><span class="o">&gt;</span><span class="w"> </span><span class="n">operands</span><span class="p">,</span><span class="w"> </span>
<span class="w">                                   </span><span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">OpFoldResult</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">result</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">};</span>

<span class="c1">// Returns any canonicalization pattern rewrites that the operation</span>
<span class="c1">// supports, for use by the canonicalization pass.</span>
<span class="k">auto</span><span class="w"> </span><span class="n">getCanonicalizationPatterns</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>
<span class="w">        </span><span class="p">[](</span><span class="n">RewritePatternSet</span><span class="w"> </span><span class="o">&amp;</span><span class="n">results</span><span class="p">,</span><span class="w"> </span><span class="n">MLIRContext</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>

<span class="c1">// Definition of the operation.</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">DynamicOpDefinition</span><span class="o">&gt;</span><span class="w"> </span><span class="n">opDef</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">DynamicOpDefinition</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">dialect</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">verifyFn</span><span class="p">),</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">parseFn</span><span class="p">),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">printFn</span><span class="p">),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">foldHookFn</span><span class="p">),</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">getCanonicalizationPatterns</span><span class="p">));</span>
</pre></div>
</div>
<p>Once the operation is defined, it can be registered by an <code class="docutils literal notranslate"><span class="pre">ExtensibleDialect</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">extensibleDialect</span><span class="o">-&gt;</span><span class="n">registerDynamicOperation</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">opDef</span><span class="p">));</span>
</pre></div>
</div>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">Dialect</span></code> given to the operation should be the one registering
the operation.</p>
</section>
<section id="using-an-operation-defined-at-runtime">
<h3>Using an operation defined at runtime<a class="headerlink" href="#using-an-operation-defined-at-runtime" title="此标题的永久链接">¶</a></h3>
<p>It is possible to match on an operation defined at runtime using their names:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">().</span><span class="n">getStringRef</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;my_dialect.my_dynamic_op&quot;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>An operation defined at runtime can be created by instantiating an
<code class="docutils literal notranslate"><span class="pre">OperationState</span></code> with the operation name, and using it with a rewriter
(for instance a <code class="docutils literal notranslate"><span class="pre">PatternRewriter</span></code>) to create the operation.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">OperationState</span><span class="w"> </span><span class="n">state</span><span class="p">(</span><span class="n">location</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;my_dialect.my_dynamic_op&quot;</span><span class="p">,</span>
<span class="w">                     </span><span class="n">operands</span><span class="p">,</span><span class="w"> </span><span class="n">resultTypes</span><span class="p">,</span><span class="w"> </span><span class="n">attributes</span><span class="p">);</span>

<span class="n">rewriter</span><span class="p">.</span><span class="n">createOperation</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="defining-a-type-at-runtime">
<h3>Defining a type at runtime<a class="headerlink" href="#defining-a-type-at-runtime" title="此标题的永久链接">¶</a></h3>
<p>Contrary to types defined in C++ or in TableGen, types defined at runtime can
only have as argument a list of <code class="docutils literal notranslate"><span class="pre">Attribute</span></code>.</p>
<p>Similarily to operations, a type is defined at runtime using the class
<code class="docutils literal notranslate"><span class="pre">DynamicTypeDefinition</span></code>, which is created using the <code class="docutils literal notranslate"><span class="pre">DynamicTypeDefinition::get</span></code>
functions. A type definition requires a name, the dialect that will register the
type, and a parameter verifier. It can also define optionally a custom parser
and printer for the arguments (the type name is assumed to be already
parsed/printed).</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// The type name, without the dialect name prefix.</span>
<span class="n">StringRef</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;my_type_name&quot;</span><span class="p">;</span>

<span class="c1">// The dialect defining the type.</span>
<span class="n">Dialect</span><span class="o">*</span><span class="w"> </span><span class="n">dialect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">getOrLoadDialect</span><span class="o">&lt;</span><span class="n">MyDialect</span><span class="o">&gt;</span><span class="p">();</span>

<span class="c1">// The type verifier.</span>
<span class="c1">// A type defined at runtime has a list of attributes as parameters.</span>
<span class="k">auto</span><span class="w"> </span><span class="n">verifier</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="n">function_ref</span><span class="o">&lt;</span><span class="n">InFlightDiagnostic</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="n">emitError</span><span class="p">,</span>
<span class="w">                   </span><span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">Attribute</span><span class="o">&gt;</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">};</span>

<span class="c1">// The type parameters parser.</span>
<span class="k">auto</span><span class="w"> </span><span class="n">parser</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="n">DialectAsmParser</span><span class="w"> </span><span class="o">&amp;</span><span class="n">parser</span><span class="p">,</span>
<span class="w">                 </span><span class="n">llvm</span><span class="o">::</span><span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">Attribute</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">parsedParams</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">};</span>

<span class="c1">// The type parameters printer.</span>
<span class="k">auto</span><span class="w"> </span><span class="n">printer</span><span class="w"> </span><span class="o">=</span><span class="p">[](</span><span class="n">DialectAsmPrinter</span><span class="w"> </span><span class="o">&amp;</span><span class="n">printer</span><span class="p">,</span><span class="w"> </span><span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">Attribute</span><span class="o">&gt;</span><span class="w"> </span><span class="n">params</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">DynamicTypeDefinition</span><span class="o">&gt;</span><span class="w"> </span><span class="n">typeDef</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">DynamicTypeDefinition</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">name</span><span class="p">),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">dialect</span><span class="p">),</span>
<span class="w">                               </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">verifier</span><span class="p">),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">printer</span><span class="p">),</span>
<span class="w">                               </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">parser</span><span class="p">));</span>
</pre></div>
</div>
<p>If the printer and the parser are ommited, a default parser and printer is
generated with the format <code class="docutils literal notranslate"><span class="pre">!dialect.typename&lt;arg1,</span> <span class="pre">arg2,</span> <span class="pre">...,</span> <span class="pre">argN&gt;</span></code>.</p>
<p>The type can then be registered by the <code class="docutils literal notranslate"><span class="pre">ExtensibleDialect</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">dialect</span><span class="o">-&gt;</span><span class="n">registerDynamicType</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">typeDef</span><span class="p">));</span>
</pre></div>
</div>
</section>
<section id="parsing-types-defined-at-runtime-in-an-extensible-dialect">
<h3>Parsing types defined at runtime in an extensible dialect<a class="headerlink" href="#parsing-types-defined-at-runtime-in-an-extensible-dialect" title="此标题的永久链接">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">parseType</span></code> methods generated by TableGen can parse types defined at runtime,
though overriden <code class="docutils literal notranslate"><span class="pre">parseType</span></code> methods need to add the necessary support for them.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Type</span><span class="w"> </span><span class="nf">MyDialect::parseType</span><span class="p">(</span><span class="n">DialectAsmParser</span><span class="w"> </span><span class="o">&amp;</span><span class="n">parser</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// The type name.</span>
<span class="w">    </span><span class="n">StringRef</span><span class="w"> </span><span class="n">typeTag</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">failed</span><span class="p">(</span><span class="n">parser</span><span class="p">.</span><span class="n">parseKeyword</span><span class="p">(</span><span class="o">&amp;</span><span class="n">typeTag</span><span class="p">)))</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Type</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Try to parse a dynamic type with &#39;typeTag&#39; name.</span>
<span class="w">    </span><span class="n">Type</span><span class="w"> </span><span class="n">dynType</span><span class="p">;</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">parseResult</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parseOptionalDynamicType</span><span class="p">(</span><span class="n">typeTag</span><span class="p">,</span><span class="w"> </span><span class="n">parser</span><span class="p">,</span><span class="w"> </span><span class="n">dynType</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">parseResult</span><span class="p">.</span><span class="n">has_value</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">succeeded</span><span class="p">(</span><span class="n">parseResult</span><span class="p">.</span><span class="n">getValue</span><span class="p">()))</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">dynType</span><span class="p">;</span>
<span class="w">         </span><span class="k">return</span><span class="w"> </span><span class="n">Type</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="using-a-type-defined-at-runtime">
<h3>Using a type defined at runtime<a class="headerlink" href="#using-a-type-defined-at-runtime" title="此标题的永久链接">¶</a></h3>
<p>Dynamic types are instances of <code class="docutils literal notranslate"><span class="pre">DynamicType</span></code>. It is possible to get a dynamic
type with <code class="docutils literal notranslate"><span class="pre">DynamicType::get</span></code> and <code class="docutils literal notranslate"><span class="pre">ExtensibleDialect::lookupTypeDefinition</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">typeDef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">extensibleDialect</span><span class="o">-&gt;</span><span class="n">lookupTypeDefinition</span><span class="p">(</span><span class="s">&quot;my_dynamic_type&quot;</span><span class="p">);</span>
<span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">Attribute</span><span class="o">&gt;</span><span class="w"> </span><span class="n">params</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DynamicType</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">typeDef</span><span class="p">,</span><span class="w"> </span><span class="n">params</span><span class="p">);</span>
</pre></div>
</div>
<p>It is also possible to cast a <code class="docutils literal notranslate"><span class="pre">Type</span></code> known to be defined at runtime to a
<code class="docutils literal notranslate"><span class="pre">DynamicType</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">dynType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">type</span><span class="p">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">DynamicType</span><span class="o">&gt;</span><span class="p">();</span>
<span class="k">auto</span><span class="w"> </span><span class="n">typeDef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dynType</span><span class="p">.</span><span class="n">getTypeDef</span><span class="p">();</span>
<span class="k">auto</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dynType</span><span class="p">.</span><span class="n">getParams</span><span class="p">();</span>
</pre></div>
</div>
</section>
<section id="defining-an-attribute-at-runtime">
<h3>Defining an attribute at runtime<a class="headerlink" href="#defining-an-attribute-at-runtime" title="此标题的永久链接">¶</a></h3>
<p>Similar to types defined at runtime, attributes defined at runtime can only have
as argument a list of <code class="docutils literal notranslate"><span class="pre">Attribute</span></code>.</p>
<p>Similarily to types, an attribute is defined at runtime using the class
<code class="docutils literal notranslate"><span class="pre">DynamicAttrDefinition</span></code>, which is created using the <code class="docutils literal notranslate"><span class="pre">DynamicAttrDefinition::get</span></code>
functions. An attribute definition requires a name, the dialect that will
register the attribute, and a parameter verifier. It can also define optionally
a custom parser and printer for the arguments (the attribute name is assumed to
be already parsed/printed).</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// The attribute name, without the dialect name prefix.</span>
<span class="n">StringRef</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;my_attribute_name&quot;</span><span class="p">;</span>

<span class="c1">// The dialect defining the attribute.</span>
<span class="n">Dialect</span><span class="o">*</span><span class="w"> </span><span class="n">dialect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">getOrLoadDialect</span><span class="o">&lt;</span><span class="n">MyDialect</span><span class="o">&gt;</span><span class="p">();</span>

<span class="c1">// The attribute verifier.</span>
<span class="c1">// An attribute defined at runtime has a list of attributes as parameters.</span>
<span class="k">auto</span><span class="w"> </span><span class="n">verifier</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="n">function_ref</span><span class="o">&lt;</span><span class="n">InFlightDiagnostic</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="n">emitError</span><span class="p">,</span>
<span class="w">                   </span><span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">Attribute</span><span class="o">&gt;</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">};</span>

<span class="c1">// The attribute parameters parser.</span>
<span class="k">auto</span><span class="w"> </span><span class="n">parser</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="n">DialectAsmParser</span><span class="w"> </span><span class="o">&amp;</span><span class="n">parser</span><span class="p">,</span>
<span class="w">                 </span><span class="n">llvm</span><span class="o">::</span><span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">Attribute</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">parsedParams</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">};</span>

<span class="c1">// The attribute parameters printer.</span>
<span class="k">auto</span><span class="w"> </span><span class="n">printer</span><span class="w"> </span><span class="o">=</span><span class="p">[](</span><span class="n">DialectAsmPrinter</span><span class="w"> </span><span class="o">&amp;</span><span class="n">printer</span><span class="p">,</span><span class="w"> </span><span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">Attribute</span><span class="o">&gt;</span><span class="w"> </span><span class="n">params</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">DynamicAttrDefinition</span><span class="o">&gt;</span><span class="w"> </span><span class="n">attrDef</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">DynamicAttrDefinition</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">name</span><span class="p">),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">dialect</span><span class="p">),</span>
<span class="w">                               </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">verifier</span><span class="p">),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">printer</span><span class="p">),</span>
<span class="w">                               </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">parser</span><span class="p">));</span>
</pre></div>
</div>
<p>If the printer and the parser are ommited, a default parser and printer is
generated with the format <code class="docutils literal notranslate"><span class="pre">!dialect.attrname&lt;arg1,</span> <span class="pre">arg2,</span> <span class="pre">...,</span> <span class="pre">argN&gt;</span></code>.</p>
<p>The attribute can then be registered by the <code class="docutils literal notranslate"><span class="pre">ExtensibleDialect</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">dialect</span><span class="o">-&gt;</span><span class="n">registerDynamicAttr</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">typeDef</span><span class="p">));</span>
</pre></div>
</div>
</section>
<section id="parsing-attributes-defined-at-runtime-in-an-extensible-dialect">
<h3>Parsing attributes defined at runtime in an extensible dialect<a class="headerlink" href="#parsing-attributes-defined-at-runtime-in-an-extensible-dialect" title="此标题的永久链接">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">parseAttribute</span></code> methods generated by TableGen can parse attributes defined at
runtime, though overriden <code class="docutils literal notranslate"><span class="pre">parseAttribute</span></code> methods need to add the necessary
support for them.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Attribute</span><span class="w"> </span><span class="nf">MyDialect::parseAttribute</span><span class="p">(</span><span class="n">DialectAsmParser</span><span class="w"> </span><span class="o">&amp;</span><span class="n">parser</span><span class="p">,</span>
<span class="w">                                    </span><span class="n">Type</span><span class="w"> </span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="c1">// The attribute name.</span>
<span class="w">    </span><span class="n">StringRef</span><span class="w"> </span><span class="n">attrTag</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">failed</span><span class="p">(</span><span class="n">parser</span><span class="p">.</span><span class="n">parseKeyword</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attrTag</span><span class="p">)))</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Attribute</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Try to parse a dynamic attribute with &#39;attrTag&#39; name.</span>
<span class="w">    </span><span class="n">Attribute</span><span class="w"> </span><span class="n">dynAttr</span><span class="p">;</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">parseResult</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parseOptionalDynamicAttr</span><span class="p">(</span><span class="n">attrTag</span><span class="p">,</span><span class="w"> </span><span class="n">parser</span><span class="p">,</span><span class="w"> </span><span class="n">dynAttr</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">parseResult</span><span class="p">.</span><span class="n">has_value</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">succeeded</span><span class="p">(</span><span class="o">*</span><span class="n">parseResult</span><span class="p">))</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">dynAttr</span><span class="p">;</span>
<span class="w">         </span><span class="k">return</span><span class="w"> </span><span class="n">Attribute</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
</div>
</section>
<section id="using-an-attribute-defined-at-runtime">
<h3>Using an attribute defined at runtime<a class="headerlink" href="#using-an-attribute-defined-at-runtime" title="此标题的永久链接">¶</a></h3>
<p>Similar to types, attributes defined at runtime are instances of <code class="docutils literal notranslate"><span class="pre">DynamicAttr</span></code>.
It is possible to get a dynamic attribute with <code class="docutils literal notranslate"><span class="pre">DynamicAttr::get</span></code> and
<code class="docutils literal notranslate"><span class="pre">ExtensibleDialect::lookupAttrDefinition</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">attrDef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">extensibleDialect</span><span class="o">-&gt;</span><span class="n">lookupAttrDefinition</span><span class="p">(</span><span class="s">&quot;my_dynamic_attr&quot;</span><span class="p">);</span>
<span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">Attribute</span><span class="o">&gt;</span><span class="w"> </span><span class="n">params</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">attr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DynamicAttr</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">attrDef</span><span class="p">,</span><span class="w"> </span><span class="n">params</span><span class="p">);</span>
</pre></div>
</div>
<p>It is also possible to cast an <code class="docutils literal notranslate"><span class="pre">Attribute</span></code> known to be defined at runtime to a
<code class="docutils literal notranslate"><span class="pre">DynamicAttr</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">dynAttr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">attr</span><span class="p">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">DynamicAttr</span><span class="o">&gt;</span><span class="p">();</span>
<span class="k">auto</span><span class="w"> </span><span class="n">attrDef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dynAttr</span><span class="p">.</span><span class="n">getAttrDef</span><span class="p">();</span>
<span class="k">auto</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dynAttr</span><span class="p">.</span><span class="n">getParams</span><span class="p">();</span>
</pre></div>
</div>
</section>
<section id="implementation-details-of-extensible-dialects">
<h3>Implementation Details of Extensible Dialects<a class="headerlink" href="#implementation-details-of-extensible-dialects" title="此标题的永久链接">¶</a></h3>
<section id="extensible-dialect">
<h4>Extensible dialect<a class="headerlink" href="#extensible-dialect" title="此标题的永久链接">¶</a></h4>
<p>The role of extensible dialects is to own the necessary data for defined
operations and types. They also contain the necessary accessors to easily
access them.</p>
<p>In order to cast a <code class="docutils literal notranslate"><span class="pre">Dialect</span></code> back to an <code class="docutils literal notranslate"><span class="pre">ExtensibleDialect</span></code>, we implement the
<code class="docutils literal notranslate"><span class="pre">IsExtensibleDialect</span></code> interface to all <code class="docutils literal notranslate"><span class="pre">ExtensibleDialect</span></code>. The casting is done
by checking if the <code class="docutils literal notranslate"><span class="pre">Dialect</span></code> implements <code class="docutils literal notranslate"><span class="pre">IsExtensibleDialect</span></code> or not.</p>
</section>
<section id="operation-representation-and-registration">
<h4>Operation representation and registration<a class="headerlink" href="#operation-representation-and-registration" title="此标题的永久链接">¶</a></h4>
<p>Operations are represented in mlir using the <code class="docutils literal notranslate"><span class="pre">AbstractOperation</span></code> class. They are
registered in dialects the same way operations defined in C++ are registered,
which is by calling <code class="docutils literal notranslate"><span class="pre">AbstractOperation::insert</span></code>.</p>
<p>The only difference is that a new <code class="docutils literal notranslate"><span class="pre">TypeID</span></code> needs to be created for each
operation, since operations are not represented by a C++ class. This is done
using a <code class="docutils literal notranslate"><span class="pre">TypeIDAllocator</span></code>, which can allocate a new unique <code class="docutils literal notranslate"><span class="pre">TypeID</span></code> at runtime.</p>
</section>
<section id="type-representation-and-registration">
<h4>Type representation and registration<a class="headerlink" href="#type-representation-and-registration" title="此标题的永久链接">¶</a></h4>
<p>Unlike operations, types need to define a C++ storage class that takes care of
type parameters. They also need to define another C++ class to access that
storage. <code class="docutils literal notranslate"><span class="pre">DynamicTypeStorage</span></code> defines the storage of types defined at runtime,
and <code class="docutils literal notranslate"><span class="pre">DynamicType</span></code> gives access to the storage, as well as defining useful
functions. A <code class="docutils literal notranslate"><span class="pre">DynamicTypeStorage</span></code> contains a list of <code class="docutils literal notranslate"><span class="pre">Attribute</span></code> type
parameters, as well as a pointer to the type definition.</p>
<p>Types are registered using the <code class="docutils literal notranslate"><span class="pre">Dialect::addType</span></code> method, which expect a
<code class="docutils literal notranslate"><span class="pre">TypeID</span></code> that is generated using a <code class="docutils literal notranslate"><span class="pre">TypeIDAllocator</span></code>. The type uniquer also
register the type with the given <code class="docutils literal notranslate"><span class="pre">TypeID</span></code>. This mean that we can reuse our
single <code class="docutils literal notranslate"><span class="pre">DynamicType</span></code> with different <code class="docutils literal notranslate"><span class="pre">TypeID</span></code> to represent the different types
defined at runtime.</p>
<p>Since the different types defined at runtime have different <code class="docutils literal notranslate"><span class="pre">TypeID</span></code>, it is not
possible to use <code class="docutils literal notranslate"><span class="pre">TypeID</span></code> to cast a <code class="docutils literal notranslate"><span class="pre">Type</span></code> into a <code class="docutils literal notranslate"><span class="pre">DynamicType</span></code>. Thus, similar to
<code class="docutils literal notranslate"><span class="pre">Dialect</span></code>, all <code class="docutils literal notranslate"><span class="pre">DynamicType</span></code> define a <code class="docutils literal notranslate"><span class="pre">IsDynamicTypeTrait</span></code>, so casting a <code class="docutils literal notranslate"><span class="pre">Type</span></code>
to a <code class="docutils literal notranslate"><span class="pre">DynamicType</span></code> boils down to querying the <code class="docutils literal notranslate"><span class="pre">IsDynamicTypeTrait</span></code> trait.</p>
</section>
</section>
</section>
</section>


          </div>
          <div class="page-nav">
            <div class="inner"><ul class="page-nav">
</ul><div class="footer" role="contentinfo">
      &#169; 版权所有 2023, yaoyue123.
    <br>
    Created using <a href="http://sphinx-doc.org/">Sphinx</a> 6.1.3 with <a href="https://github.com/schettino72/sphinx_press_theme">Press Theme</a> 0.8.0.
</div>
            </div>
          </div>
      </page>
    </div></div>
    
    
  </body>
</html>