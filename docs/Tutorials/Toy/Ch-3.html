<!DOCTYPE html>
<html  lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

      <title>Chapter 3: High-level Language-Specific Analysis and Transformation</title>
    
          <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
          <link rel="stylesheet" href="../../../_static/theme.css " type="text/css" />
      
      <!-- sphinx script_files -->
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
        <script src="../../../_static/translations.js"></script>

      
      <!-- bundled in js (rollup iife) -->
      <!-- <script src="../../../_static/theme-vendors.js"></script> -->
      <script src="../../../_static/theme.js" defer></script>
    
  <link rel="index" title="索引" href="../../../genindex.html" />
  <link rel="search" title="搜索" href="../../../search.html" />
  <link rel="next" title="Chapter 4: Enabling Generic Transformation with Interfaces" href="Ch-4.html" />
  <link rel="prev" title="Chapter 2: Emitting Basic MLIR" href="Ch-2.html" /> 
  </head>

  <body>
    <div id="app">
    <div class="theme-container" :class="pageClasses"><navbar @toggle-sidebar="toggleSidebar">
  <router-link to="../../../index.html" class="home-link">
    
      <span class="site-name">MLIR 中文文档</span>
    
  </router-link>

  <div class="links">
    <navlinks class="can-hide">



    </navlinks>
  </div>
</navbar>

      
      <div class="sidebar-mask" @click="toggleSidebar(false)">
      </div>
        <sidebar @toggle-sidebar="toggleSidebar">
          
          <navlinks>
            



            
          </navlinks><div id="searchbox" class="searchbox" role="search">
  <div class="caption"><span class="caption-text">快速搜索</span>
    <div class="searchformwrapper">
      <form class="search" action="../../../search.html" method="get">
        <input type="text" name="q" />
        <input type="submit" value="搜索" />
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div><div class="sidebar-links" role="navigation" aria-label="main navigation">
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../../../index.html#mlir">欢迎使用 mlir 中文文档</a></span>
      </p>
      <ul class="current">
        
          <li class="toctree-l1 ">
            
              <a href="../../../_index.html" class="reference internal ">开始使用</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../CreatingADialect.html" class="reference internal ">Creating a Dialect</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../DataFlowAnalysis.html" class="reference internal ">Writing DataFlow Analyses in MLIR</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../QuickstartRewrites.html" class="reference internal ">Quickstart tutorial to adding MLIR graph rewrite</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Ch-1.html" class="reference internal ">Chapter 1: Toy Language and AST</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Ch-2.html" class="reference internal ">Chapter 2: Emitting Basic MLIR</a>
            

            
          </li>

        
          <li class="toctree-l1 current">
            
              <a href="#" class="reference internal current">Chapter 3: High-level Language-Specific Analysis and Transformation</a>
            

            
              <ul>
                
                  <li class="toctree-l2"><a href="#optimize-transpose-using-c-style-pattern-match-and-rewrite" class="reference internal">Optimize Transpose using C++ style pattern-match and rewrite</a></li>
                
                  <li class="toctree-l2"><a href="#optimize-reshapes-using-drr" class="reference internal">Optimize Reshapes using DRR</a></li>
                
              </ul>
            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Ch-4.html" class="reference internal ">Chapter 4: Enabling Generic Transformation with Interfaces</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Ch-5.html" class="reference internal ">Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Ch-6.html" class="reference internal ">Chapter 6: Lowering to LLVM and CodeGeneration</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Ch-7.html" class="reference internal ">Chapter 7: Adding a Composite Type to Toy</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="_index.html" class="reference internal ">Toy Tutorial</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../UnderstandingTheIRStructure.html" class="reference internal ">Understanding the IR Structure</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../_index.html" class="reference internal ">Tutorials</a>
            

            
          </li>

        
      </ul>
    </div>
  
</div>
        </sidebar>

      <page>
          <div class="body-header" role="navigation" aria-label="navigation">
  
  <ul class="breadcrumbs">
    <li><a href="../../../index.html">Docs</a> &raquo;</li>
    
    <li>Chapter 3: High-level Language-Specific Analysis and Transformation</li>
  </ul>
  

  <ul class="page-nav">
  <li class="prev">
    <a href="Ch-2.html"
       title="上一章">← Chapter 2: Emitting Basic MLIR</a>
  </li>
  <li class="next">
    <a href="Ch-4.html"
       title="下一章">Chapter 4: Enabling Generic Transformation with Interfaces →</a>
  </li>
</ul>
  
</div>
<hr>
          <div class="content" role="main" v-pre>
            
  <section id="chapter-3-high-level-language-specific-analysis-and-transformation">
<h1>Chapter 3: High-level Language-Specific Analysis and Transformation<a class="headerlink" href="#chapter-3-high-level-language-specific-analysis-and-transformation" title="此标题的永久链接">¶</a></h1>
<p>[TOC]</p>
<p>Creating a dialect that closely represents the semantics of an input language
enables analyses, transformations and optimizations in MLIR that require
high-level language information and are generally performed on the language AST.
For example, <code class="docutils literal notranslate"><span class="pre">clang</span></code> has a fairly
<a class="reference external" href="https://clang.llvm.org/doxygen/classclang_1_1TreeTransform.html">heavy mechanism</a>
for performing template instantiation in C++.</p>
<p>We divide compiler transformations into two categories: local and global. In
this chapter, we focus on how to leverage the Toy Dialect and its high-level
semantics to perform local pattern-match transformations that would be difficult
in LLVM. For this, we use MLIR’s
<a class="reference internal" href="../../PatternRewriter.html"><span class="doc">Generic DAG Rewriter</span></a>.</p>
<p>There are two methods that can be used to implement pattern-match
transformations: 1. Imperative, C++ pattern-match and rewrite 2. Declarative,
rule-based pattern-match and rewrite using table-driven
<a class="reference internal" href="../../DeclarativeRewrites.html"><span class="doc">Declarative Rewrite Rules</span></a> (DRR). Note that the
use of DRR requires that the operations be defined using ODS, as described in
<a class="reference internal" href="Ch-2.html"><span class="doc">Chapter 2</span></a>.</p>
<section id="optimize-transpose-using-c-style-pattern-match-and-rewrite">
<h2>Optimize Transpose using C++ style pattern-match and rewrite<a class="headerlink" href="#optimize-transpose-using-c-style-pattern-match-and-rewrite" title="此标题的永久链接">¶</a></h2>
<p>Let’s start with a simple pattern and try to eliminate a sequence of two
transposes that cancel out: <code class="docutils literal notranslate"><span class="pre">transpose(transpose(X))</span> <span class="pre">-&gt;</span> <span class="pre">X</span></code>. Here is the
corresponding Toy example:</p>
<div class="highlight-toy notranslate"><div class="highlight"><pre><span></span>def transpose_transpose(x) {
  return transpose(transpose(x));
}
</pre></div>
</div>
<p>Which corresponds to the following IR:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>toy.func @transpose_transpose(%arg0: tensor&lt;*xf64&gt;) -&gt; tensor&lt;*xf64&gt; {
  %0 = toy.transpose(%arg0 : tensor&lt;*xf64&gt;) to tensor&lt;*xf64&gt;
  %1 = toy.transpose(%0 : tensor&lt;*xf64&gt;) to tensor&lt;*xf64&gt;
  toy.return %1 : tensor&lt;*xf64&gt;
}
</pre></div>
</div>
<p>This is a good example of a transformation that is trivial to match on the Toy
IR but that would be quite hard for LLVM to figure. For example, today Clang
can’t optimize away the temporary array, and the computation with the naive
transpose is expressed with these loops:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#define N 100</span>
<span class="cp">#define M 100</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">sink</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">double_transpose</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">N</span><span class="p">][</span><span class="n">M</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">M</span><span class="p">][</span><span class="n">N</span><span class="p">];</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">M</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">       </span><span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">N</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">M</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">       </span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">sink</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For a simple C++ approach to rewrite, involving matching a tree-like pattern in
the IR and replacing it with a different set of operations, we can plug into the
MLIR <code class="docutils literal notranslate"><span class="pre">Canonicalizer</span></code> pass by implementing a <code class="docutils literal notranslate"><span class="pre">RewritePattern</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// Fold transpose(transpose(x)) -&gt; x</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">SimplifyRedundantTranspose</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">mlir</span><span class="o">::</span><span class="n">OpRewritePattern</span><span class="o">&lt;</span><span class="n">TransposeOp</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">/// We register this pattern to match every toy.transpose in the IR.</span>
<span class="w">  </span><span class="c1">/// The &quot;benefit&quot; is used by the framework to order the patterns and process</span>
<span class="w">  </span><span class="c1">/// them in order of profitability.</span>
<span class="w">  </span><span class="n">SimplifyRedundantTranspose</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">MLIRContext</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="p">)</span>
<span class="w">      </span><span class="o">:</span><span class="w"> </span><span class="n">OpRewritePattern</span><span class="o">&lt;</span><span class="n">TransposeOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="cm">/*benefit=*/</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>

<span class="w">  </span><span class="c1">/// This method is attempting to match a pattern and rewrite it. The rewriter</span>
<span class="w">  </span><span class="c1">/// argument is the orchestrator of the sequence of rewrites. It is expected</span>
<span class="w">  </span><span class="c1">/// to interact with it to perform any changes to the IR from here.</span>
<span class="w">  </span><span class="n">mlir</span><span class="o">::</span><span class="n">LogicalResult</span>
<span class="w">  </span><span class="n">matchAndRewrite</span><span class="p">(</span><span class="n">TransposeOp</span><span class="w"> </span><span class="n">op</span><span class="p">,</span>
<span class="w">                  </span><span class="n">mlir</span><span class="o">::</span><span class="n">PatternRewriter</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rewriter</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Look through the input of the current transpose.</span>
<span class="w">    </span><span class="n">mlir</span><span class="o">::</span><span class="n">Value</span><span class="w"> </span><span class="n">transposeInput</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">op</span><span class="p">.</span><span class="n">getOperand</span><span class="p">();</span>
<span class="w">    </span><span class="n">TransposeOp</span><span class="w"> </span><span class="n">transposeInputOp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">transposeInput</span><span class="p">.</span><span class="n">getDefiningOp</span><span class="o">&lt;</span><span class="n">TransposeOp</span><span class="o">&gt;</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Input defined by another transpose? If not, no match.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">transposeInputOp</span><span class="p">)</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">failure</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Otherwise, we have a redundant transpose. Use the rewriter.</span>
<span class="w">    </span><span class="n">rewriter</span><span class="p">.</span><span class="n">replaceOp</span><span class="p">(</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">transposeInputOp</span><span class="p">.</span><span class="n">getOperand</span><span class="p">()});</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">success</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The implementation of this rewriter is in <code class="docutils literal notranslate"><span class="pre">ToyCombine.cpp</span></code>. The
<a class="reference internal" href="../../Canonicalization.html"><span class="doc">canonicalization pass</span></a> applies transformations
defined by operations in a greedy, iterative manner. To ensure that the
canonicalization pass applies our new transform, we set
<a class="reference external" href="../../DefiningDialects/Operations.md/#hascanonicalizer">hasCanonicalizer = 1</a> and register the
pattern with the canonicalization framework.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Register our patterns for rewrite by the Canonicalization framework.</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">TransposeOp::getCanonicalizationPatterns</span><span class="p">(</span>
<span class="w">    </span><span class="n">RewritePatternSet</span><span class="w"> </span><span class="o">&amp;</span><span class="n">results</span><span class="p">,</span><span class="w"> </span><span class="n">MLIRContext</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">results</span><span class="p">.</span><span class="n">add</span><span class="o">&lt;</span><span class="n">SimplifyRedundantTranspose</span><span class="o">&gt;</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We also need to update our main file, <code class="docutils literal notranslate"><span class="pre">toyc.cpp</span></code>, to add an optimization
pipeline. In MLIR, the optimizations are run through a <code class="docutils literal notranslate"><span class="pre">PassManager</span></code> in a
similar way to LLVM:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="n">mlir</span><span class="o">::</span><span class="n">PassManager</span><span class="w"> </span><span class="nf">pm</span><span class="p">(</span><span class="k">module</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">());</span>
<span class="w">  </span><span class="n">pm</span><span class="p">.</span><span class="n">addNestedPass</span><span class="o">&lt;</span><span class="n">mlir</span><span class="o">::</span><span class="n">toy</span><span class="o">::</span><span class="n">FuncOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mlir</span><span class="o">::</span><span class="n">createCanonicalizerPass</span><span class="p">());</span>
</pre></div>
</div>
<p>Finally, we can run <code class="docutils literal notranslate"><span class="pre">toyc-ch3</span> <span class="pre">test/Examples/Toy/Ch3/transpose_transpose.toy</span>&#160; <span class="pre">-emit=mlir</span> <span class="pre">-opt</span></code> and observe our pattern in action:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>toy.func @transpose_transpose(%arg0: tensor&lt;*xf64&gt;) -&gt; tensor&lt;*xf64&gt; {
  %0 = toy.transpose(%arg0 : tensor&lt;*xf64&gt;) to tensor&lt;*xf64&gt;
  toy.return %arg0 : tensor&lt;*xf64&gt;
}
</pre></div>
</div>
<p>As expected, we now directly return the function argument, bypassing any
transpose operation. However, one of the transposes still hasn’t been
eliminated. That is not ideal! What happened is that our pattern replaced the
last transform with the function input and left behind the now dead transpose
input. The Canonicalizer knows to clean up dead operations; however, MLIR
conservatively assumes that operations may have side-effects. We can fix this by
adding a new trait, <code class="docutils literal notranslate"><span class="pre">Pure</span></code>, to our <code class="docutils literal notranslate"><span class="pre">TransposeOp</span></code>:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def TransposeOp : Toy_Op&lt;&quot;transpose&quot;, [Pure]&gt; {...}
</pre></div>
</div>
<p>Let’s retry now <code class="docutils literal notranslate"><span class="pre">toyc-ch3</span> <span class="pre">test/transpose_transpose.toy</span> <span class="pre">-emit=mlir</span> <span class="pre">-opt</span></code>:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>toy.func @transpose_transpose(%arg0: tensor&lt;*xf64&gt;) -&gt; tensor&lt;*xf64&gt; {
  toy.return %arg0 : tensor&lt;*xf64&gt;
}
</pre></div>
</div>
<p>Perfect! No <code class="docutils literal notranslate"><span class="pre">transpose</span></code> operation is left - the code is optimal.</p>
<p>In the next section, we use DRR for pattern match optimizations associated with
the Reshape op.</p>
</section>
<section id="optimize-reshapes-using-drr">
<h2>Optimize Reshapes using DRR<a class="headerlink" href="#optimize-reshapes-using-drr" title="此标题的永久链接">¶</a></h2>
<p>Declarative, rule-based pattern-match and rewrite (DRR) is an operation
DAG-based declarative rewriter that provides a table-based syntax for
pattern-match and rewrite rules:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>class Pattern&lt;
    dag sourcePattern, list&lt;dag&gt; resultPatterns,
    list&lt;dag&gt; additionalConstraints = [],
    dag benefitsAdded = (addBenefit 0)&gt;;
</pre></div>
</div>
<p>A redundant reshape optimization similar to SimplifyRedundantTranspose can be
expressed more simply using DRR as follows:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>// Reshape(Reshape(x)) = Reshape(x)
def ReshapeReshapeOptPattern : Pat&lt;(ReshapeOp(ReshapeOp $arg)),
                                   (ReshapeOp $arg)&gt;;
</pre></div>
</div>
<p>The automatically generated C++ code corresponding to each of the DRR patterns
can be found under <code class="docutils literal notranslate"><span class="pre">path/to/BUILD/tools/mlir/examples/toy/Ch3/ToyCombine.inc</span></code>.</p>
<p>DRR also provides a method for adding argument constraints when the
transformation is conditional on some properties of the arguments and results.
An example is a transformation that eliminates reshapes when they are redundant,
i.e. when the input and output shapes are identical.</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def TypesAreIdentical : Constraint&lt;CPred&lt;&quot;$0.getType() == $1.getType()&quot;&gt;&gt;;
def RedundantReshapeOptPattern : Pat&lt;
  (ReshapeOp:$res $arg), (replaceWithValue $arg),
  [(TypesAreIdentical $res, $arg)]&gt;;
</pre></div>
</div>
<p>Some optimizations may require additional transformations on instruction
arguments. This is achieved using NativeCodeCall, which allows for more complex
transformations either by calling into a C++ helper function or by using inline
C++. An example of such an optimization is FoldConstantReshape, where we
optimize Reshape of a constant value by reshaping the constant in place and
eliminating the reshape operation.</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def ReshapeConstant : NativeCodeCall&lt;&quot;$0.reshape(($1.getType()).cast&lt;ShapedType&gt;())&quot;&gt;;
def FoldConstantReshapeOptPattern : Pat&lt;
  (ReshapeOp:$res (ConstantOp $arg)),
  (ConstantOp (ReshapeConstant $arg, $res))&gt;;
</pre></div>
</div>
<p>We demonstrate these reshape optimizations using the following
trivial_reshape.toy program:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">def</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">var</span><span class="w"> </span><span class="n">a</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span>
<span class="w">  </span><span class="n">var</span><span class="w"> </span><span class="n">b</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">  </span><span class="n">var</span><span class="w"> </span><span class="n">c</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">  </span><span class="n">print</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>module {
  toy.func @main() {
    %0 = toy.constant dense&lt;[1.000000e+00, 2.000000e+00]&gt; : tensor&lt;2xf64&gt;
    %1 = toy.reshape(%0 : tensor&lt;2xf64&gt;) to tensor&lt;2x1xf64&gt;
    %2 = toy.reshape(%1 : tensor&lt;2x1xf64&gt;) to tensor&lt;2x1xf64&gt;
    %3 = toy.reshape(%2 : tensor&lt;2x1xf64&gt;) to tensor&lt;2x1xf64&gt;
    toy.print %3 : tensor&lt;2x1xf64&gt;
    toy.return
  }
}
</pre></div>
</div>
<p>We can try to run <code class="docutils literal notranslate"><span class="pre">toyc-ch3</span> <span class="pre">test/Examples/Toy/Ch3/trivial_reshape.toy</span> <span class="pre">-emit=mlir</span>&#160; <span class="pre">-opt</span></code> and observe our pattern in action:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>module {
  toy.func @main() {
    %0 = toy.constant dense&lt;[[1.000000e+00], [2.000000e+00]]&gt; : tensor&lt;2x1xf64&gt;
    toy.print %0 : tensor&lt;2x1xf64&gt;
    toy.return
  }
}
</pre></div>
</div>
<p>As expected, no reshape operations remain after canonicalization.</p>
<p>Further details on the declarative rewrite method can be found at
<a class="reference internal" href="../../DeclarativeRewrites.html"><span class="doc">Table-driven Declarative Rewrite Rule (DRR)</span></a>.</p>
<p>In this chapter, we saw how to use certain core transformations through always
available hooks. In the <a class="reference internal" href="Ch-4.html"><span class="doc">next chapter</span></a>, we will see how to use generic
solutions that scale better through Interfaces.</p>
</section>
</section>


          </div>
          <div class="page-nav">
            <div class="inner"><ul class="page-nav">
  <li class="prev">
    <a href="Ch-2.html"
       title="上一章">← Chapter 2: Emitting Basic MLIR</a>
  </li>
  <li class="next">
    <a href="Ch-4.html"
       title="下一章">Chapter 4: Enabling Generic Transformation with Interfaces →</a>
  </li>
</ul><div class="footer" role="contentinfo">
      &#169; 版权所有 2023, yaoyue123.
    <br>
    Created using <a href="http://sphinx-doc.org/">Sphinx</a> 6.1.3 with <a href="https://github.com/schettino72/sphinx_press_theme">Press Theme</a> 0.8.0.
</div>
            </div>
          </div>
      </page>
    </div></div>
    
    
  </body>
</html>