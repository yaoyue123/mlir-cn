<!DOCTYPE html>
<html  lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

      <title>Operation Definition Specification (ODS)</title>
    
          <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
          <link rel="stylesheet" href="../../_static/theme.css " type="text/css" />
      
      <!-- sphinx script_files -->
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
        <script src="../../_static/translations.js"></script>

      
      <!-- bundled in js (rollup iife) -->
      <!-- <script src="../../_static/theme-vendors.js"></script> -->
      <script src="../../_static/theme.js" defer></script>
    
  <link rel="index" title="索引" href="../../genindex.html" />
  <link rel="search" title="搜索" href="../../search.html" /> 
  </head>

  <body>
    <div id="app">
    <div class="theme-container" :class="pageClasses"><navbar @toggle-sidebar="toggleSidebar">
  <router-link to="../../index.html" class="home-link">
    
      <span class="site-name">MLIR 中文文档</span>
    
  </router-link>

  <div class="links">
    <navlinks class="can-hide">



    </navlinks>
  </div>
</navbar>

      
      <div class="sidebar-mask" @click="toggleSidebar(false)">
      </div>
        <sidebar @toggle-sidebar="toggleSidebar">
          
          <navlinks>
            



            
          </navlinks><div id="searchbox" class="searchbox" role="search">
  <div class="caption"><span class="caption-text">快速搜索</span>
    <div class="searchformwrapper">
      <form class="search" action="../../search.html" method="get">
        <input type="text" name="q" />
        <input type="submit" value="搜索" />
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div><div class="sidebar-links" role="navigation" aria-label="main navigation">
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../../index.html#mlir">欢迎使用 mlir 中文文档</a></span>
      </p>
      <ul class="">
        
          <li class="toctree-l1 ">
            
              <a href="../../_index.html" class="reference internal ">开始使用MLIR</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/CreatingADialect.html" class="reference internal ">Creating a Dialect</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/DataFlowAnalysis.html" class="reference internal ">Writing DataFlow Analyses in MLIR</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/QuickstartRewrites.html" class="reference internal ">Quickstart tutorial to adding MLIR graph rewrite</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/Toy/Ch-1.html" class="reference internal ">第1章：Toy语言和AST（抽象语法树）</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/Toy/Ch-2.html" class="reference internal ">Chapter 2: Emitting Basic MLIR</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/Toy/Ch-3.html" class="reference internal ">Chapter 3: High-level Language-Specific Analysis and Transformation</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/Toy/Ch-4.html" class="reference internal ">Chapter 4: Enabling Generic Transformation with Interfaces</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/Toy/Ch-5.html" class="reference internal ">Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/Toy/Ch-6.html" class="reference internal ">Chapter 6: Lowering to LLVM and CodeGeneration</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/Toy/Ch-7.html" class="reference internal ">Chapter 7: Adding a Composite Type to Toy</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/Toy/_index.html" class="reference internal ">Toy 入门教程</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/UnderstandingTheIRStructure.html" class="reference internal ">Understanding the IR Structure</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/_index.html" class="reference internal ">Tutorials</a>
            

            
          </li>

        
      </ul>
    </div>
  
</div>
        </sidebar>

      <page>
          <div class="body-header" role="navigation" aria-label="navigation">
  
  <ul class="breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
    
    <li>Operation Definition Specification (ODS)</li>
  </ul>
  

  <ul class="page-nav">
</ul>
  
</div>
<hr>
          <div class="content" role="main" v-pre>
            
  <section id="operation-definition-specification-ods">
<h1>Operation Definition Specification (ODS)<a class="headerlink" href="#operation-definition-specification-ods" title="此标题的永久链接">¶</a></h1>
<p>In addition to specializing the <code class="docutils literal notranslate"><span class="pre">mlir::Op</span></code> C++ template, MLIR also supports
defining operations and data types in a table-driven manner. This is achieved
via <a class="reference external" href="https://llvm.org/docs/TableGen/index.html">TableGen</a>, which is both a generic language and its tooling to
maintain records of domain-specific information. Facts regarding an operation
are specified concisely into a TableGen record, which will be expanded into an
equivalent <code class="docutils literal notranslate"><span class="pre">mlir::Op</span></code> C++ template specialization at compiler build time.</p>
<p>This manual explains in detail all the available mechanisms for defining
operations in such a table-driven manner. It aims to be a specification instead
of a tutorial. Please refer to
<a class="reference internal" href="../Tutorials/QuickstartRewrites.html"><span class="doc">Quickstart tutorial to adding MLIR graph rewrite</span></a>
for the latter.</p>
<p>In addition to detailing each mechanism, this manual also tries to capture best
practices. They are rendered as quoted bullet points.</p>
<p>[TOC]</p>
<section id="motivation">
<h2>Motivation<a class="headerlink" href="#motivation" title="此标题的永久链接">¶</a></h2>
<p>MLIR allows pluggable dialects, and dialects contain, among others, a list of
operations. This open and extensible ecosystem leads to the “stringly” type IR
problem, e.g., repetitive string comparisons during optimization and analysis
passes, unintuitive accessor methods (e.g., generic/error prone <code class="docutils literal notranslate"><span class="pre">getOperand(3)</span></code>
vs self-documenting <code class="docutils literal notranslate"><span class="pre">getStride()</span></code>) with more generic return types, verbose and
generic constructors without default arguments, verbose textual IR dumps, and so
on. Furthermore, operation verification is:</p>
<ol class="simple">
<li><p>best case: a central string-to-verification-function map,</p></li>
<li><p>middle case: duplication of verification across the code base, or</p></li>
<li><p>worst case: no verification functions.</p></li>
</ol>
<p>The fix is to support defining ops in a table-driven manner. Then for each
dialect, we can have a central place that contains everything you need to know
about each op, including its constraints, custom assembly form, etc. This
description is also used to generate helper functions and classes to allow
building, verification, parsing, printing, analysis, and many more.</p>
</section>
<section id="benefits">
<h2>Benefits<a class="headerlink" href="#benefits" title="此标题的永久链接">¶</a></h2>
<p>Compared to the C++ template, this table-driven approach has several benefits
including but not limited to:</p>
<ul class="simple">
<li><p><strong>Single source of truth</strong>: We strive to encode all facts regarding an
operation into the record, so that readers don’t need to jump among code
snippets to fully understand an operation.</p></li>
<li><p><strong>Removing boilerplate</strong>: We can automatically generate
operand/attribute/result getter methods, operation build methods, operation
verify methods, and many more utilities from the record. This greatly
reduces the boilerplate needed for defining a new op.</p></li>
<li><p><strong>Facilitating auto-generation</strong>: The usage of these operation information
records are by no means limited to op definition itself. We can use them to
drive the auto-generation of many other components, like computation graph
serialization.</p></li>
</ul>
</section>
<section id="tablegen-syntax">
<h2>TableGen Syntax<a class="headerlink" href="#tablegen-syntax" title="此标题的永久链接">¶</a></h2>
<p>We use TableGen as the language for specifying operation information. TableGen
itself just provides syntax for writing records; the syntax and constructs
allowed in a TableGen file (typically with the filename suffix <code class="docutils literal notranslate"><span class="pre">.td</span></code>) can be found
<a class="reference external" href="https://llvm.org/docs/TableGen/ProgRef.html">here</a>.</p>
<ul class="simple">
<li><p>TableGen <code class="docutils literal notranslate"><span class="pre">class</span></code> is similar to C++ class; it can be templated and
subclassed.</p></li>
<li><p>TableGen <code class="docutils literal notranslate"><span class="pre">def</span></code> is similar to C++ object; it can be declared by specializing
a TableGen <code class="docutils literal notranslate"><span class="pre">class</span></code> (e.g., <code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">MyDef</span> <span class="pre">:</span> <span class="pre">MyClass&lt;...&gt;;</span></code>) or completely
independently (e.g., <code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">MyDef;</span></code>). It cannot be further templated or
subclassed.</p></li>
<li><p>TableGen <code class="docutils literal notranslate"><span class="pre">dag</span></code> is a dedicated type for directed acyclic graph of elements. A
<code class="docutils literal notranslate"><span class="pre">dag</span></code> has one operator and zero or more arguments. Its syntax is <code class="docutils literal notranslate"><span class="pre">(operator</span> <span class="pre">arg0,</span> <span class="pre">arg1,</span> <span class="pre">argN)</span></code>. The operator can be any TableGen <code class="docutils literal notranslate"><span class="pre">def</span></code>; an argument can
be anything, including <code class="docutils literal notranslate"><span class="pre">dag</span></code> itself. We can have names attached to both the
operator and the arguments like <code class="docutils literal notranslate"><span class="pre">(MyOp:$op_name</span> <span class="pre">MyArg:$arg_name)</span></code>.</p></li>
</ul>
<p>Please see the <a class="reference external" href="https://llvm.org/docs/TableGen/ProgRef.html">language reference</a> to learn about all the
types and expressions supported by TableGen.</p>
</section>
<section id="operation-definition">
<h2>Operation Definition<a class="headerlink" href="#operation-definition" title="此标题的永久链接">¶</a></h2>
<p>MLIR defines several common constructs to help operation definition and provide
their semantics via a special <a class="reference external" href="https://llvm.org/docs/TableGen/BackEnds.html#introduction">TableGen backend</a>:
<a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/mlir/tools/mlir-tblgen/OpDefinitionsGen.cpp"><code class="docutils literal notranslate"><span class="pre">OpDefinitionsGen</span></code></a>. These constructs are defined in
<a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/IR/OpBase.td"><code class="docutils literal notranslate"><span class="pre">OpBase.td</span></code></a>. The main ones are:</p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">Op</span></code> class: It is the main construct for defining operations. All facts
regarding the operation are specified when specializing this class, with the
help of the following constructs.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">Dialect</span></code> class: Operations belonging to one logical group are placed in
the same dialect. The <code class="docutils literal notranslate"><span class="pre">Dialect</span></code> class contains dialect-level information.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">OpTrait</span></code> class hierarchy: They are used to specify special properties
and constraints of the operation, including whether the operation has side
effect or whether its output has the same shape as the input.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">ins</span></code>/<code class="docutils literal notranslate"><span class="pre">outs</span></code> marker: These are two special markers builtin to the
<code class="docutils literal notranslate"><span class="pre">OpDefinitionsGen</span></code> backend. They lead to the definitions of operands/attributes
and results respectively.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">TypeConstraint</span></code> class hierarchy: They are used to specify the
constraints over operands or results. A notable subclass hierarchy is
<code class="docutils literal notranslate"><span class="pre">Type</span></code>, which stands for constraints for common C++ types.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">AttrConstraint</span></code> class hierarchy: They are used to specify the
constraints over attributes. A notable subclass hierarchy is <code class="docutils literal notranslate"><span class="pre">Attr</span></code>, which
stands for constraints for attributes whose values are of common types.</p></li>
</ul>
<p>An operation is defined by specializing the <code class="docutils literal notranslate"><span class="pre">Op</span></code> class with concrete contents
for all the fields it requires. For example, <code class="docutils literal notranslate"><span class="pre">tf.AvgPool</span></code> is defined as</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def TF_AvgPoolOp : TF_Op&lt;&quot;AvgPool&quot;, [NoMemoryEffect]&gt; {
  let summary = &quot;Performs average pooling on the input.&quot;;

  let description = [{
Each entry in `output` is the mean of the corresponding size `ksize`
window in `value`.
  }];

  let arguments = (ins
    TF_FpTensor:$value,

    ConfinedAttr&lt;I64ArrayAttr, [ArrayMinCount&lt;4&gt;]&gt;:$ksize,
    ConfinedAttr&lt;I64ArrayAttr, [ArrayMinCount&lt;4&gt;]&gt;:$strides,
    TF_AnyStrAttrOf&lt;[&quot;SAME&quot;, &quot;VALID&quot;]&gt;:$padding,
    DefaultValuedAttr&lt;TF_ConvertDataFormatAttr, &quot;NHWC&quot;&gt;:$data_format
  );

  let results = (outs
    TF_FpTensor:$output
  );

  TF_DerivedOperandTypeAttr T = TF_DerivedOperandTypeAttr&lt;0&gt;;
}
</pre></div>
</div>
<p>In the following we describe all the fields needed. Please see the definition of
the <code class="docutils literal notranslate"><span class="pre">Op</span></code> class for the complete list of fields supported.</p>
<section id="operation-name">
<h3>Operation name<a class="headerlink" href="#operation-name" title="此标题的永久链接">¶</a></h3>
<p>The operation name is a unique identifier for the operation within MLIR, e.g.,
<code class="docutils literal notranslate"><span class="pre">tf.Add</span></code> for addition operation in the TensorFlow dialect. This is the
equivalent of the mnemonic in assembly language. It is used for parsing and
printing in the textual format. It is also used for pattern matching in graph
rewrites.</p>
<p>The full operation name is composed of the dialect name and the op name, with
the former provided via the dialect and the latter provided as the second
template parameter to the <code class="docutils literal notranslate"><span class="pre">Op</span></code> class.</p>
</section>
<section id="operation-documentation">
<h3>Operation documentation<a class="headerlink" href="#operation-documentation" title="此标题的永久链接">¶</a></h3>
<p>This includes both a one-line <code class="docutils literal notranslate"><span class="pre">summary</span></code> and a longer human-readable
<code class="docutils literal notranslate"><span class="pre">description</span></code>. They will be used to drive automatic generation of dialect
documentation. They need to be provided in the operation’s definition body:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>let summary = &quot;...&quot;;

let description = [{
...
}];
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">description</span></code> should be written in Markdown syntax.</p>
<p>Placing the documentation at the beginning is recommended since it helps in
understanding the operation.</p>
<blockquote>
<div><ul class="simple">
<li><p>Place documentation at the beginning of the operation definition</p></li>
<li><p>The summary should be short and concise. It should be a one-liner without
trailing punctuation. Put expanded explanation in description.</p></li>
</ul>
</div></blockquote>
</section>
<section id="operation-arguments">
<h3>Operation arguments<a class="headerlink" href="#operation-arguments" title="此标题的永久链接">¶</a></h3>
<p>There are two kinds of arguments: operands and attributes. Operands are runtime
values produced by other ops; while attributes are compile-time known constant
values, including two categories:</p>
<ol>
<li><p>Natural attributes: these attributes affect the behavior of the operations
(e.g., padding for convolution);</p></li>
<li><p>Derived attributes: these attributes are not needed to define the operation
but are instead derived from information of the operation. E.g., the output
shape of type. This is mostly used for convenience interface generation or
interaction with other frameworks/translation.</p>
<p>All derived attributes should be materializable as an Attribute. That is,
even though they are not materialized, it should be possible to store as an
attribute.</p>
</li>
</ol>
<p>Both operands and attributes are specified inside the <code class="docutils literal notranslate"><span class="pre">dag</span></code>-typed <code class="docutils literal notranslate"><span class="pre">arguments</span></code>,
led by <code class="docutils literal notranslate"><span class="pre">ins</span></code>:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>let arguments = (ins
  &lt;type-constraint&gt;:$&lt;operand-name&gt;,
  ...
  &lt;attr-constraint&gt;:$&lt;attr-name&gt;,
  ...
);
</pre></div>
</div>
<p>Here <code class="docutils literal notranslate"><span class="pre">&lt;type-constraint&gt;</span></code> is a TableGen <code class="docutils literal notranslate"><span class="pre">def</span></code> from the <code class="docutils literal notranslate"><span class="pre">TypeConstraint</span></code> class
hierarchy. Similarly, <code class="docutils literal notranslate"><span class="pre">&lt;attr-constraint&gt;</span></code> is a TableGen <code class="docutils literal notranslate"><span class="pre">def</span></code> from the
<code class="docutils literal notranslate"><span class="pre">AttrConstraint</span></code> class hierarchy. See <a class="reference external" href="#constraints">Constraints</a> for more
information.</p>
<p>There is no requirements on the relative order of operands and attributes; they
can mix freely. The relative order of operands themselves matters. From each
named argument a named getter will be generated that returns the argument with
the return type (in the case of attributes the return type will be constructed
from the storage type, while for operands it will be <code class="docutils literal notranslate"><span class="pre">Value</span></code>). Each attribute’s
raw value (e.g., as stored) can also be accessed via generated <code class="docutils literal notranslate"><span class="pre">&lt;name&gt;Attr</span></code>
getters for use in transformation passes where the more user-friendly return
type is less suitable.</p>
<p>All the arguments should be named to:</p>
<ul class="simple">
<li><p>provide documentation,</p></li>
<li><p>drive auto-generation of getter methods, and</p></li>
<li><p>provide a handle to reference for other places like constraints.</p></li>
</ul>
<section id="variadic-operands">
<h4>Variadic operands<a class="headerlink" href="#variadic-operands" title="此标题的永久链接">¶</a></h4>
<p>To declare a variadic operand, wrap the <code class="docutils literal notranslate"><span class="pre">TypeConstraint</span></code> for the operand with
<code class="docutils literal notranslate"><span class="pre">Variadic&lt;...&gt;</span></code>.</p>
<p>Normally operations have no variadic operands or just one variadic operand. For
the latter case, it is easy to deduce which dynamic operands are for the static
variadic operand definition. However, if an operation has more than one variable
length operands (either optional or variadic), it would be impossible to
attribute dynamic operands to the corresponding static variadic operand
definitions without further information from the operation. Therefore, either
the <code class="docutils literal notranslate"><span class="pre">SameVariadicOperandSize</span></code> or <code class="docutils literal notranslate"><span class="pre">AttrSizedOperandSegments</span></code> trait is needed to
indicate that all variable length operands have the same number of dynamic
values.</p>
</section>
<section id="variadicofvariadic-operands">
<h4>VariadicOfVariadic operands<a class="headerlink" href="#variadicofvariadic-operands" title="此标题的永久链接">¶</a></h4>
<p>To declare a variadic operand that has a variadic number of sub-ranges, wrap the
<code class="docutils literal notranslate"><span class="pre">TypeConstraint</span></code> for the operand with <code class="docutils literal notranslate"><span class="pre">VariadicOfVariadic&lt;...,</span> <span class="pre">&quot;&lt;segment-attribute-name&gt;&quot;&gt;</span></code>.</p>
<p>The second field of the <code class="docutils literal notranslate"><span class="pre">VariadicOfVariadic</span></code> is the name of an <code class="docutils literal notranslate"><span class="pre">I32ElementsAttr</span></code>
argument that contains the sizes of the variadic sub-ranges. This attribute will
be used when determining the size of sub-ranges, or when updating the size of
sub-ranges.</p>
</section>
<section id="optional-operands">
<h4>Optional operands<a class="headerlink" href="#optional-operands" title="此标题的永久链接">¶</a></h4>
<p>To declare an optional operand, wrap the <code class="docutils literal notranslate"><span class="pre">TypeConstraint</span></code> for the operand with
<code class="docutils literal notranslate"><span class="pre">Optional&lt;...&gt;</span></code>.</p>
<p>Normally operations have no optional operands or just one optional operand. For
the latter case, it is easy to deduce which dynamic operands are for the static
operand definition. However, if an operation has more than one variable length
operands (either optional or variadic), it would be impossible to attribute
dynamic operands to the corresponding static variadic operand definitions
without further information from the operation. Therefore, either the
<code class="docutils literal notranslate"><span class="pre">SameVariadicOperandSize</span></code> or <code class="docutils literal notranslate"><span class="pre">AttrSizedOperandSegments</span></code> trait is needed to
indicate that all variable length operands have the same number of dynamic
values.</p>
</section>
<section id="optional-attributes">
<h4>Optional attributes<a class="headerlink" href="#optional-attributes" title="此标题的永久链接">¶</a></h4>
<p>To declare an optional attribute, wrap the <code class="docutils literal notranslate"><span class="pre">AttrConstraint</span></code> for the attribute
with <code class="docutils literal notranslate"><span class="pre">OptionalAttr&lt;...&gt;</span></code>.</p>
</section>
<section id="attributes-with-default-values">
<h4>Attributes with default values<a class="headerlink" href="#attributes-with-default-values" title="此标题的永久链接">¶</a></h4>
<p>To declare an attribute with a default value, wrap the <code class="docutils literal notranslate"><span class="pre">AttrConstraint</span></code> for the
attribute with <code class="docutils literal notranslate"><span class="pre">DefaultValuedAttr&lt;...,</span> <span class="pre">&quot;...&quot;&gt;</span></code>.</p>
<p>The second parameter to <code class="docutils literal notranslate"><span class="pre">DefaultValuedAttr</span></code> should be a string containing the
C++ default value. For example, a float default value should be specified as
like <code class="docutils literal notranslate"><span class="pre">&quot;0.5f&quot;</span></code>, and an integer array default value should be specified as like
<code class="docutils literal notranslate"><span class="pre">&quot;{1,</span> <span class="pre">2,</span> <span class="pre">3}&quot;</span></code>.</p>
<p>The generated operation printing function will not print default-valued
attributes when the attribute value is equal to the default.</p>
</section>
<section id="confining-attributes">
<h4>Confining attributes<a class="headerlink" href="#confining-attributes" title="此标题的永久链接">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">ConfinedAttr</span></code> is provided as a general mechanism to help modelling further
constraints on attributes beyond the ones brought by value types. You can use
<code class="docutils literal notranslate"><span class="pre">ConfinedAttr</span></code> to compose complex constraints out of more primitive ones. For
example, a 32-bit integer attribute whose minimum value must be 10 can be
expressed as <code class="docutils literal notranslate"><span class="pre">ConfinedAttr&lt;I32Attr,</span> <span class="pre">[IntMinValue&lt;10&gt;]&gt;</span></code>.</p>
<p>Right now, the following primitive constraints are supported:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">IntMinValue&lt;N&gt;</span></code>: Specifying an integer attribute to be greater than or
equal to <code class="docutils literal notranslate"><span class="pre">N</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">IntMaxValue&lt;N&gt;</span></code>: Specifying an integer attribute to be less than or equal
to <code class="docutils literal notranslate"><span class="pre">N</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ArrayMinCount&lt;N&gt;</span></code>: Specifying an array attribute to have at least <code class="docutils literal notranslate"><span class="pre">N</span></code>
elements</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">IntArrayNthElemEq&lt;I,</span> <span class="pre">N&gt;</span></code>: Specifying an integer array attribute’s <code class="docutils literal notranslate"><span class="pre">I</span></code>-th
element to be equal to <code class="docutils literal notranslate"><span class="pre">N</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">IntArrayNthElemMinValue&lt;I,</span> <span class="pre">N&gt;</span></code>: Specifying an integer array attribute’s
<code class="docutils literal notranslate"><span class="pre">I</span></code>-th element to be greater than or equal to <code class="docutils literal notranslate"><span class="pre">N</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">IntArrayNthElemMaxValue&lt;I,</span> <span class="pre">N&gt;</span></code>: Specifying an integer array attribute’s
<code class="docutils literal notranslate"><span class="pre">I</span></code>-th element to be less than or equal to <code class="docutils literal notranslate"><span class="pre">N</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">IntArrayNthElemInRange&lt;I,</span> <span class="pre">M,</span> <span class="pre">N&gt;</span></code>: Specifying an integer array attribute’s
<code class="docutils literal notranslate"><span class="pre">I</span></code>-th element to be greater than or equal to <code class="docutils literal notranslate"><span class="pre">M</span></code> and less than or equal to <code class="docutils literal notranslate"><span class="pre">N</span></code></p></li>
</ul>
<p>TODO: Design and implement more primitive constraints</p>
</section>
</section>
<section id="operation-regions">
<h3>Operation regions<a class="headerlink" href="#operation-regions" title="此标题的永久链接">¶</a></h3>
<p>The regions of an operation are specified inside of the <code class="docutils literal notranslate"><span class="pre">dag</span></code>-typed <code class="docutils literal notranslate"><span class="pre">regions</span></code>,
led by <code class="docutils literal notranslate"><span class="pre">region</span></code>:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>let regions = (region
  &lt;region-constraint&gt;:$&lt;region-name&gt;,
  ...
);
</pre></div>
</div>
<section id="variadic-regions">
<h4>Variadic regions<a class="headerlink" href="#variadic-regions" title="此标题的永久链接">¶</a></h4>
<p>Similar to the <code class="docutils literal notranslate"><span class="pre">Variadic</span></code> class used for variadic operands and results,
<code class="docutils literal notranslate"><span class="pre">VariadicRegion&lt;...&gt;</span></code> can be used for regions. Variadic regions can currently
only be specified as the last region in the regions list.</p>
</section>
</section>
<section id="operation-results">
<h3>Operation results<a class="headerlink" href="#operation-results" title="此标题的永久链接">¶</a></h3>
<p>Similar to operands, results are specified inside the <code class="docutils literal notranslate"><span class="pre">dag</span></code>-typed <code class="docutils literal notranslate"><span class="pre">results</span></code>, led
by <code class="docutils literal notranslate"><span class="pre">outs</span></code>:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>let results = (outs
  &lt;type-constraint&gt;:$&lt;result-name&gt;,
  ...
);
</pre></div>
</div>
<section id="variadic-results">
<h4>Variadic results<a class="headerlink" href="#variadic-results" title="此标题的永久链接">¶</a></h4>
<p>Similar to variadic operands, <code class="docutils literal notranslate"><span class="pre">Variadic&lt;...&gt;</span></code> can also be used for results. And
similarly, <code class="docutils literal notranslate"><span class="pre">SameVariadicResultSize</span></code> for multiple variadic results in the same
operation.</p>
</section>
</section>
<section id="operation-successors">
<h3>Operation successors<a class="headerlink" href="#operation-successors" title="此标题的永久链接">¶</a></h3>
<p>For terminator operations, the successors are specified inside of the
<code class="docutils literal notranslate"><span class="pre">dag</span></code>-typed <code class="docutils literal notranslate"><span class="pre">successors</span></code>, led by <code class="docutils literal notranslate"><span class="pre">successor</span></code>:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>let successors = (successor
  &lt;successor-constraint&gt;:$&lt;successor-name&gt;,
  ...
);
</pre></div>
</div>
<section id="variadic-successors">
<h4>Variadic successors<a class="headerlink" href="#variadic-successors" title="此标题的永久链接">¶</a></h4>
<p>Similar to the <code class="docutils literal notranslate"><span class="pre">Variadic</span></code> class used for variadic operands and results,
<code class="docutils literal notranslate"><span class="pre">VariadicSuccessor&lt;...&gt;</span></code> can be used for successors. Variadic successors can
currently only be specified as the last successor in the successor list.</p>
</section>
</section>
<section id="operation-traits-and-constraints">
<h3>Operation traits and constraints<a class="headerlink" href="#operation-traits-and-constraints" title="此标题的永久链接">¶</a></h3>
<p>Traits are operation properties that affect syntax or semantics. MLIR C++ models
various traits in the <code class="docutils literal notranslate"><span class="pre">mlir::OpTrait</span></code> namespace.</p>
<p>Both operation traits, <a class="reference external" href="../Interfaces.md/#utilizing-the-ods-framework">interfaces</a>,
and constraints involving multiple operands/attributes/results are provided as
the third template parameter to the <code class="docutils literal notranslate"><span class="pre">Op</span></code> class. They should be deriving from
the <code class="docutils literal notranslate"><span class="pre">OpTrait</span></code> class. See <a class="reference external" href="#constraints">Constraints</a> for more information.</p>
</section>
<section id="builder-methods">
<h3>Builder methods<a class="headerlink" href="#builder-methods" title="此标题的永久链接">¶</a></h3>
<p>For each operation, there are a few builders automatically generated based on
the arguments and returns types. For example, given the following op definition:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def MyOp : ... {
  let arguments = (ins
    I32:$i32_operand,
    F32:$f32_operand,
    ...,

    I32Attr:$i32_attr,
    F32Attr:$f32_attr,
    ...
  );

  let results = (outs
    I32:$i32_result,
    F32:$f32_result,
    ...
  );
}
</pre></div>
</div>
<p>The following builders are generated:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// All result-types/operands/attributes have one aggregate parameter.</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">build</span><span class="p">(</span><span class="n">OpBuilder</span><span class="w"> </span><span class="o">&amp;</span><span class="n">odsBuilder</span><span class="p">,</span><span class="w"> </span><span class="n">OperationState</span><span class="w"> </span><span class="o">&amp;</span><span class="n">odsState</span><span class="p">,</span>
<span class="w">                  </span><span class="n">TypeRange</span><span class="w"> </span><span class="n">resultTypes</span><span class="p">,</span>
<span class="w">                  </span><span class="n">ValueRange</span><span class="w"> </span><span class="n">operands</span><span class="p">,</span>
<span class="w">                  </span><span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">NamedAttribute</span><span class="o">&gt;</span><span class="w"> </span><span class="n">attributes</span><span class="p">);</span>

<span class="c1">// Each result-type/operand/attribute has a separate parameter. The parameters</span>
<span class="c1">// for attributes are of mlir::Attribute types.</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">build</span><span class="p">(</span><span class="n">OpBuilder</span><span class="w"> </span><span class="o">&amp;</span><span class="n">odsBuilder</span><span class="p">,</span><span class="w"> </span><span class="n">OperationState</span><span class="w"> </span><span class="o">&amp;</span><span class="n">odsState</span><span class="p">,</span>
<span class="w">                  </span><span class="n">Type</span><span class="w"> </span><span class="n">i32_result</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="n">f32_result</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span>
<span class="w">                  </span><span class="n">Value</span><span class="w"> </span><span class="n">i32_operand</span><span class="p">,</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="n">f32_operand</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span>
<span class="w">                  </span><span class="n">IntegerAttr</span><span class="w"> </span><span class="n">i32_attr</span><span class="p">,</span><span class="w"> </span><span class="n">FloatAttr</span><span class="w"> </span><span class="n">f32_attr</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span>

<span class="c1">// Each result-type/operand/attribute has a separate parameter. The parameters</span>
<span class="c1">// for attributes are raw values unwrapped with mlir::Attribute instances.</span>
<span class="c1">// (Note that this builder will not always be generated. See the following</span>
<span class="c1">// explanation for more details.)</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">build</span><span class="p">(</span><span class="n">OpBuilder</span><span class="w"> </span><span class="o">&amp;</span><span class="n">odsBuilder</span><span class="p">,</span><span class="w"> </span><span class="n">OperationState</span><span class="w"> </span><span class="o">&amp;</span><span class="n">odsState</span><span class="p">,</span>
<span class="w">                  </span><span class="n">Type</span><span class="w"> </span><span class="n">i32_result</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="n">f32_result</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span>
<span class="w">                  </span><span class="n">Value</span><span class="w"> </span><span class="n">i32_operand</span><span class="p">,</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="n">f32_operand</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span>
<span class="w">                  </span><span class="n">APInt</span><span class="w"> </span><span class="n">i32_attr</span><span class="p">,</span><span class="w"> </span><span class="n">StringRef</span><span class="w"> </span><span class="n">f32_attr</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span>

<span class="c1">// Each operand/attribute has a separate parameter but result type is aggregate.</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">build</span><span class="p">(</span><span class="n">OpBuilder</span><span class="w"> </span><span class="o">&amp;</span><span class="n">odsBuilder</span><span class="p">,</span><span class="w"> </span><span class="n">OperationState</span><span class="w"> </span><span class="o">&amp;</span><span class="n">odsState</span><span class="p">,</span>
<span class="w">                  </span><span class="n">TypeRange</span><span class="w"> </span><span class="n">resultTypes</span><span class="p">,</span>
<span class="w">                  </span><span class="n">Value</span><span class="w"> </span><span class="n">i32_operand</span><span class="p">,</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="n">f32_operand</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span>
<span class="w">                  </span><span class="n">IntegerAttr</span><span class="w"> </span><span class="n">i32_attr</span><span class="p">,</span><span class="w"> </span><span class="n">FloatAttr</span><span class="w"> </span><span class="n">f32_attr</span><span class="p">,</span><span class="w"> </span><span class="p">...);</span>

<span class="c1">// All operands/attributes have aggregate parameters.</span>
<span class="c1">// Generated if return type can be inferred.</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">build</span><span class="p">(</span><span class="n">OpBuilder</span><span class="w"> </span><span class="o">&amp;</span><span class="n">odsBuilder</span><span class="p">,</span><span class="w"> </span><span class="n">OperationState</span><span class="w"> </span><span class="o">&amp;</span><span class="n">odsState</span><span class="p">,</span>
<span class="w">                  </span><span class="n">ValueRange</span><span class="w"> </span><span class="n">operands</span><span class="p">,</span><span class="w"> </span><span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">NamedAttribute</span><span class="o">&gt;</span><span class="w"> </span><span class="n">attributes</span><span class="p">);</span>

<span class="c1">// (And manually specified builders depending on the specific op.)</span>
</pre></div>
</div>
<p>The first form provides basic uniformity so that we can create ops using the
same form regardless of the exact op. This is particularly useful for
implementing declarative pattern rewrites.</p>
<p>The second and third forms are good for use in manually written code, given that
they provide better guarantee via signatures.</p>
<p>The third form will be generated if any of the op’s attribute has different
<code class="docutils literal notranslate"><span class="pre">Attr.returnType</span></code> from <code class="docutils literal notranslate"><span class="pre">Attr.storageType</span></code> and we know how to build an attribute
from an unwrapped value (i.e., <code class="docutils literal notranslate"><span class="pre">Attr.constBuilderCall</span></code> is defined.)
Additionally, for the third form, if an attribute appearing later in the
<code class="docutils literal notranslate"><span class="pre">arguments</span></code> list has a default value, the default value will be supplied in the
declaration. This works for <code class="docutils literal notranslate"><span class="pre">BoolAttr</span></code>, <code class="docutils literal notranslate"><span class="pre">StrAttr</span></code>, <code class="docutils literal notranslate"><span class="pre">EnumAttr</span></code> for now and the
list can grow in the future. So if possible, the default-valued attribute should be
placed at the end of the <code class="docutils literal notranslate"><span class="pre">arguments</span></code> list to leverage this feature. (This
behavior is essentially due to C++ function parameter default value placement
restrictions.) Otherwise, the builder of the third form will still be generated
but default values for the attributes not at the end of the <code class="docutils literal notranslate"><span class="pre">arguments</span></code> list
will not be supplied in the builder’s signature.</p>
<p>ODS will generate a builder that doesn’t require the return type specified if</p>
<ul class="simple">
<li><p>Op implements InferTypeOpInterface interface;</p></li>
<li><p>All return types are either buildable types or are the same as a given
operand (e.g., <code class="docutils literal notranslate"><span class="pre">AllTypesMatch</span></code> constraint between operand and result);</p></li>
</ul>
<p>And there may potentially exist other builders depending on the specific op;
please refer to the
<a class="reference external" href="#run-mlir-tblgen-to-see-the-generated-content">generated C++ file</a> for the
complete list.</p>
<section id="custom-builder-methods">
<h4>Custom builder methods<a class="headerlink" href="#custom-builder-methods" title="此标题的永久链接">¶</a></h4>
<p>However, if the above cases cannot satisfy all needs, you can define additional
convenience build methods in the <code class="docutils literal notranslate"><span class="pre">builders</span></code> field as follows.</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def MyOp : Op&lt;&quot;my_op&quot;, []&gt; {
  let arguments = (ins F32Attr:$attr);

  let builders = [
    OpBuilder&lt;(ins &quot;float&quot;:$val)&gt;
  ];
}
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">builders</span></code> field is a list of custom builders that are added to the Op
class. In this example, we provide a convenience builder that takes a floating
point value instead of an attribute. The <code class="docutils literal notranslate"><span class="pre">ins</span></code> prefix is common to many function
declarations in ODS, which use a TableGen <a class="reference external" href="#tablegen-syntax"><code class="docutils literal notranslate"><span class="pre">dag</span></code></a>. What
follows is a comma-separated list of types (quoted string) and names prefixed
with the <code class="docutils literal notranslate"><span class="pre">$</span></code> sign. This will generate the declaration of a builder method that
looks like:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyOp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="cm">/*...*/</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="cm">/*...*/</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">build</span><span class="p">(</span><span class="o">::</span><span class="n">mlir</span><span class="o">::</span><span class="n">OpBuilder</span><span class="w"> </span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span><span class="w"> </span><span class="o">::</span><span class="n">mlir</span><span class="o">::</span><span class="n">OperationState</span><span class="w"> </span><span class="o">&amp;</span><span class="n">state</span><span class="p">,</span>
<span class="w">                    </span><span class="kt">float</span><span class="w"> </span><span class="n">val</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Note that the method has two additional leading arguments. These arguments are
useful to construct the operation. In particular, the method must populate
<code class="docutils literal notranslate"><span class="pre">state</span></code> with attributes, operands, regions and result types of the operation to
be constructed. <code class="docutils literal notranslate"><span class="pre">builder</span></code> can be used to construct any IR objects that belong to
the Op, such as types or nested operations. Since the type and name are
generated as is in the C++ code, they should be valid C++ constructs for a type
(in the namespace of the Op) and an identifier (e.g., <code class="docutils literal notranslate"><span class="pre">class</span></code> is not a valid
identifier).</p>
<p>Implementations of the builder can be provided directly in ODS, using TableGen
code block as follows.</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def MyOp : Op&lt;&quot;my_op&quot;, []&gt; {
  let arguments = (ins F32Attr:$attr);

  let builders = [
    OpBuilder&lt;(ins &quot;float&quot;:$val), [{
      $_state.addAttribute(&quot;attr&quot;, $_builder.getF32FloatAttr(val));
    }]&gt;
  ];
}
</pre></div>
</div>
<p>The equivalents of <code class="docutils literal notranslate"><span class="pre">builder</span></code> and <code class="docutils literal notranslate"><span class="pre">state</span></code> arguments are available as <code class="docutils literal notranslate"><span class="pre">$_builder</span></code>
and <code class="docutils literal notranslate"><span class="pre">$_state</span></code> special variables. The named arguments listed in the <code class="docutils literal notranslate"><span class="pre">ins</span></code> part
are available directly, e.g. <code class="docutils literal notranslate"><span class="pre">val</span></code>. The body of the builder will be generated by
substituting special variables and should otherwise be valid C++. While there is
no limitation on the code size, we encourage one to define only short builders
inline in ODS and put definitions of longer builders in C++ files.</p>
<p>Finally, if some arguments need a default value, they can be defined using
<code class="docutils literal notranslate"><span class="pre">CArg</span></code> to wrap the type and this value as follows.</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def MyOp : Op&lt;&quot;my_op&quot;, []&gt; {
  let arguments = (ins F32Attr:$attr);

  let builders = [
    OpBuilder&lt;(ins CArg&lt;&quot;float&quot;, &quot;0.5f&quot;&gt;:$val), [{
      $_state.addAttribute(&quot;attr&quot;, $_builder.getF32FloatAttr(val));
    }]&gt;
  ];
}
</pre></div>
</div>
<p>The generated code will use default value in the declaration, but not in the
definition, as required by C++.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// Header file.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MyOp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="cm">/*...*/</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="cm">/*...*/</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">build</span><span class="p">(</span><span class="o">::</span><span class="n">mlir</span><span class="o">::</span><span class="n">OpBuilder</span><span class="w"> </span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span><span class="w"> </span><span class="o">::</span><span class="n">mlir</span><span class="o">::</span><span class="n">OperationState</span><span class="w"> </span><span class="o">&amp;</span><span class="n">state</span><span class="p">,</span>
<span class="w">                    </span><span class="kt">float</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">/// Source file.</span>
<span class="n">MyOp</span><span class="o">::</span><span class="n">build</span><span class="p">(</span><span class="o">::</span><span class="n">mlir</span><span class="o">::</span><span class="n">OpBuilder</span><span class="w"> </span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span><span class="w"> </span><span class="o">::</span><span class="n">mlir</span><span class="o">::</span><span class="n">OperationState</span><span class="w"> </span><span class="o">&amp;</span><span class="n">state</span><span class="p">,</span>
<span class="w">            </span><span class="kt">float</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">state</span><span class="p">.</span><span class="n">addAttribute</span><span class="p">(</span><span class="s">&quot;attr&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="n">getF32FloatAttr</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="custom-parser-and-printer-methods">
<h3>Custom parser and printer methods<a class="headerlink" href="#custom-parser-and-printer-methods" title="此标题的永久链接">¶</a></h3>
<p>Functions to parse and print the operation’s custom assembly form.</p>
</section>
<section id="custom-verifier-code">
<h3>Custom verifier code<a class="headerlink" href="#custom-verifier-code" title="此标题的永久链接">¶</a></h3>
<p>Verification code will be automatically generated for
<a class="reference external" href="#constraints">constraints</a> specified on various entities of the op. To perform
<em>additional</em> verification, you can use</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>let hasVerifier = 1;
let hasRegionVerifier = 1;
</pre></div>
</div>
<p>This will generate <code class="docutils literal notranslate"><span class="pre">LogicalResult</span> <span class="pre">verify()</span></code>/<code class="docutils literal notranslate"><span class="pre">LogicalResult</span> <span class="pre">verifyRegions()</span></code>
method declarations on the op class that can be defined with any additional
verification constraints. For verificaiton which needs to access the nested
operations, you should use <code class="docutils literal notranslate"><span class="pre">hasRegionVerifier</span></code> to ensure that it won’t access
any ill-formed operation. Except that, The other verifications can be
implemented with <code class="docutils literal notranslate"><span class="pre">hasVerifier</span></code>. Check the next section for the execution order
of these verification methods.</p>
<section id="verification-ordering">
<h4>Verification Ordering<a class="headerlink" href="#verification-ordering" title="此标题的永久链接">¶</a></h4>
<p>The verification of an operation involves several steps,</p>
<ol class="simple">
<li><p>StructuralOpTrait will be verified first, they can be run independently.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verifyInvariants</span></code> which is constructed by ODS, it verifies the type,
attributes, .etc.</p></li>
<li><p>Other Traits/Interfaces that have marked their verifier as <code class="docutils literal notranslate"><span class="pre">verifyTrait</span></code> or
<code class="docutils literal notranslate"><span class="pre">verifyWithRegions=0</span></code>.</p></li>
<li><p>Custom verifier which is defined in the op and has been marked <code class="docutils literal notranslate"><span class="pre">hasVerifier=1</span></code></p></li>
</ol>
<p>If an operation has regions, then it may have the second phase,</p>
<ol class="simple">
<li><p>Traits/Interfaces that have marked their verifier as <code class="docutils literal notranslate"><span class="pre">verifyRegionTrait</span></code> or
<code class="docutils literal notranslate"><span class="pre">verifyWithRegions=1</span></code>. This implies the verifier needs to access the
operations in its regions.</p></li>
<li><p>Custom verifier which is defined in the op and has been marked
<code class="docutils literal notranslate"><span class="pre">hasRegionVerifier=1</span></code></p></li>
</ol>
<p>Note that the second phase will be run after the operations in the region are
verified. Verifiers further down the order can rely on certain invariants being
verified by a previous verifier and do not need to re-verify them.</p>
</section>
<section id="emitting-diagnostics-in-custom-verifiers">
<h4>Emitting diagnostics in custom verifiers<a class="headerlink" href="#emitting-diagnostics-in-custom-verifiers" title="此标题的永久链接">¶</a></h4>
<p>Custom verifiers should avoid printing operations using custom operation
printers, because they require the printed operation (and sometimes its parent
operation) to be verified first. In particular, when emitting diagnostics,
custom verifiers should use the <code class="docutils literal notranslate"><span class="pre">Error</span></code> severity level, which prints operations
in generic form by default, and avoid using lower severity levels (<code class="docutils literal notranslate"><span class="pre">Note</span></code>,
<code class="docutils literal notranslate"><span class="pre">Remark</span></code>, <code class="docutils literal notranslate"><span class="pre">Warning</span></code>).</p>
</section>
</section>
<section id="declarative-assembly-format">
<h3>Declarative Assembly Format<a class="headerlink" href="#declarative-assembly-format" title="此标题的永久链接">¶</a></h3>
<p>The custom assembly form of the operation may be specified in a declarative
string that matches the operations operands, attributes, etc. With the ability
to express additional information that needs to be parsed to build the
operation:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def CallOp : Std_Op&lt;&quot;call&quot;, ...&gt; {
  let arguments = (ins FlatSymbolRefAttr:$callee, Variadic&lt;AnyType&gt;:$args);
  let results = (outs Variadic&lt;AnyType&gt;);

  let assemblyFormat = [{
    $callee `(` $args `)` attr-dict `:` functional-type($args, results)
  }];
}
</pre></div>
</div>
<p>The format is comprised of three components:</p>
<section id="directives">
<h4>Directives<a class="headerlink" href="#directives" title="此标题的永久链接">¶</a></h4>
<p>A directive is a type of builtin function, with an optional set of arguments.
The available directives are as follows:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">attr-dict</span></code></p>
<ul>
<li><p>Represents the attribute dictionary of the operation.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">attr-dict-with-keyword</span></code></p>
<ul>
<li><p>Represents the attribute dictionary of the operation, but prefixes the
dictionary with an <code class="docutils literal notranslate"><span class="pre">attributes</span></code> keyword.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">custom</span></code> &lt; UserDirective &gt; ( Params )</p>
<ul>
<li><p>Represents a custom directive implemented by the user in C++.</p></li>
<li><p>See the <a class="reference external" href="#custom-directives">Custom Directives</a> section below for more
details.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">functional-type</span></code> ( inputs , outputs )</p>
<ul>
<li><p>Formats the <code class="docutils literal notranslate"><span class="pre">inputs</span></code> and <code class="docutils literal notranslate"><span class="pre">outputs</span></code> arguments as a
<a class="reference external" href="../Dialects/Builtin.md/#functiontype">function type</a>.</p></li>
<li><p>The constraints on <code class="docutils literal notranslate"><span class="pre">inputs</span></code> and <code class="docutils literal notranslate"><span class="pre">outputs</span></code> are the same as the <code class="docutils literal notranslate"><span class="pre">input</span></code> of
the <code class="docutils literal notranslate"><span class="pre">type</span></code> directive.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">oilist</span></code> ( `keyword` elements | `otherKeyword` elements …)</p>
<ul>
<li><p>Represents an optional order-independent list of clauses. Each clause
has a keyword and corresponding assembly format.</p></li>
<li><p>Each clause can appear 0 or 1 time (in any order).</p></li>
<li><p>Only literals, types and variables can be used within an oilist element.</p></li>
<li><p>All the variables must be optional or variadic.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">operands</span></code></p>
<ul>
<li><p>Represents all of the operands of an operation.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">ref</span></code> ( input )</p>
<ul>
<li><p>Represents a reference to the a variable or directive, that must have
already been resolved, that may be used as a parameter to a <code class="docutils literal notranslate"><span class="pre">custom</span></code>
directive.</p></li>
<li><p>Used to pass previously parsed entities to custom directives.</p></li>
<li><p>The input may be any directive or variable, aside from <code class="docutils literal notranslate"><span class="pre">functional-type</span></code>
and <code class="docutils literal notranslate"><span class="pre">custom</span></code>.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">regions</span></code></p>
<ul>
<li><p>Represents all of the regions of an operation.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">results</span></code></p>
<ul>
<li><p>Represents all of the results of an operation.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">successors</span></code></p>
<ul>
<li><p>Represents all of the successors of an operation.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">type</span></code> ( input )</p>
<ul>
<li><p>Represents the type of the given input.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">input</span></code> must be either an operand or result <a class="reference external" href="#variables">variable</a>, the
<code class="docutils literal notranslate"><span class="pre">operands</span></code> directive, or the <code class="docutils literal notranslate"><span class="pre">results</span></code> directive.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">qualified</span></code> ( type_or_attribute )</p>
<ul>
<li><p>Wraps a <code class="docutils literal notranslate"><span class="pre">type</span></code> directive or an attribute parameter.</p></li>
<li><p>Used to force printing the type or attribute prefixed with its dialect
and mnemonic. For example the <code class="docutils literal notranslate"><span class="pre">vector.multi_reduction</span></code> operation has a
<code class="docutils literal notranslate"><span class="pre">kind</span></code> attribute ; by default the declarative assembly will print:
<code class="docutils literal notranslate"><span class="pre">vector.multi_reduction</span> <span class="pre">&lt;minf&gt;,</span> <span class="pre">...</span></code> but using <code class="docutils literal notranslate"><span class="pre">qualified($kind)</span></code> in the
declarative assembly format will print it instead as:
<code class="docutils literal notranslate"><span class="pre">vector.multi_reduction</span> <span class="pre">#vector.kind&lt;minf&gt;,</span> <span class="pre">...</span></code>.</p></li>
</ul>
</li>
</ul>
</section>
<section id="literals">
<h4>Literals<a class="headerlink" href="#literals" title="此标题的永久链接">¶</a></h4>
<p>A literal is either a keyword or punctuation surrounded by ``.</p>
<p>The following are the set of valid punctuation:</p>
<p><code class="docutils literal notranslate"><span class="pre">:</span></code>, <code class="docutils literal notranslate"><span class="pre">,</span></code>, <code class="docutils literal notranslate"><span class="pre">=</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">(</span></code>, <code class="docutils literal notranslate"><span class="pre">)</span></code>, <code class="docutils literal notranslate"><span class="pre">{</span></code>, <code class="docutils literal notranslate"><span class="pre">}</span></code>, <code class="docutils literal notranslate"><span class="pre">[</span></code>, <code class="docutils literal notranslate"><span class="pre">]</span></code>, <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">?</span></code>, <code class="docutils literal notranslate"><span class="pre">+</span></code>, <code class="docutils literal notranslate"><span class="pre">*</span></code></p>
<p>The following are valid whitespace punctuation:</p>
<p><code class="docutils literal notranslate"><span class="pre">\n</span></code>, <code class="docutils literal notranslate"> </code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">\n</span></code> literal emits a newline an indents to the start of the operation. An
example is shown below:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>let assemblyFormat = [{
  `{` `\n` ` ` ` ` `this_is_on_a_newline` `\n` `}` attr-dict
}];
</pre></div>
</div>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>%results = my.operation {
  this_is_on_a_newline
}
</pre></div>
</div>
<p>An empty literal `` may be used to remove a space that is inserted implicitly
after certain literal elements, such as <code class="docutils literal notranslate"><span class="pre">)</span></code>/<code class="docutils literal notranslate"><span class="pre">]</span></code>/etc. For example, “<code class="docutils literal notranslate"><span class="pre">]</span></code>” may
result in an output of <code class="docutils literal notranslate"><span class="pre">]</span></code> it is not the last element in the format. “<code class="docutils literal notranslate"><span class="pre">]</span></code> ``”
would trim the trailing space in this situation.</p>
</section>
<section id="variables">
<h4>Variables<a class="headerlink" href="#variables" title="此标题的永久链接">¶</a></h4>
<p>A variable is an entity that has been registered on the operation itself, i.e.
an argument(attribute or operand), region, result, successor, etc. In the
<code class="docutils literal notranslate"><span class="pre">CallOp</span></code> example above, the variables would be <code class="docutils literal notranslate"><span class="pre">$callee</span></code> and <code class="docutils literal notranslate"><span class="pre">$args</span></code>.</p>
<p>Attribute variables are printed with their respective value type, unless that
value type is buildable. In those cases, the type of the attribute is elided.</p>
</section>
<section id="custom-directives">
<h4>Custom Directives<a class="headerlink" href="#custom-directives" title="此标题的永久链接">¶</a></h4>
<p>The declarative assembly format specification allows for handling a large
majority of the common cases when formatting an operation. For the operations
that require or desire specifying parts of the operation in a form not supported
by the declarative syntax, custom directives may be specified. A custom
directive essentially allows for users to use C++ for printing and parsing
subsections of an otherwise declaratively specified format. Looking at the
specification of a custom directive above:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>custom-directive ::= `custom` `&lt;` UserDirective `&gt;` `(` Params `)`
</pre></div>
</div>
<p>A custom directive has two main parts: The <code class="docutils literal notranslate"><span class="pre">UserDirective</span></code> and the <code class="docutils literal notranslate"><span class="pre">Params</span></code>. A
custom directive is transformed into a call to a <code class="docutils literal notranslate"><span class="pre">print*</span></code> and a <code class="docutils literal notranslate"><span class="pre">parse*</span></code> method
when generating the C++ code for the format. The <code class="docutils literal notranslate"><span class="pre">UserDirective</span></code> is an
identifier used as a suffix to these two calls, i.e., <code class="docutils literal notranslate"><span class="pre">custom&lt;MyDirective&gt;(...)</span></code>
would result in calls to <code class="docutils literal notranslate"><span class="pre">parseMyDirective</span></code> and <code class="docutils literal notranslate"><span class="pre">printMyDirective</span></code> within the
parser and printer respectively. <code class="docutils literal notranslate"><span class="pre">Params</span></code> may be any combination of variables
(i.e. Attribute, Operand, Successor, etc.), type directives, <code class="docutils literal notranslate"><span class="pre">attr-dict</span></code>, and
strings of C++ code. The type directives must refer to a variable, but that
variable need not also be a parameter to the custom directive.</p>
<p>The arguments to the <code class="docutils literal notranslate"><span class="pre">parse&lt;UserDirective&gt;</span></code> method are firstly a reference to
the <code class="docutils literal notranslate"><span class="pre">OpAsmParser</span></code>(<code class="docutils literal notranslate"><span class="pre">OpAsmParser</span> <span class="pre">&amp;</span></code>), and secondly a set of output parameters
corresponding to the parameters specified in the format. The mapping of
declarative parameter to <code class="docutils literal notranslate"><span class="pre">parse</span></code> method argument is detailed below:</p>
<ul class="simple">
<li><p>Attribute Variables</p>
<ul>
<li><p>Single: <code class="docutils literal notranslate"><span class="pre">&lt;Attribute-Storage-Type&gt;(e.g.</span> <span class="pre">Attribute)</span> <span class="pre">&amp;</span></code></p></li>
<li><p>Optional: <code class="docutils literal notranslate"><span class="pre">&lt;Attribute-Storage-Type&gt;(e.g.</span> <span class="pre">Attribute)</span> <span class="pre">&amp;</span></code></p></li>
</ul>
</li>
<li><p>Operand Variables</p>
<ul>
<li><p>Single: <code class="docutils literal notranslate"><span class="pre">OpAsmParser::UnresolvedOperand</span> <span class="pre">&amp;</span></code></p></li>
<li><p>Optional: <code class="docutils literal notranslate"><span class="pre">Optional&lt;OpAsmParser::UnresolvedOperand&gt;</span> <span class="pre">&amp;</span></code></p></li>
<li><p>Variadic: <code class="docutils literal notranslate"><span class="pre">SmallVectorImpl&lt;OpAsmParser::UnresolvedOperand&gt;</span> <span class="pre">&amp;</span></code></p></li>
<li><p>VariadicOfVariadic:
<code class="docutils literal notranslate"><span class="pre">SmallVectorImpl&lt;SmallVector&lt;OpAsmParser::UnresolvedOperand&gt;&gt;</span> <span class="pre">&amp;</span></code></p></li>
</ul>
</li>
<li><p>Ref Directives</p>
<ul>
<li><p>A reference directive is passed to the parser using the same mapping as
the input operand. For example, a single region would be passed as a
<code class="docutils literal notranslate"><span class="pre">Region</span> <span class="pre">&amp;</span></code>.</p></li>
</ul>
</li>
<li><p>Region Variables</p>
<ul>
<li><p>Single: <code class="docutils literal notranslate"><span class="pre">Region</span> <span class="pre">&amp;</span></code></p></li>
<li><p>Variadic: <code class="docutils literal notranslate"><span class="pre">SmallVectorImpl&lt;std::unique_ptr&lt;Region&gt;&gt;</span> <span class="pre">&amp;</span></code></p></li>
</ul>
</li>
<li><p>Successor Variables</p>
<ul>
<li><p>Single: <code class="docutils literal notranslate"><span class="pre">Block</span> <span class="pre">*&amp;</span></code></p></li>
<li><p>Variadic: <code class="docutils literal notranslate"><span class="pre">SmallVectorImpl&lt;Block</span> <span class="pre">*&gt;</span> <span class="pre">&amp;</span></code></p></li>
</ul>
</li>
<li><p>Type Directives</p>
<ul>
<li><p>Single: <code class="docutils literal notranslate"><span class="pre">Type</span> <span class="pre">&amp;</span></code></p></li>
<li><p>Optional: <code class="docutils literal notranslate"><span class="pre">Type</span> <span class="pre">&amp;</span></code></p></li>
<li><p>Variadic: <code class="docutils literal notranslate"><span class="pre">SmallVectorImpl&lt;Type&gt;</span> <span class="pre">&amp;</span></code></p></li>
<li><p>VariadicOfVariadic: <code class="docutils literal notranslate"><span class="pre">SmallVectorImpl&lt;SmallVector&lt;Type&gt;&gt;</span> <span class="pre">&amp;</span></code></p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">attr-dict</span></code> Directive: <code class="docutils literal notranslate"><span class="pre">NamedAttrList</span> <span class="pre">&amp;</span></code></p></li>
</ul>
<p>When a variable is optional, the value should only be specified if the variable
is present. Otherwise, the value should remain <code class="docutils literal notranslate"><span class="pre">None</span></code> or null.</p>
<p>The arguments to the <code class="docutils literal notranslate"><span class="pre">print&lt;UserDirective&gt;</span></code> method is firstly a reference to the
<code class="docutils literal notranslate"><span class="pre">OpAsmPrinter</span></code>(<code class="docutils literal notranslate"><span class="pre">OpAsmPrinter</span> <span class="pre">&amp;</span></code>), second the op (e.g. <code class="docutils literal notranslate"><span class="pre">FooOp</span> <span class="pre">op</span></code> which can be
<code class="docutils literal notranslate"><span class="pre">Operation</span> <span class="pre">*op</span></code> alternatively), and finally a set of output parameters
corresponding to the parameters specified in the format. The mapping of
declarative parameter to <code class="docutils literal notranslate"><span class="pre">print</span></code> method argument is detailed below:</p>
<ul class="simple">
<li><p>Attribute Variables</p>
<ul>
<li><p>Single: <code class="docutils literal notranslate"><span class="pre">&lt;Attribute-Storage-Type&gt;(e.g.</span> <span class="pre">Attribute)</span></code></p></li>
<li><p>Optional: <code class="docutils literal notranslate"><span class="pre">&lt;Attribute-Storage-Type&gt;(e.g.</span> <span class="pre">Attribute)</span></code></p></li>
</ul>
</li>
<li><p>Operand Variables</p>
<ul>
<li><p>Single: <code class="docutils literal notranslate"><span class="pre">Value</span></code></p></li>
<li><p>Optional: <code class="docutils literal notranslate"><span class="pre">Value</span></code></p></li>
<li><p>Variadic: <code class="docutils literal notranslate"><span class="pre">OperandRange</span></code></p></li>
<li><p>VariadicOfVariadic: <code class="docutils literal notranslate"><span class="pre">OperandRangeRange</span></code></p></li>
</ul>
</li>
<li><p>Ref Directives</p>
<ul>
<li><p>A reference directive is passed to the printer using the same mapping as
the input operand. For example, a single region would be passed as a
<code class="docutils literal notranslate"><span class="pre">Region</span> <span class="pre">&amp;</span></code>.</p></li>
</ul>
</li>
<li><p>Region Variables</p>
<ul>
<li><p>Single: <code class="docutils literal notranslate"><span class="pre">Region</span> <span class="pre">&amp;</span></code></p></li>
<li><p>Variadic: <code class="docutils literal notranslate"><span class="pre">MutableArrayRef&lt;Region&gt;</span></code></p></li>
</ul>
</li>
<li><p>Successor Variables</p>
<ul>
<li><p>Single: <code class="docutils literal notranslate"><span class="pre">Block</span> <span class="pre">*</span></code></p></li>
<li><p>Variadic: <code class="docutils literal notranslate"><span class="pre">SuccessorRange</span></code></p></li>
</ul>
</li>
<li><p>Type Directives</p>
<ul>
<li><p>Single: <code class="docutils literal notranslate"><span class="pre">Type</span></code></p></li>
<li><p>Optional: <code class="docutils literal notranslate"><span class="pre">Type</span></code></p></li>
<li><p>Variadic: <code class="docutils literal notranslate"><span class="pre">TypeRange</span></code></p></li>
<li><p>VariadicOfVariadic: <code class="docutils literal notranslate"><span class="pre">TypeRangeRange</span></code></p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">attr-dict</span></code> Directive: <code class="docutils literal notranslate"><span class="pre">DictionaryAttr</span></code></p></li>
</ul>
<p>When a variable is optional, the provided value may be null. When a variable is
referenced in a custom directive parameter using <code class="docutils literal notranslate"><span class="pre">ref</span></code>, it is passed in by
value. Referenced variables to <code class="docutils literal notranslate"><span class="pre">print&lt;UserDirective&gt;</span></code> are passed as the same as
bound variables, but referenced variables to <code class="docutils literal notranslate"><span class="pre">parse&lt;UserDirective&gt;</span></code> are passed
like to the printer.</p>
<p>A custom directive can take a string of C++ code as a parameter. The code is
pasted verbatim in the calls to the custom parser and printers, with the
substitutions <code class="docutils literal notranslate"><span class="pre">$_builder</span></code> and <code class="docutils literal notranslate"><span class="pre">$_ctxt</span></code>. String literals can be used to
parameterize custom directives.</p>
</section>
<section id="optional-groups">
<h4>Optional Groups<a class="headerlink" href="#optional-groups" title="此标题的永久链接">¶</a></h4>
<p>In certain situations operations may have “optional” information, e.g.
attributes or an empty set of variadic operands. In these situations a section
of the assembly format can be marked as <code class="docutils literal notranslate"><span class="pre">optional</span></code> based on the presence of this
information. An optional group is defined as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>optional-group: `(` then-elements `)` (`:` `(` else-elements `)`)? `?`
</pre></div>
</div>
<p>The elements of an optional group have the following requirements:</p>
<ul class="simple">
<li><p>The first element of <code class="docutils literal notranslate"><span class="pre">then-elements</span></code> must either be a attribute, literal,
operand, or region.</p>
<ul>
<li><p>This is because the first element must be optionally parsable.</p></li>
</ul>
</li>
<li><p>Exactly one argument variable or type directive within either
<code class="docutils literal notranslate"><span class="pre">then-elements</span></code> or <code class="docutils literal notranslate"><span class="pre">else-elements</span></code> must be marked as the anchor of the
group.</p>
<ul>
<li><p>The anchor is the element whose presence controls which elements
should be printed/parsed.</p></li>
<li><p>An element is marked as the anchor by adding a trailing <code class="docutils literal notranslate"><span class="pre">^</span></code>.</p></li>
<li><p>The first element is <em>not</em> required to be the anchor of the group.</p></li>
<li><p>When a non-variadic region anchors a group, the detector for printing
the group is if the region is empty.</p></li>
</ul>
</li>
<li><p>Literals, variables, custom directives, and type directives are the only
valid elements within the group.</p>
<ul>
<li><p>Any attribute variable may be used, but only optional or default-valued
attributes can be marked as the anchor. A default-valued anchor is
considered present if it holds a value other than the default.</p></li>
<li><p>Only variadic or optional results and operand arguments and can be used.</p></li>
<li><p>All region variables can be used. When a non-variable length region is
used, if the group is not present the region is empty.</p></li>
</ul>
</li>
</ul>
<p>An example of an operation with an optional group is <code class="docutils literal notranslate"><span class="pre">func.return</span></code>, which has a
variadic number of operands.</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def ReturnOp : ... {
  let arguments = (ins Variadic&lt;AnyType&gt;:$operands);

  // We only print the operands and types if there are a non-zero number
  // of operands.
  let assemblyFormat = &quot;attr-dict ($operands^ `:` type($operands))?&quot;;
}
</pre></div>
</div>
<section id="unit-attributes">
<h5>Unit Attributes<a class="headerlink" href="#unit-attributes" title="此标题的永久链接">¶</a></h5>
<p>In MLIR, the <a class="reference external" href="../Dialects/Builtin.md/#unitattr"><code class="docutils literal notranslate"><span class="pre">unit</span></code> Attribute</a> is special in that it
only has one possible value, i.e. it derives meaning from its existence. When a
unit attribute is used to anchor an optional group and is not the first element
of the group, the presence of the unit attribute can be directly correlated with
the presence of the optional group itself. As such, in these situations the unit
attribute will not be printed or present in the output and will be automatically
inferred when parsing by the presence of the optional group itself.</p>
<p>For example, the following operation:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def FooOp : ... {
  let arguments = (ins UnitAttr:$is_read_only);

  let assemblyFormat = &quot;attr-dict (`is_read_only` $is_read_only^)?&quot;;
}
</pre></div>
</div>
<p>would be formatted as such:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>// When the unit attribute is present:
foo.op is_read_only

// When the unit attribute is not present:
foo.op
</pre></div>
</div>
</section>
<section id="optional-else-group">
<h5>Optional “else” Group<a class="headerlink" href="#optional-else-group" title="此标题的永久链接">¶</a></h5>
<p>Optional groups also have support for an “else” group of elements. These are
elements that are parsed/printed if the <code class="docutils literal notranslate"><span class="pre">anchor</span></code> element of the optional group
is <em>not</em> present. Unlike the main element group, the “else” group has no
restriction on the first element and none of the elements may act as the
<code class="docutils literal notranslate"><span class="pre">anchor</span></code> for the optional. An example is shown below:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def FooOp : ... {
  let arguments = (ins UnitAttr:$foo);

  let assemblyFormat = &quot;attr-dict (`foo_is_present` $foo^):(`foo_is_absent`)?&quot;;
}
</pre></div>
</div>
<p>would be formatted as such:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>// When the `foo` attribute is present:
foo.op foo_is_present

// When the `foo` attribute is not present:
foo.op foo_is_absent
</pre></div>
</div>
</section>
</section>
<section id="requirements">
<h4>Requirements<a class="headerlink" href="#requirements" title="此标题的永久链接">¶</a></h4>
<p>The format specification has a certain set of requirements that must be adhered
to:</p>
<ol class="simple">
<li><p>The output and operation name are never shown as they are fixed and cannot
be altered.</p></li>
<li><p>All operands within the operation must appear within the format, either
individually or with the <code class="docutils literal notranslate"><span class="pre">operands</span></code> directive.</p></li>
<li><p>All regions within the operation must appear within the format, either
individually or with the <code class="docutils literal notranslate"><span class="pre">regions</span></code> directive.</p></li>
<li><p>All successors within the operation must appear within the format, either
individually or with the <code class="docutils literal notranslate"><span class="pre">successors</span></code> directive.</p></li>
<li><p>All operand and result types must appear within the format using the various
<code class="docutils literal notranslate"><span class="pre">type</span></code> directives, either individually or with the <code class="docutils literal notranslate"><span class="pre">operands</span></code> or <code class="docutils literal notranslate"><span class="pre">results</span></code>
directives.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">attr-dict</span></code> directive must always be present.</p></li>
<li><p>Must not contain overlapping information; e.g. multiple instances of
‘attr-dict’, types, operands, etc.</p>
<ul class="simple">
<li><p>Note that <code class="docutils literal notranslate"><span class="pre">attr-dict</span></code> does not overlap with individual attributes. These
attributes will simply be elided when printing the attribute dictionary.</p></li>
</ul>
</li>
</ol>
<section id="type-inference">
<h5>Type Inference<a class="headerlink" href="#type-inference" title="此标题的永久链接">¶</a></h5>
<p>One requirement of the format is that the types of operands and results must
always be present. In certain instances, the type of a variable may be deduced
via type constraints or other information available. In these cases, the type of
that variable may be elided from the format.</p>
<ul class="simple">
<li><p>Buildable Types</p></li>
</ul>
<p>Some type constraints may only have one representation, allowing for them to be
directly buildable; for example the <code class="docutils literal notranslate"><span class="pre">I32</span></code> or <code class="docutils literal notranslate"><span class="pre">Index</span></code> types. Types in <code class="docutils literal notranslate"><span class="pre">ODS</span></code> may
mark themselves as buildable by setting the <code class="docutils literal notranslate"><span class="pre">builderCall</span></code> field or inheriting
from the <code class="docutils literal notranslate"><span class="pre">BuildableType</span></code> class.</p>
<ul class="simple">
<li><p>Trait Equality Constraints</p></li>
</ul>
<p>There are many operations that have known type equality constraints registered
as traits on the operation; for example the true, false, and result values of a
<code class="docutils literal notranslate"><span class="pre">select</span></code> operation often have the same type. The assembly format may inspect
these equal constraints to discern the types of missing variables. The currently
supported traits are: <code class="docutils literal notranslate"><span class="pre">AllTypesMatch</span></code>, <code class="docutils literal notranslate"><span class="pre">TypesMatchWith</span></code>, <code class="docutils literal notranslate"><span class="pre">SameTypeOperands</span></code>, and
<code class="docutils literal notranslate"><span class="pre">SameOperandsAndResultType</span></code>.</p>
<ul class="simple">
<li><p>InferTypeOpInterface</p></li>
</ul>
<p>Operations that implement <code class="docutils literal notranslate"><span class="pre">InferTypeOpInterface</span></code> can omit their result types in
their assembly format since the result types can be inferred from the operands.</p>
</section>
</section>
</section>
<section id="hascanonicalizer">
<h3><code class="docutils literal notranslate"><span class="pre">hasCanonicalizer</span></code><a class="headerlink" href="#hascanonicalizer" title="此标题的永久链接">¶</a></h3>
<p>This boolean field indicate whether canonicalization patterns have been defined
for this operation. If it is <code class="docutils literal notranslate"><span class="pre">1</span></code>, then <code class="docutils literal notranslate"><span class="pre">::getCanonicalizationPatterns()</span></code> should
be defined.</p>
</section>
<section id="hascanonicalizemethod">
<h3><code class="docutils literal notranslate"><span class="pre">hasCanonicalizeMethod</span></code><a class="headerlink" href="#hascanonicalizemethod" title="此标题的永久链接">¶</a></h3>
<p>When this boolean field is set to <code class="docutils literal notranslate"><span class="pre">true</span></code>, it indicates that the op implements a
<code class="docutils literal notranslate"><span class="pre">canonicalize</span></code> method for simple “matchAndRewrite” style canonicalization
patterns. If <code class="docutils literal notranslate"><span class="pre">hasCanonicalizer</span></code> is 0, then an implementation of
<code class="docutils literal notranslate"><span class="pre">::getCanonicalizationPatterns()</span></code> is implemented to call this function.</p>
</section>
<section id="hasfolder">
<h3><code class="docutils literal notranslate"><span class="pre">hasFolder</span></code><a class="headerlink" href="#hasfolder" title="此标题的永久链接">¶</a></h3>
<p>This boolean field indicate whether general folding rules have been defined for
this operation. If it is <code class="docutils literal notranslate"><span class="pre">1</span></code>, then <code class="docutils literal notranslate"><span class="pre">::fold()</span></code> should be defined.</p>
</section>
<section id="extra-declarations">
<h3>Extra declarations<a class="headerlink" href="#extra-declarations" title="此标题的永久链接">¶</a></h3>
<p>One of the goals of table-driven op definition is to auto-generate as much logic
and methods needed for each op as possible. With that said, there will always be
long-tail cases that won’t be covered. For such cases, you can use
<code class="docutils literal notranslate"><span class="pre">extraClassDeclaration</span></code>. Code in <code class="docutils literal notranslate"><span class="pre">extraClassDeclaration</span></code> will be copied
literally to the generated C++ op class.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">extraClassDeclaration</span></code> is a mechanism intended for long-tail cases by
power users; for not-yet-implemented widely-applicable cases, improving the
infrastructure is preferable.</p>
</section>
<section id="extra-definitions">
<h3>Extra definitions<a class="headerlink" href="#extra-definitions" title="此标题的永久链接">¶</a></h3>
<p>When defining base op classes in TableGen that are inherited many times by
different ops, users may want to provide common definitions of utility and
interface functions. However, many of these definitions may not be desirable or
possible in <code class="docutils literal notranslate"><span class="pre">extraClassDeclaration</span></code>, which append them to the op’s C++ class
declaration. In these cases, users can add an <code class="docutils literal notranslate"><span class="pre">extraClassDefinition</span></code> to define
code that is added to the generated source file inside the op’s C++ namespace.
The substitution <code class="docutils literal notranslate"><span class="pre">$cppClass</span></code> is replaced by the op’s C++ class name.</p>
</section>
<section id="generated-c-code">
<h3>Generated C++ code<a class="headerlink" href="#generated-c-code" title="此标题的永久链接">¶</a></h3>
<p><a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/mlir/tools/mlir-tblgen/OpDefinitionsGen.cpp">OpDefinitionsGen</a> processes the op definition spec file and
generates two files containing the corresponding C++ code: one for declarations,
the other for definitions. The former is generated via the <code class="docutils literal notranslate"><span class="pre">-gen-op-decls</span></code>
command-line option, while the latter is via the <code class="docutils literal notranslate"><span class="pre">-gen-op-defs</span></code> option.</p>
<p>The definition file contains all the op method definitions, which can be
included and enabled by defining <code class="docutils literal notranslate"><span class="pre">GET_OP_CLASSES</span></code>. For each operation,
OpDefinitionsGen generates an operation class and an
<a class="reference external" href="#operand-adaptors">operand adaptor</a> class. Besides, it also contains a
comma-separated list of all defined ops, which can be included and enabled by
defining <code class="docutils literal notranslate"><span class="pre">GET_OP_LIST</span></code>.</p>
<section id="class-name-and-namespaces">
<h4>Class name and namespaces<a class="headerlink" href="#class-name-and-namespaces" title="此标题的永久链接">¶</a></h4>
<p>For each operation, its generated C++ class name is the symbol <code class="docutils literal notranslate"><span class="pre">def</span></code>ed with
TableGen with dialect prefix removed. The first <code class="docutils literal notranslate"><span class="pre">_</span></code> serves as the delimiter. For
example, for <code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">TF_AddOp</span></code>, the C++ class name would be <code class="docutils literal notranslate"><span class="pre">AddOp</span></code>. We remove the
<code class="docutils literal notranslate"><span class="pre">TF</span></code> prefix because it is for scoping ops; other dialects may as well define
their own <code class="docutils literal notranslate"><span class="pre">AddOp</span></code>s.</p>
<p>The namespaces of the generated C++ class will come from the dialect’s
<code class="docutils literal notranslate"><span class="pre">cppNamespace</span></code> field. For example, if a dialect’s <code class="docutils literal notranslate"><span class="pre">cppNamespace</span></code> is <code class="docutils literal notranslate"><span class="pre">A::B</span></code>, then
an op of that dialect will be placed in <code class="docutils literal notranslate"><span class="pre">namespace</span> <span class="pre">A</span> <span class="pre">{</span> <span class="pre">namespace</span> <span class="pre">B</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span> <span class="pre">}</span></code>.
If a dialect does not specify a <code class="docutils literal notranslate"><span class="pre">cppNamespace</span></code>, we then use the dialect’s name
as the namespace.</p>
<p>This means the qualified name of the generated C++ class does not necessarily
match exactly with the operation name as explained in
<a class="reference external" href="#operation-name">Operation name</a>. This is to allow flexible naming to satisfy
coding style requirements.</p>
</section>
<section id="operand-adaptors">
<h4>Operand adaptors<a class="headerlink" href="#operand-adaptors" title="此标题的永久链接">¶</a></h4>
<p>For each operation, we automatically generate an <em>operand adaptor</em>. This class
solves the problem of accessing operands provided as a list of <code class="docutils literal notranslate"><span class="pre">Value</span></code>s without
using “magic” constants. The operand adaptor takes a reference to an array of
<code class="docutils literal notranslate"><span class="pre">Value</span></code> and provides methods with the same names as those in the operation class
to access them. For example, for a binary arithmetic operation, it may provide
<code class="docutils literal notranslate"><span class="pre">.lhs()</span></code> to access the first operand and <code class="docutils literal notranslate"><span class="pre">.rhs()</span></code> to access the second operand.</p>
<p>The operand adaptor class lives in the same namespace as the operation class,
and has the name of the operation followed by <code class="docutils literal notranslate"><span class="pre">Adaptor</span></code> as well as an alias
<code class="docutils literal notranslate"><span class="pre">Adaptor</span></code> inside the op class.</p>
<p>Operand adaptors can be used in function templates that also process operations:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">BinaryOpTy</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Value</span><span class="p">,</span><span class="w"> </span><span class="n">Value</span><span class="o">&gt;</span><span class="w"> </span><span class="n">zip</span><span class="p">(</span><span class="n">BinaryOpTy</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="n">op</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="n">lhs</span><span class="p">(),</span><span class="w"> </span><span class="n">op</span><span class="p">.</span><span class="n">rhs</span><span class="p">());;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">process</span><span class="p">(</span><span class="n">AddOp</span><span class="w"> </span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">Value</span><span class="o">&gt;</span><span class="w"> </span><span class="n">newOperands</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">zip</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
<span class="w">  </span><span class="n">zip</span><span class="p">(</span><span class="n">Adaptor</span><span class="o">&lt;</span><span class="n">AddOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">newOperands</span><span class="p">));</span>
<span class="w">  </span><span class="cm">/*...*/</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="constraints">
<h2>Constraints<a class="headerlink" href="#constraints" title="此标题的永久链接">¶</a></h2>
<p>Constraint is a core concept in table-driven operation definition: operation
verification and graph operation matching are all based on satisfying
constraints. So both the operation definition and rewrite rules specification
significantly involve writing constraints. We have the <code class="docutils literal notranslate"><span class="pre">Constraint</span></code> class in
<a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/IR/OpBase.td"><code class="docutils literal notranslate"><span class="pre">OpBase.td</span></code></a> as the common base class for all constraints.</p>
<p>An operation’s constraint can cover different range; it may</p>
<ul class="simple">
<li><p>Only concern a single attribute (e.g. being a 32-bit integer greater than
5),</p></li>
<li><p>Multiple operands and results (e.g., the 1st result’s shape must be the same
as the 1st operand), or</p></li>
<li><p>Intrinsic to the operation itself (e.g., having no side effect).</p></li>
</ul>
<p>We call them as single-entity constraint, multi-entity constraint, and traits,
respectively.</p>
<section id="single-entity-constraint">
<h3>Single-entity constraint<a class="headerlink" href="#single-entity-constraint" title="此标题的永久链接">¶</a></h3>
<p>Constraints scoped to a single operand, attribute, or result are specified at
the entity’s declaration place as described in
<a class="reference external" href="#operation-arguments">Operation arguments</a> and
<a class="reference external" href="#operation-results">Operation results</a>.</p>
<p>To help modelling constraints of common types, a set of <code class="docutils literal notranslate"><span class="pre">TypeConstraint</span></code>s are
created; they are the <code class="docutils literal notranslate"><span class="pre">Type</span></code> subclass hierarchy. It includes <code class="docutils literal notranslate"><span class="pre">F32</span></code> for the
constraints of being a float, <code class="docutils literal notranslate"><span class="pre">TensorOf&lt;[F32]&gt;</span></code> for the constraints of being a
float tensor, and so on.</p>
<p>Similarly, a set of <code class="docutils literal notranslate"><span class="pre">AttrConstraint</span></code>s are created for helping modelling
constraints of common attribute kinds. They are the <code class="docutils literal notranslate"><span class="pre">Attr</span></code> subclass hierarchy.
It includes <code class="docutils literal notranslate"><span class="pre">F32Attr</span></code> for the constraints of being a float attribute,
<code class="docutils literal notranslate"><span class="pre">F32ArrayAttr</span></code> for the constraints of being a float array attribute, and so on.</p>
</section>
<section id="multi-entity-constraint">
<h3>Multi-entity constraint<a class="headerlink" href="#multi-entity-constraint" title="此标题的永久链接">¶</a></h3>
<p>Constraints involving more than one operand/attribute/result are quite common on
operations, like the element type and shape relation between operands and
results. These constraints should be specified as the <code class="docutils literal notranslate"><span class="pre">Op</span></code> class template
parameter as described in
<a class="reference external" href="#operation-traits-and-constraints">Operation traits and constraints</a>.</p>
<p>Multi-entity constraints are modeled as <code class="docutils literal notranslate"><span class="pre">PredOpTrait</span></code> (a subclass of <code class="docutils literal notranslate"><span class="pre">OpTrait</span></code>)
in <a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/IR/OpBase.td"><code class="docutils literal notranslate"><span class="pre">OpBase.td</span></code></a>.A bunch of constraint primitives are provided to help
specification. See <a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/IR/OpBase.td"><code class="docutils literal notranslate"><span class="pre">OpBase.td</span></code></a> for the complete list.</p>
</section>
<section id="trait">
<h3>Trait<a class="headerlink" href="#trait" title="此标题的永久链接">¶</a></h3>
<p>Traits are intrinsic properties of the operation like having side effect or not,
commutative or not, whether is a terminator, etc. These constraints should be
specified as the <code class="docutils literal notranslate"><span class="pre">Op</span></code> class template parameter as described in
<a class="reference external" href="#operation-traits-and-constraints">Operation traits and constraints</a>.</p>
<p>Traits are modeled as <code class="docutils literal notranslate"><span class="pre">NativeOpTrait</span></code> (a subclass of <code class="docutils literal notranslate"><span class="pre">OpTrait</span></code>) in
<a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/IR/OpBase.td"><code class="docutils literal notranslate"><span class="pre">OpBase.td</span></code></a>. They are backed and will be translated into the
corresponding C++ <code class="docutils literal notranslate"><span class="pre">mlir::OpTrait</span></code> classes.</p>
</section>
<section id="how-to-specify-new-constraint">
<h3>How to specify new constraint<a class="headerlink" href="#how-to-specify-new-constraint" title="此标题的永久链接">¶</a></h3>
<p>To write a constraint, you need to provide its predicates and give it a
descriptive name. Predicates, modeled with the <code class="docutils literal notranslate"><span class="pre">Pred</span></code> class, are the workhorse
for composing constraints. The predicate for a constraint is typically built up
in a nested manner, using the two categories of predicates:</p>
<ol class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">CPred</span></code>: the primitive leaf predicate.</p></li>
<li><p>Compound predicate: a predicate composed from child predicates using
predicate combiners (conjunction: <code class="docutils literal notranslate"><span class="pre">And</span></code>, disjunction: <code class="docutils literal notranslate"><span class="pre">Or</span></code>, negation: <code class="docutils literal notranslate"><span class="pre">Neg</span></code>,
substitution: <code class="docutils literal notranslate"><span class="pre">SubstLeaves</span></code>, concatenation: <code class="docutils literal notranslate"><span class="pre">Concat</span></code>).</p></li>
</ol>
<p><code class="docutils literal notranslate"><span class="pre">CPred</span></code> is the basis for composing more complex predicates. It is the “atom”
predicate from the perspective of TableGen and the “interface” between TableGen
and C++. What is inside is already C++ code, which will be treated as opaque
strings with special placeholders to be substituted.</p>
<p>You can put any C++ code that returns a boolean value inside a <code class="docutils literal notranslate"><span class="pre">CPred</span></code>,
including evaluating expressions, calling functions, calling class methods, and
so on.</p>
<p>To help interaction with the C++ environment, there are a few special
placeholders provided to refer to entities in the context where this predicate
is used. They serve as “hooks” to the enclosing environment. This includes
<code class="docutils literal notranslate"><span class="pre">$_builder</span></code>, <code class="docutils literal notranslate"><span class="pre">$_op</span></code>, and <code class="docutils literal notranslate"><span class="pre">$_self</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">$_builder</span></code> will be replaced by a <code class="docutils literal notranslate"><span class="pre">mlir::Builder</span></code> instance so that you can
access common build methods.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">$_op</span></code> will be replaced by the current operation so that you can access
information of the current operation.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">$_self</span></code> will be replaced with the entity this predicate is attached to.
E.g., <code class="docutils literal notranslate"><span class="pre">BoolAttr</span></code> is an attribute constraint that wraps a
<code class="docutils literal notranslate"><span class="pre">CPred&lt;&quot;$_self.isa&lt;BoolAttr&gt;()&quot;&gt;</span></code>. Then for <code class="docutils literal notranslate"><span class="pre">BoolAttr:$attr</span></code>,<code class="docutils literal notranslate"><span class="pre">$_self</span></code> will be
replaced by <code class="docutils literal notranslate"><span class="pre">$attr</span></code>. For type constraints, it’s a little bit special since
we want the constraints on each type definition reads naturally and we want
to attach type constraints directly to an operand/result, <code class="docutils literal notranslate"><span class="pre">$_self</span></code> will be
replaced by the operand/result’s type. E.g., for <code class="docutils literal notranslate"><span class="pre">F32</span></code> in <code class="docutils literal notranslate"><span class="pre">F32:$operand</span></code>,
its <code class="docutils literal notranslate"><span class="pre">$_self</span></code> will be expanded as <code class="docutils literal notranslate"><span class="pre">operand(...).getType()</span></code>.</p></li>
</ul>
<p>TODO: Reconsider the leading symbol for special placeholders. Eventually we want
to allow referencing operand/result <code class="docutils literal notranslate"><span class="pre">$-name</span></code>s; such <code class="docutils literal notranslate"><span class="pre">$-name</span></code>s can start with
underscore.</p>
<p>For example, to write an attribute <code class="docutils literal notranslate"><span class="pre">attr</span></code> is an <code class="docutils literal notranslate"><span class="pre">IntegerAttr</span></code>, in C++ you can
just call <code class="docutils literal notranslate"><span class="pre">attr.isa&lt;IntegerAttr&gt;()</span></code>. The code can be wrapped in a <code class="docutils literal notranslate"><span class="pre">CPred</span></code> as
<code class="docutils literal notranslate"><span class="pre">$_self.isa&lt;IntegerAttr&gt;()</span></code>, with <code class="docutils literal notranslate"><span class="pre">$_self</span></code> as the special placeholder to be
replaced by the current attribute <code class="docutils literal notranslate"><span class="pre">attr</span></code> at expansion time.</p>
<p>For more complicated predicates, you can wrap it in a single <code class="docutils literal notranslate"><span class="pre">CPred</span></code>, or you can
use predicate combiners to combine them. For example, to write the constraint
that an attribute <code class="docutils literal notranslate"><span class="pre">attr</span></code> is a 32-bit or 64-bit integer, you can write it as</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>And&lt;[
  CPred&lt;&quot;$_self.isa&lt;IntegerAttr&gt;()&quot;&gt;,
  Or&lt;[
    CPred&lt;&quot;$_self.cast&lt;IntegerAttr&gt;().getType().isInteger(32)&quot;&gt;,
    CPred&lt;&quot;$_self.cast&lt;IntegerAttr&gt;().getType().isInteger(64)&quot;&gt;
  ]&gt;
]&gt;
</pre></div>
</div>
<p>(Note that the above is just to show with a familiar example how you can use
<code class="docutils literal notranslate"><span class="pre">CPred</span></code> and predicate combiners to write complicated predicates. For integer
attributes specifically, <a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/IR/OpBase.td"><code class="docutils literal notranslate"><span class="pre">OpBase.td</span></code></a> already defines <code class="docutils literal notranslate"><span class="pre">I32Attr</span></code> and
<code class="docutils literal notranslate"><span class="pre">I64Attr</span></code>. So you can actually reuse them to write it as <code class="docutils literal notranslate"><span class="pre">Or&lt;[I32Attr.predicate,</span> <span class="pre">I64Attr.predicate]&gt;</span></code>.)</p>
<p>TODO: Build up a library of reusable primitive constraints</p>
<p>If the predicate is very complex to write with <code class="docutils literal notranslate"><span class="pre">CPred</span></code> together with predicate
combiners, you can also write it as a normal C++ function and use the <code class="docutils literal notranslate"><span class="pre">CPred</span></code> as
a way to “invoke” the function. For example, to verify an attribute <code class="docutils literal notranslate"><span class="pre">attr</span></code> has
some property, you can write a C++ function like</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span><span class="w"> </span><span class="nf">HasSomeProperty</span><span class="p">(</span><span class="n">Attribute</span><span class="w"> </span><span class="n">attr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
<p>and then define the op as:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def HasSomeProperty : AttrConstraint&lt;CPred&lt;&quot;HasSomeProperty($_self)&quot;&gt;,
                                     &quot;has some property&quot;&gt;;

def MyOp : Op&lt;...&gt; {
  let arguments = (ins
    ...
    HasSomeProperty:$attr
  );
}
</pre></div>
</div>
<p>As to whether we should define the predicate using a single <code class="docutils literal notranslate"><span class="pre">CPred</span></code> wrapping the
whole expression, multiple <code class="docutils literal notranslate"><span class="pre">CPred</span></code>s with predicate combiners, or a single
<code class="docutils literal notranslate"><span class="pre">CPred</span></code> “invoking” a function, there are no clear-cut criteria. Defining using
<code class="docutils literal notranslate"><span class="pre">CPred</span></code> and predicate combiners is preferable since it exposes more information
(instead hiding all the logic behind a C++ function) into the op definition spec
so that it can potentially drive more auto-generation cases. But it will require
a nice library of common predicates as the building blocks to avoid the
duplication, which is being worked on right now.</p>
</section>
</section>
<section id="attribute-definition">
<h2>Attribute Definition<a class="headerlink" href="#attribute-definition" title="此标题的永久链接">¶</a></h2>
<p>An attribute is a compile-time known constant of an operation.</p>
<p>ODS provides attribute wrappers over C++ attribute classes. There are a few
common C++ <a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/IR/Attributes.h">attribute classes</a> defined in MLIR’s core IR library
and one is free to define dialect-specific attribute classes. ODS allows one to
use these attributes in TableGen to define operations, potentially with more
fine-grained constraints. For example, <code class="docutils literal notranslate"><span class="pre">StrAttr</span></code> directly maps to <code class="docutils literal notranslate"><span class="pre">StringAttr</span></code>;
<code class="docutils literal notranslate"><span class="pre">F32Attr</span></code>/<code class="docutils literal notranslate"><span class="pre">F64Attr</span></code> requires the <code class="docutils literal notranslate"><span class="pre">FloatAttr</span></code> to additionally be of a certain
bitwidth.</p>
<p>ODS attributes are defined as having a storage type (corresponding to a backing
<code class="docutils literal notranslate"><span class="pre">mlir::Attribute</span></code> that <em>stores</em> the attribute), a return type (corresponding to
the C++ <em>return</em> type of the generated helper getters) as well as a method
to convert between the internal storage and the helper method.</p>
<section id="attribute-decorators">
<h3>Attribute decorators<a class="headerlink" href="#attribute-decorators" title="此标题的永久链接">¶</a></h3>
<p>There are a few important attribute adapters/decorators/modifiers that can be
applied to ODS attributes to specify common additional properties like
optionality, default values, etc.:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DefaultValuedAttr</span></code>: specifies the
<a class="reference external" href="#attributes-with-default-values">default value</a> for an attribute.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">OptionalAttr</span></code>: specifies an attribute as <a class="reference external" href="#optional-attributes">optional</a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ConfinedAttr</span></code>: adapts an attribute with
<a class="reference external" href="#confining-attributes">further constraints</a>.</p></li>
</ul>
</section>
<section id="enum-attributes">
<h3>Enum attributes<a class="headerlink" href="#enum-attributes" title="此标题的永久链接">¶</a></h3>
<p>Some attributes can only take values from a predefined enum, e.g., the
comparison kind of a comparison op. To define such attributes, ODS provides
several mechanisms: <code class="docutils literal notranslate"><span class="pre">IntEnumAttr</span></code>, and <code class="docutils literal notranslate"><span class="pre">BitEnumAttr</span></code>.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">IntEnumAttr</span></code>: each enum case is an integer, the attribute is stored as a
<a class="reference external" href="../Dialects/Builtin.md/#integertype"><code class="docutils literal notranslate"><span class="pre">IntegerAttr</span></code></a> in the op.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">BitEnumAttr</span></code>: each enum case is a either the empty case, a single bit,
or a group of single bits, and the attribute is stored as a
<a class="reference external" href="../Dialects/Builtin.md/#integertype"><code class="docutils literal notranslate"><span class="pre">IntegerAttr</span></code></a> in the op.</p></li>
</ul>
<p>All these <code class="docutils literal notranslate"><span class="pre">*EnumAttr</span></code> attributes require fully specifying all of the allowed
cases via their corresponding <code class="docutils literal notranslate"><span class="pre">*EnumAttrCase</span></code>. With this, ODS is able to
generate additional verification to only accept allowed cases. To facilitate the
interaction between <code class="docutils literal notranslate"><span class="pre">*EnumAttr</span></code>s and their C++ consumers, the
<a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/mlir/tools/mlir-tblgen/EnumsGen.cpp"><code class="docutils literal notranslate"><span class="pre">EnumsGen</span></code></a> TableGen backend can generate a few common utilities: a
C++ enum class, <code class="docutils literal notranslate"><span class="pre">llvm::DenseMapInfo</span></code> for the enum class, conversion functions
from/to strings. This is controlled via the <code class="docutils literal notranslate"><span class="pre">-gen-enum-decls</span></code> and
<code class="docutils literal notranslate"><span class="pre">-gen-enum-defs</span></code> command-line options of <code class="docutils literal notranslate"><span class="pre">mlir-tblgen</span></code>.</p>
<p>For example, given the following <code class="docutils literal notranslate"><span class="pre">EnumAttr</span></code>:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def Case15: I32EnumAttrCase&lt;&quot;Case15&quot;, 15&gt;;
def Case20: I32EnumAttrCase&lt;&quot;Case20&quot;, 20&gt;;

def MyIntEnum: I32EnumAttr&lt;&quot;MyIntEnum&quot;, &quot;An example int enum&quot;,
                           [Case15, Case20]&gt; {
  let cppNamespace = &quot;Outer::Inner&quot;;
  let stringToSymbolFnName = &quot;ConvertToEnum&quot;;
  let symbolToStringFnName = &quot;ConvertToString&quot;;
}
</pre></div>
</div>
<p>The following will be generated via <code class="docutils literal notranslate"><span class="pre">mlir-tblgen</span> <span class="pre">-gen-enum-decls</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">Outer</span><span class="w"> </span><span class="p">{</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">Inner</span><span class="w"> </span><span class="p">{</span>
<span class="c1">// An example int enum</span>
<span class="k">enum</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">MyIntEnum</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Case15</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">15</span><span class="p">,</span>
<span class="w">  </span><span class="n">Case20</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">MyIntEnum</span><span class="o">&gt;</span><span class="w"> </span><span class="n">symbolizeMyIntEnum</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
<span class="n">llvm</span><span class="o">::</span><span class="n">StringRef</span><span class="w"> </span><span class="nf">ConvertToString</span><span class="p">(</span><span class="n">MyIntEnum</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">MyIntEnum</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ConvertToEnum</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">StringRef</span><span class="p">);</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="nf">getMaxEnumValForMyIntEnum</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// namespace Inner</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// namespace Outer</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">llvm</span><span class="w"> </span><span class="p">{</span>
<span class="k">template</span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">DenseMapInfo</span><span class="o">&lt;</span><span class="n">Outer</span><span class="o">::</span><span class="n">Inner</span><span class="o">::</span><span class="n">MyIntEnum</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">StorageInfo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">DenseMapInfo</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="n">Outer</span><span class="o">::</span><span class="n">Inner</span><span class="o">::</span><span class="n">MyIntEnum</span><span class="w"> </span><span class="nf">getEmptyKey</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Outer</span><span class="o">::</span><span class="n">Inner</span><span class="o">::</span><span class="n">MyIntEnum</span><span class="o">&gt;</span><span class="p">(</span><span class="n">StorageInfo</span><span class="o">::</span><span class="n">getEmptyKey</span><span class="p">());</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="n">Outer</span><span class="o">::</span><span class="n">Inner</span><span class="o">::</span><span class="n">MyIntEnum</span><span class="w"> </span><span class="nf">getTombstoneKey</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Outer</span><span class="o">::</span><span class="n">Inner</span><span class="o">::</span><span class="n">MyIntEnum</span><span class="o">&gt;</span><span class="p">(</span><span class="n">StorageInfo</span><span class="o">::</span><span class="n">getTombstoneKey</span><span class="p">());</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="nf">getHashValue</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Outer</span><span class="o">::</span><span class="n">Inner</span><span class="o">::</span><span class="n">MyIntEnum</span><span class="w"> </span><span class="o">&amp;</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">StorageInfo</span><span class="o">::</span><span class="n">getHashValue</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">isEqual</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Outer</span><span class="o">::</span><span class="n">Inner</span><span class="o">::</span><span class="n">MyIntEnum</span><span class="w"> </span><span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Outer</span><span class="o">::</span><span class="n">Inner</span><span class="o">::</span><span class="n">MyIntEnum</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">lhs</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">rhs</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The following will be generated via <code class="docutils literal notranslate"><span class="pre">mlir-tblgen</span> <span class="pre">-gen-enum-defs</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span><span class="w"> </span><span class="nn">Outer</span><span class="w"> </span><span class="p">{</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">Inner</span><span class="w"> </span><span class="p">{</span>
<span class="n">llvm</span><span class="o">::</span><span class="n">StringRef</span><span class="w"> </span><span class="nf">ConvertToString</span><span class="p">(</span><span class="n">MyIntEnum</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">MyIntEnum</span><span class="o">::</span><span class="no">Case15</span><span class="p">:</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;Case15&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">MyIntEnum</span><span class="o">::</span><span class="no">Case20</span><span class="p">:</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;Case20&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">MyIntEnum</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ConvertToEnum</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">StringRef</span><span class="w"> </span><span class="n">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">StringSwitch</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">MyIntEnum</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>
<span class="w">      </span><span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;Case15&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">MyIntEnum</span><span class="o">::</span><span class="n">Case15</span><span class="p">)</span>
<span class="w">      </span><span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;Case20&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">MyIntEnum</span><span class="o">::</span><span class="n">Case20</span><span class="p">)</span>
<span class="w">      </span><span class="p">.</span><span class="n">Default</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">MyIntEnum</span><span class="o">&gt;</span><span class="w"> </span><span class="n">symbolizeMyIntEnum</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">15</span><span class="p">:</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">MyIntEnum</span><span class="o">::</span><span class="n">Case15</span><span class="p">;</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">20</span><span class="p">:</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">MyIntEnum</span><span class="o">::</span><span class="n">Case20</span><span class="p">;</span>
<span class="w">  </span><span class="k">default</span><span class="o">:</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="p">}</span><span class="w"> </span><span class="c1">// namespace Inner</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// namespace Outer</span>
</pre></div>
</div>
<p>Similarly for the following <code class="docutils literal notranslate"><span class="pre">BitEnumAttr</span></code> definition:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def None: I32BitEnumAttrCaseNone&lt;&quot;None&quot;&gt;;
def Bit0: I32BitEnumAttrCaseBit&lt;&quot;Bit0&quot;, 0, &quot;tagged&quot;&gt;;
def Bit1: I32BitEnumAttrCaseBit&lt;&quot;Bit1&quot;, 1&gt;;
def Bit2: I32BitEnumAttrCaseBit&lt;&quot;Bit2&quot;, 2&gt;;
def Bit3: I32BitEnumAttrCaseBit&lt;&quot;Bit3&quot;, 3&gt;;

def MyBitEnum: BitEnumAttr&lt;&quot;MyBitEnum&quot;, &quot;An example bit enum&quot;,
                           [None, Bit0, Bit1, Bit2, Bit3]&gt;;
</pre></div>
</div>
<p>We can have:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// An example bit enum</span>
<span class="k">enum</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">MyBitEnum</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">None</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">  </span><span class="n">Bit0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">  </span><span class="n">Bit1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">  </span><span class="n">Bit2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span>
<span class="w">  </span><span class="n">Bit3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">MyBitEnum</span><span class="o">&gt;</span><span class="w"> </span><span class="n">symbolizeMyBitEnum</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">stringifyMyBitEnum</span><span class="p">(</span><span class="n">MyBitEnum</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">MyBitEnum</span><span class="o">&gt;</span><span class="w"> </span><span class="n">symbolizeMyBitEnum</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">StringRef</span><span class="p">);</span>

<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">MyBitEnum</span><span class="w"> </span><span class="k">operator</span><span class="o">|</span><span class="p">(</span><span class="n">MyBitEnum</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">MyBitEnum</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">MyBitEnum</span><span class="o">&gt;</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>
<span class="p">}</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">MyBitEnum</span><span class="w"> </span><span class="k">operator</span><span class="o">&amp;</span><span class="p">(</span><span class="n">MyBitEnum</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">MyBitEnum</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">MyBitEnum</span><span class="o">&gt;</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>
<span class="p">}</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">MyBitEnum</span><span class="w"> </span><span class="k">operator</span><span class="o">^</span><span class="p">(</span><span class="n">MyBitEnum</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">MyBitEnum</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">MyBitEnum</span><span class="o">&gt;</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>
<span class="p">}</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">MyBitEnum</span><span class="w"> </span><span class="k">operator</span><span class="o">~</span><span class="p">(</span><span class="n">MyBitEnum</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Ensure only bits that can be present in the enum are set</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">MyBitEnum</span><span class="o">&gt;</span><span class="p">(</span><span class="o">~</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">bits</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">15u</span><span class="p">));</span>
<span class="p">}</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">bitEnumContainsAll</span><span class="p">(</span><span class="n">MyBitEnum</span><span class="w"> </span><span class="n">bits</span><span class="p">,</span><span class="w"> </span><span class="n">MyBitEnum</span><span class="w"> </span><span class="n">bit</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">bits</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">bit</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">bit</span><span class="p">;</span>
<span class="p">}</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">bitEnumContainsAny</span><span class="p">(</span><span class="n">MyBitEnum</span><span class="w"> </span><span class="n">bits</span><span class="p">,</span><span class="w"> </span><span class="n">MyBitEnum</span><span class="w"> </span><span class="n">bit</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">bits</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">bit</span><span class="p">))</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="kr">inline</span><span class="w"> </span><span class="k">constexpr</span><span class="w"> </span><span class="n">MyBitEnum</span><span class="w"> </span><span class="n">bitEnumClear</span><span class="p">(</span><span class="n">MyBitEnum</span><span class="w"> </span><span class="n">bits</span><span class="p">,</span><span class="w"> </span><span class="n">MyBitEnum</span><span class="w"> </span><span class="n">bit</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">bits</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="n">bit</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">stringifyEnum</span><span class="p">(</span><span class="n">MyBitEnum</span><span class="w"> </span><span class="n">enumValue</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">stringifyMyBitEnum</span><span class="p">(</span><span class="n">enumValue</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">EnumType</span><span class="o">&gt;</span>
<span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">EnumType</span><span class="o">&gt;</span><span class="w"> </span><span class="n">symbolizeEnum</span><span class="p">(</span><span class="o">::</span><span class="n">llvm</span><span class="o">::</span><span class="n">StringRef</span><span class="p">);</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="o">::</span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">MyBitEnum</span><span class="o">&gt;</span><span class="w"> </span><span class="n">symbolizeEnum</span><span class="o">&lt;</span><span class="n">MyBitEnum</span><span class="o">&gt;</span><span class="p">(</span><span class="o">::</span><span class="n">llvm</span><span class="o">::</span><span class="n">StringRef</span><span class="w"> </span><span class="n">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">symbolizeMyBitEnum</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">llvm</span><span class="w"> </span><span class="p">{</span>
<span class="k">template</span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">DenseMapInfo</span><span class="o">&lt;::</span><span class="n">MyBitEnum</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">StorageInfo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">DenseMapInfo</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="o">::</span><span class="n">MyBitEnum</span><span class="w"> </span><span class="nf">getEmptyKey</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;::</span><span class="n">MyBitEnum</span><span class="o">&gt;</span><span class="p">(</span><span class="n">StorageInfo</span><span class="o">::</span><span class="n">getEmptyKey</span><span class="p">());</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="o">::</span><span class="n">MyBitEnum</span><span class="w"> </span><span class="nf">getTombstoneKey</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;::</span><span class="n">MyBitEnum</span><span class="o">&gt;</span><span class="p">(</span><span class="n">StorageInfo</span><span class="o">::</span><span class="n">getTombstoneKey</span><span class="p">());</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="nf">getHashValue</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="o">::</span><span class="n">MyBitEnum</span><span class="w"> </span><span class="o">&amp;</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">StorageInfo</span><span class="o">::</span><span class="n">getHashValue</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">isEqual</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="o">::</span><span class="n">MyBitEnum</span><span class="w"> </span><span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">::</span><span class="n">MyBitEnum</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">lhs</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">rhs</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">stringifyMyBitEnum</span><span class="p">(</span><span class="n">MyBitEnum</span><span class="w"> </span><span class="n">symbol</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">symbol</span><span class="p">);</span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="mi">15u</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="mi">15u</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="s">&quot;invalid bits set in bit enum&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// Special case for all bits unset.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">val</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;None&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="n">llvm</span><span class="o">::</span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">StringRef</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">strs</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">1u</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="mi">1u</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">val</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">strs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">&quot;tagged&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">2u</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="mi">2u</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">val</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">strs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">&quot;Bit1&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">4u</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="mi">4u</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">val</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">strs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">&quot;Bit2&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="mi">8u</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="mi">8u</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">val</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">strs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">&quot;Bit3&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">join</span><span class="p">(</span><span class="n">strs</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;|&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">MyBitEnum</span><span class="o">&gt;</span><span class="w"> </span><span class="n">symbolizeMyBitEnum</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">StringRef</span><span class="w"> </span><span class="n">str</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Special case for all bits unset.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">str</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;None&quot;</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">MyBitEnum</span><span class="o">::</span><span class="n">None</span><span class="p">;</span>

<span class="w">  </span><span class="n">llvm</span><span class="o">::</span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">StringRef</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">symbols</span><span class="p">;</span>
<span class="w">  </span><span class="n">str</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="n">symbols</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;|&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">symbol</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">symbols</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">bit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">StringSwitch</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
<span class="w">      </span><span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;tagged&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">      </span><span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;Bit1&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">      </span><span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;Bit2&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span>
<span class="w">      </span><span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;Bit3&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">)</span>
<span class="w">      </span><span class="p">.</span><span class="n">Default</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">bit</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="o">*</span><span class="n">bit</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">MyBitEnum</span><span class="o">&gt;</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">MyBitEnum</span><span class="o">&gt;</span><span class="w"> </span><span class="n">symbolizeMyBitEnum</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Special case for all bits unset.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">MyBitEnum</span><span class="o">::</span><span class="n">None</span><span class="p">;</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">15u</span><span class="p">))</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">MyBitEnum</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="debugging-tips">
<h2>Debugging Tips<a class="headerlink" href="#debugging-tips" title="此标题的永久链接">¶</a></h2>
<section id="run-mlir-tblgen-to-see-the-generated-content">
<h3>Run <code class="docutils literal notranslate"><span class="pre">mlir-tblgen</span></code> to see the generated content<a class="headerlink" href="#run-mlir-tblgen-to-see-the-generated-content" title="此标题的永久链接">¶</a></h3>
<p>TableGen syntax sometimes can be obscure; reading the generated content can be a
very helpful way to understand and debug issues. To build <code class="docutils literal notranslate"><span class="pre">mlir-tblgen</span></code>, run
<code class="docutils literal notranslate"><span class="pre">cmake</span> <span class="pre">--build</span> <span class="pre">.</span> <span class="pre">--target</span> <span class="pre">mlir-tblgen</span></code> in your build directory and find the
<code class="docutils literal notranslate"><span class="pre">mlir-tblgen</span></code> binary in the <code class="docutils literal notranslate"><span class="pre">bin/</span></code> subdirectory. All the supported generators
can be found via <code class="docutils literal notranslate"><span class="pre">mlir-tblgen</span> <span class="pre">--help</span></code>. For example, <code class="docutils literal notranslate"><span class="pre">--gen-op-decls</span></code> and
<code class="docutils literal notranslate"><span class="pre">--gen-op-defs</span></code> as explained in <a class="reference external" href="#generated-c-code">Generated C++ code</a>.</p>
<p>To see the generated code, invoke <code class="docutils literal notranslate"><span class="pre">mlir-tblgen</span></code> with a specific generator by
providing include paths via <code class="docutils literal notranslate"><span class="pre">-I</span></code>. For example,</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span><span class="c1"># To see op C++ class declaration</span>
mlir-tblgen<span class="w"> </span>--gen-op-decls<span class="w"> </span>-I<span class="w"> </span>/path/to/mlir/include<span class="w"> </span>/path/to/input/td/file
<span class="c1"># To see op C++ class definition</span>
mlir-tblgen<span class="w"> </span>--gen-op-defs<span class="w"> </span>-I<span class="w"> </span>/path/to/mlir/include<span class="w"> </span>/path/to/input/td/file
<span class="c1"># To see op documentation</span>
mlir-tblgen<span class="w"> </span>--gen-dialect-doc<span class="w"> </span>-I<span class="w"> </span>/path/to/mlir/include<span class="w"> </span>/path/to/input/td/file

<span class="c1"># To see op interface C++ class declaration</span>
mlir-tblgen<span class="w"> </span>--gen-op-interface-decls<span class="w"> </span>-I<span class="w"> </span>/path/to/mlir/include<span class="w"> </span>/path/to/input/td/file
<span class="c1"># To see op interface C++ class definition</span>
mlir-tblgen<span class="w"> </span>--gen-op-interface-defs<span class="w"> </span>-I<span class="w"> </span>/path/to/mlir/include<span class="w"> </span>/path/to/input/td/file
<span class="c1"># To see op interface documentation</span>
mlir-tblgen<span class="w"> </span>--gen-op-interface-doc<span class="w"> </span>-I<span class="w"> </span>/path/to/mlir/include<span class="w"> </span>/path/to/input/td/file
</pre></div>
</div>
</section>
</section>
<section id="appendix">
<h2>Appendix<a class="headerlink" href="#appendix" title="此标题的永久链接">¶</a></h2>
<section id="reporting-deprecation-in-tablegen">
<h3>Reporting deprecation in TableGen<a class="headerlink" href="#reporting-deprecation-in-tablegen" title="此标题的永久链接">¶</a></h3>
<p>Classes/defs can be marked as deprecated by using the <code class="docutils literal notranslate"><span class="pre">Deprecate</span></code> helper class,
e.g.,</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def OpTraitA : NativeOpTrait&lt;&quot;OpTraitA&quot;&gt;, Deprecated&lt;&quot;use `bar` instead&quot;&gt;;
</pre></div>
</div>
<p>would result in marking <code class="docutils literal notranslate"><span class="pre">OpTraitA</span></code> as deprecated and mlir-tblgen can emit a
warning (default) or error (depending on <code class="docutils literal notranslate"><span class="pre">-on-deprecated</span></code> flag) to make
deprecated state known.</p>
</section>
<section id="reporting-deprecation-in-c">
<h3>Reporting deprecation in C++<a class="headerlink" href="#reporting-deprecation-in-c" title="此标题的永久链接">¶</a></h3>
<p>TableGen generated C++ entities, such as classes, functions or methods, can be
marked as deprecated using the <code class="docutils literal notranslate"><span class="pre">CppDeprecated</span></code> mixin:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def MyOp : Op&lt;MyDialect, &quot;my.op&quot;&gt;, CppDeprecated&lt;&quot;use &#39;your.op&#39; instead&quot;&gt;;
</pre></div>
</div>
<p>This differs to the deprecation mechanic for TableGen, in that no warning is
emitted by mlir-tblgen. Rather, a warning with the given reason is emitted by
the C++ compiler on use of the given entity.</p>
<p>To allow more convenient syntax, helper classes exist for TableGen classes
which are commonly used as anonymous definitions. These currently include:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">DeprecatedOpBuilder</span></code>: Can be used in place of <code class="docutils literal notranslate"><span class="pre">OpBuilder</span></code> with the same
arguments except taking the reason as first argument, e.g.
<code class="docutils literal notranslate"><span class="pre">DeprecatedOpBuilder&lt;&quot;use</span> <span class="pre">'build'</span> <span class="pre">with</span> <span class="pre">foo</span> <span class="pre">instead&quot;,</span> <span class="pre">(ins</span> <span class="pre">&quot;int&quot;:$bar)&gt;</span></code></p></li>
</ul>
<p>Note: Support for the <code class="docutils literal notranslate"><span class="pre">CppDeprecated</span></code> mechanism has to be implemented by
every code generator separately.</p>
</section>
<section id="requirements-and-existing-mechanisms-analysis">
<h3>Requirements and existing mechanisms analysis<a class="headerlink" href="#requirements-and-existing-mechanisms-analysis" title="此标题的永久链接">¶</a></h3>
<p>The op description should be as declarative as possible to allow a wide range of
tools to work with them and query methods generated from them. In particular
this means specifying traits, constraints and shape inference information in a
way that is easily analyzable (e.g., avoid opaque calls to C++ functions where
possible).</p>
<p>We considered the approaches of several contemporary systems and focused on
requirements that were desirable:</p>
<ul>
<li><p>Ops registered using a registry separate from C++ code.</p>
<ul class="simple">
<li><p>Unknown ops are allowed in MLIR, so ops need not be registered. The
ability of the compiler to optimize those ops or graphs containing those
ops is constrained but correct.</p></li>
<li><p>The current proposal does not include a runtime op description, but it
does not preclude such description, it can be added later.</p></li>
<li><p>The op registry is essential for generating C++ classes that make
manipulating ops, verifying correct construction etc. in C++ easier by
providing a typed representation and accessors.</p></li>
</ul>
</li>
<li><p>The op registry will be defined in
<a class="reference external" href="https://llvm.org/docs/TableGen/index.html">TableGen</a> and be used to
generate C++ classes and utility functions
(builder/verifier/parser/printer).</p>
<ul class="simple">
<li><p>TableGen is a modelling specification language used by LLVM’s backends
and fits in well with trait-based modelling. This is an implementation
decision and there are alternative ways of doing this. But the
specification language is good for the requirements of modelling the
traits (as seen from usage in LLVM processor backend modelling) and easy
to extend, so a practical choice. If another good option comes up, we
will consider it.</p></li>
</ul>
</li>
<li><p>MLIR allows both defined and undefined ops.</p>
<ul class="simple">
<li><p>Defined ops should have fixed semantics and could have a corresponding
reference implementation defined.</p></li>
<li><p>Dialects are under full control of the dialect owner and normally live
with the framework of the dialect.</p></li>
</ul>
</li>
<li><p>The op’s traits (e.g., commutative) are modelled along with the op in the
registry.</p></li>
<li><p>The op’s operand/return type constraints are modelled along with the op in
the registry (see <a class="reference internal" href="../ShapeInference.html"><span class="doc">Shape inference</span></a> discussion below),
this allows (e.g.) optimized concise syntax in textual dumps.</p></li>
<li><p>Behavior of the op is documented along with the op with a summary and a
description. The description is written in markdown and extracted for
inclusion in the generated LangRef section of the dialect.</p></li>
<li><p>The generic assembly form of printing and parsing is available as normal,
but a custom parser and printer can either be specified or automatically
generated from an optional string representation showing the mapping of the
“assembly” string to operands/type.</p>
<ul class="simple">
<li><p>Parser-level remappings (e.g., <code class="docutils literal notranslate"><span class="pre">eq</span></code> to enum) will be supported as part
of the parser generation.</p></li>
</ul>
</li>
<li><p>Matching patterns are specified separately from the op description.</p>
<ul class="simple">
<li><p>Contrasted with LLVM there is no “base” set of ops that every backend
needs to be aware of. Instead there are many different dialects and the
transformations/legalizations between these dialects form a graph of
transformations.</p></li>
</ul>
</li>
<li><p>Reference implementation may be provided along with the op definition.</p>
<ul class="simple">
<li><p>The reference implementation may be in terms of either standard ops or
other reference implementations.</p></li>
</ul>
<p>TODO: document expectation if the dependent op’s definition changes.</p>
</li>
</ul>
</section>
</section>
</section>


          </div>
          <div class="page-nav">
            <div class="inner"><ul class="page-nav">
</ul><div class="footer" role="contentinfo">
      &#169; 版权所有 2023, yaoyue123.
    <br>
    Created using <a href="http://sphinx-doc.org/">Sphinx</a> 6.1.3 with <a href="https://github.com/schettino72/sphinx_press_theme">Press Theme</a> 0.8.0.
</div>
            </div>
          </div>
      </page>
    </div></div>
    
    
  </body>
</html>