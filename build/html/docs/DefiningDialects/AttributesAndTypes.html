<!DOCTYPE html>
<html  lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

      <title>Defining Dialect Attributes and Types</title>
    
          <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
          <link rel="stylesheet" href="../../_static/theme.css " type="text/css" />
      
      <!-- sphinx script_files -->
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
        <script src="../../_static/translations.js"></script>

      
      <!-- bundled in js (rollup iife) -->
      <!-- <script src="../../_static/theme-vendors.js"></script> -->
      <script src="../../_static/theme.js" defer></script>
    
  <link rel="index" title="索引" href="../../genindex.html" />
  <link rel="search" title="搜索" href="../../search.html" /> 
  </head>

  <body>
    <div id="app">
    <div class="theme-container" :class="pageClasses"><navbar @toggle-sidebar="toggleSidebar">
  <router-link to="../../index.html" class="home-link">
    
      <span class="site-name">MLIR 中文文档</span>
    
  </router-link>

  <div class="links">
    <navlinks class="can-hide">



    </navlinks>
  </div>
</navbar>

      
      <div class="sidebar-mask" @click="toggleSidebar(false)">
      </div>
        <sidebar @toggle-sidebar="toggleSidebar">
          
          <navlinks>
            



            
          </navlinks><div id="searchbox" class="searchbox" role="search">
  <div class="caption"><span class="caption-text">快速搜索</span>
    <div class="searchformwrapper">
      <form class="search" action="../../search.html" method="get">
        <input type="text" name="q" />
        <input type="submit" value="搜索" />
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div><div class="sidebar-links" role="navigation" aria-label="main navigation">
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../../index.html#mlir">欢迎使用 mlir 中文文档</a></span>
      </p>
      <ul class="">
        
          <li class="toctree-l1 ">
            
              <a href="../../_index.html" class="reference internal ">开始使用MLIR</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/CreatingADialect.html" class="reference internal ">Creating a Dialect</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/DataFlowAnalysis.html" class="reference internal ">Writing DataFlow Analyses in MLIR</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/QuickstartRewrites.html" class="reference internal ">Quickstart tutorial to adding MLIR graph rewrite</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/Toy/Ch-1.html" class="reference internal ">第1章：Toy语言和AST（抽象语法树）</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/Toy/Ch-2.html" class="reference internal ">Chapter 2: Emitting Basic MLIR</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/Toy/Ch-3.html" class="reference internal ">Chapter 3: High-level Language-Specific Analysis and Transformation</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/Toy/Ch-4.html" class="reference internal ">Chapter 4: Enabling Generic Transformation with Interfaces</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/Toy/Ch-5.html" class="reference internal ">Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/Toy/Ch-6.html" class="reference internal ">Chapter 6: Lowering to LLVM and CodeGeneration</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/Toy/Ch-7.html" class="reference internal ">Chapter 7: Adding a Composite Type to Toy</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/Toy/_index.html" class="reference internal ">Toy 入门教程</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/UnderstandingTheIRStructure.html" class="reference internal ">Understanding the IR Structure</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/_index.html" class="reference internal ">Tutorials</a>
            

            
          </li>

        
      </ul>
    </div>
  
</div>
        </sidebar>

      <page>
          <div class="body-header" role="navigation" aria-label="navigation">
  
  <ul class="breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
    
    <li>Defining Dialect Attributes and Types</li>
  </ul>
  

  <ul class="page-nav">
</ul>
  
</div>
<hr>
          <div class="content" role="main" v-pre>
            
  <section id="defining-dialect-attributes-and-types">
<h1>Defining Dialect Attributes and Types<a class="headerlink" href="#defining-dialect-attributes-and-types" title="此标题的永久链接">¶</a></h1>
<p>This document describes how to define dialect
<a class="reference external" href="../LangRef.md/#attributes">attributes</a> and <a class="reference external" href="../LangRef.md/#type-system">types</a>.</p>
<p>[TOC]</p>
<section id="langref-refresher">
<h2>LangRef Refresher<a class="headerlink" href="#langref-refresher" title="此标题的永久链接">¶</a></h2>
<p>Before diving into how to define these constructs, below is a quick refresher
from the <a class="reference internal" href="../LangRef.html"><span class="doc">MLIR LangRef</span></a>.</p>
<section id="attributes">
<h3>Attributes<a class="headerlink" href="#attributes" title="此标题的永久链接">¶</a></h3>
<p>Attributes are the mechanism for specifying constant data on operations in
places where a variable is never allowed - e.g. the comparison predicate of a
<a class="reference external" href="../Dialects/ArithOps.md#arithcmpi-mlirarithcmpiop"><code class="docutils literal notranslate"><span class="pre">arith.cmpi</span></code> operation</a>, or
the underlying value of a <a class="reference external" href="../Dialects/ArithOps.md#arithconstant-mlirarithconstantop"><code class="docutils literal notranslate"><span class="pre">arith.constant</span></code> operation</a>.
Each operation has an attribute dictionary, which associates a set of attribute
names to attribute values.</p>
</section>
<section id="types">
<h3>Types<a class="headerlink" href="#types" title="此标题的永久链接">¶</a></h3>
<p>Every SSA value, such as operation results or block arguments, in MLIR has a type
defined by the type system. MLIR has an open type system with no fixed list of types,
and there are no restrictions on the abstractions they represent. For example, take
the following <a class="reference external" href="../Dialects/ArithOps.md#arithaddi-mlirarithaddiop">Arithmetic AddI operation</a>:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>  %result = arith.addi %lhs, %rhs : i64
</pre></div>
</div>
<p>It takes two input SSA values (<code class="docutils literal notranslate"><span class="pre">%lhs</span></code> and <code class="docutils literal notranslate"><span class="pre">%rhs</span></code>), and returns a single SSA
value (<code class="docutils literal notranslate"><span class="pre">%result</span></code>). The inputs and outputs of this operation are of type <code class="docutils literal notranslate"><span class="pre">i64</span></code>,
which is an instance of the <a class="reference external" href="../Dialects/Builtin.md#integertype">Builtin IntegerType</a>.</p>
</section>
</section>
<section id="attributes-and-types">
<h2>Attributes and Types<a class="headerlink" href="#attributes-and-types" title="此标题的永久链接">¶</a></h2>
<p>The C++ Attribute and Type classes in MLIR (like Ops, and many other things) are
value-typed. This means that instances of <code class="docutils literal notranslate"><span class="pre">Attribute</span></code> or <code class="docutils literal notranslate"><span class="pre">Type</span></code> are passed
around by-value, as opposed to by-pointer or by-reference. The <code class="docutils literal notranslate"><span class="pre">Attribute</span></code> and
<code class="docutils literal notranslate"><span class="pre">Type</span></code> classes act as wrappers around internal storage objects that are uniqued
within an instance of an <code class="docutils literal notranslate"><span class="pre">MLIRContext</span></code>.</p>
<p>The structure for defining Attributes and Types is nearly identical, with only a
few differences depending on the context. As such, a majority of this document
describes the process for defining both Attributes and Types side-by-side with
examples for both. If necessary, a section will explicitly call out any
distinct differences.</p>
<section id="adding-a-new-attribute-or-type-definition">
<h3>Adding a new Attribute or Type definition<a class="headerlink" href="#adding-a-new-attribute-or-type-definition" title="此标题的永久链接">¶</a></h3>
<p>As described above, C++ Attribute and Type objects in MLIR are value-typed and
essentially function as helpful wrappers around an internal storage object that
holds the actual data for the type. Similarly to Operations, Attributes and Types
are defined declaratively via <a class="reference external" href="https://llvm.org/docs/TableGen/index.html">TableGen</a>;
a generic language with tooling to maintain records of domain-specific information.
It is highly recommended that users review the
<a class="reference external" href="https://llvm.org/docs/TableGen/ProgRef.html">TableGen Programmer’s Reference</a>
for an introduction to its syntax and constructs.</p>
<p>Starting the definition of a new attribute or type simply requires adding a
specialization for either the <code class="docutils literal notranslate"><span class="pre">AttrDef</span></code> or <code class="docutils literal notranslate"><span class="pre">TypeDef</span></code> class respectively. Instances
of the classes correspond to unqiue Attribute or Type classes.</p>
<p>Below show cases an example Attribute and Type definition. We generally recommend
defining Attribute and Type classes in different <code class="docutils literal notranslate"><span class="pre">.td</span></code> files to better encapsulate
the different constructs, and define a proper layering between them. This
recommendation extends to all of the MLIR constructs, including <a class="reference internal" href="../Interfaces.html"><span class="doc">Interfaces</span></a>,
Operations, etc.</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>// Include the definition of the necessary tablegen constructs for defining
// our types.
include &quot;mlir/IR/AttrTypeBase.td&quot;

// It&#39;s common to define a base classes for types in the same dialect. This
// removes the need to pass in the dialect for each type, and can also be used
// to define a few fields ahead of time.
class MyDialect_Type&lt;string name, string typeMnemonic, list&lt;Trait&gt; traits = []&gt;
    : TypeDef&lt;My_Dialect, name, traits&gt; {
  let mnemonic = typeMnemonic;
}

// Here is a simple definition of an &quot;integer&quot; type, with a width parameter.
def My_IntegerType : MyDialect_Type&lt;&quot;Integer&quot;, &quot;int&quot;&gt; {
  let summary = &quot;Integer type with arbitrary precision up to a fixed limit&quot;;
  let description = [{
    Integer types have a designated bit width.
  }];
  /// Here we defined a single parameter for the type, which is the bitwidth.
  let parameters = (ins &quot;unsigned&quot;:$width);

  /// Here we define the textual format of the type declaratively, which will
  /// automatically generate parser and printer logic. This will allow for
  /// instances of the type to be output as, for example:
  ///
  ///    !my.int&lt;10&gt; // a 10-bit integer.
  ///
  let assemblyFormat = &quot;`&lt;` $width `&gt;`&quot;;

  /// Indicate that our type will add additional verification to the parameters.
  let genVerifyDecl = 1;
}
</pre></div>
</div>
<p>Below is an example of an Attribute:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>// Include the definition of the necessary tablegen constructs for defining
// our attributes.
include &quot;mlir/IR/AttrTypeBase.td&quot;

// It&#39;s common to define a base classes for attributes in the same dialect. This
// removes the need to pass in the dialect for each attribute, and can also be used
// to define a few fields ahead of time.
class MyDialect_Attr&lt;string name, string attrMnemonic, list&lt;Trait&gt; traits = []&gt;
    : AttrDef&lt;My_Dialect, name, traits&gt; {
  let mnemonic = attrMnemonic;
}

// Here is a simple definition of an &quot;integer&quot; attribute, with a type and value parameter.
def My_IntegerAttr : MyDialect_Attr&lt;&quot;Integer&quot;, &quot;int&quot;&gt; {
  let summary = &quot;An Attribute containing a integer value&quot;;
  let description = [{
    An integer attribute is a literal attribute that represents an integral
    value of the specified integer type.
  }];
  /// Here we&#39;ve defined two parameters, one is a &quot;self&quot; type parameter, and the
  /// other is the integer value of the attribute. The self type parameter is
  /// specially handled by the assembly format.
  let parameters = (ins AttributeSelfTypeParameter&lt;&quot;&quot;&gt;:$type, &quot;APInt&quot;:$value);

  /// Here we&#39;ve defined a custom builder for the type, that removes the need to pass
  /// in an MLIRContext instance; as it can be infered from the `type`.
  let builders = [
    AttrBuilderWithInferredContext&lt;(ins &quot;Type&quot;:$type,
                                        &quot;const APInt &amp;&quot;:$value), [{
      return $_get(type.getContext(), type, value);
    }]&gt;
  ];

  /// Here we define the textual format of the attribute declaratively, which will
  /// automatically generate parser and printer logic. This will allow for
  /// instances of the attribute to be output as, for example:
  ///
  ///    #my.int&lt;50&gt; : !my.int&lt;32&gt; // a 32-bit integer of value 50.
  ///
  /// Note that the self type parameter is not included in the assembly format.
  /// Its value is derived from the optional trailing type on all attributes.
  let assemblyFormat = &quot;`&lt;` $value `&gt;`&quot;;

  /// Indicate that our attribute will add additional verification to the parameters.
  let genVerifyDecl = 1;

  /// Indicate to the ODS generator that we do not want the default builders,
  /// as we have defined our own simpler ones.
  let skipDefaultBuilders = 1;
}
</pre></div>
</div>
</section>
<section id="class-name">
<h3>Class Name<a class="headerlink" href="#class-name" title="此标题的永久链接">¶</a></h3>
<p>The name of the C++ class which gets generated defaults to
<code class="docutils literal notranslate"><span class="pre">&lt;classParamName&gt;Attr</span></code> or <code class="docutils literal notranslate"><span class="pre">&lt;classParamName&gt;Type</span></code> for attributes and types
respectively. In the examples above, this was the <code class="docutils literal notranslate"><span class="pre">name</span></code> template parameter that
was provided to <code class="docutils literal notranslate"><span class="pre">MyDialect_Attr</span></code> and <code class="docutils literal notranslate"><span class="pre">MyDialect_Type</span></code>. For the definitions we
added above, we would get C++ classes named <code class="docutils literal notranslate"><span class="pre">IntegerType</span></code> and <code class="docutils literal notranslate"><span class="pre">IntegerAttr</span></code>
respectively. This can be explicitly overridden via the <code class="docutils literal notranslate"><span class="pre">cppClassName</span></code> field.</p>
</section>
<section id="documentation">
<h3>Documentation<a class="headerlink" href="#documentation" title="此标题的永久链接">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">summary</span></code> and <code class="docutils literal notranslate"><span class="pre">description</span></code> fields allow for providing user documentation
for the attribute or type. The <code class="docutils literal notranslate"><span class="pre">summary</span></code> field expects a simple single-line
string, with the <code class="docutils literal notranslate"><span class="pre">description</span></code> field used for long and extensive documentation.
This documentation can be used to generate markdown documentation for the
dialect and is used by upstream
<a class="reference external" href="https://mlir.llvm.org/docs/Dialects/">MLIR dialects</a>.</p>
</section>
<section id="mnemonic">
<h3>Mnemonic<a class="headerlink" href="#mnemonic" title="此标题的永久链接">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">mnemonic</span></code> field, i.e. the template parameters <code class="docutils literal notranslate"><span class="pre">attrMnemonic</span></code> and
<code class="docutils literal notranslate"><span class="pre">typeMnemonic</span></code> we specified above, are used to specify a name for use during
parsing. This allows for more easily dispatching to the current attribute or
type class when parsing IR. This field is generally optional, and custom
parsing/printing logic can be added without defining it, though most classes
will want to take advantage of the convenience it provides. This is why we
added it as a template parameter in the examples above.</p>
</section>
<section id="parameters">
<h3>Parameters<a class="headerlink" href="#parameters" title="此标题的永久链接">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">parameters</span></code> field is a variable length list containing the attribute or
type’s parameters. If no parameters are specified (the default), this type is
considered a singleton type (meaning there is only one possible instance).
Parameters in this list take the form: <code class="docutils literal notranslate"><span class="pre">&quot;c++Type&quot;:$paramName</span></code>. Parameter types
with a C++ type that requires allocation when constructing the storage instance
in the context require one of the following:</p>
<ul class="simple">
<li><p>Utilize the <code class="docutils literal notranslate"><span class="pre">AttrParameter</span></code> or <code class="docutils literal notranslate"><span class="pre">TypeParameter</span></code> classes instead of the raw
“c++Type” string. This allows for providing custom allocation code when using
that parameter. <code class="docutils literal notranslate"><span class="pre">StringRefParameter</span></code> and <code class="docutils literal notranslate"><span class="pre">ArrayRefParameter</span></code> are examples of
common parameter types that require allocation.</p></li>
<li><p>Set the <code class="docutils literal notranslate"><span class="pre">genAccessors</span></code> field to 1 (the default) to generate accessor methods
for each parameter (e.g. <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">getWidth()</span> <span class="pre">const</span></code> in the Type example above).</p></li>
<li><p>Set the <code class="docutils literal notranslate"><span class="pre">hasCustomStorageConstructor</span></code> field to <code class="docutils literal notranslate"><span class="pre">1</span></code> to generate a storage class
that only declares the constructor, allowing for you to specialize it with
whatever allocation code necessary.</p></li>
</ul>
<section id="attrparameter-typeparameter-and-attrortypeparameter">
<h4>AttrParameter, TypeParameter, and AttrOrTypeParameter<a class="headerlink" href="#attrparameter-typeparameter-and-attrortypeparameter" title="此标题的永久链接">¶</a></h4>
<p>As hinted at above, these classes allow for specifying parameter types with
additional functionality. This is generally useful for complex parameters, or those
with additional invariants that prevent using the raw C++ class. Examples
include documentation (e.g. the <code class="docutils literal notranslate"><span class="pre">summary</span></code> and <code class="docutils literal notranslate"><span class="pre">syntax</span></code> field), the C++ type, a
custom allocator to use in the storage constructor method, a custom comparator
to decide if two instances of the parameter type are equal, etc. As the names
may suggest, <code class="docutils literal notranslate"><span class="pre">AttrParameter</span></code> is intended for parameters on Attributes,
<code class="docutils literal notranslate"><span class="pre">TypeParameter</span></code> for Type parameters, and <code class="docutils literal notranslate"><span class="pre">AttrOrTypeParameters</span></code> for either.</p>
<p>Below is an easy parameter pitfall, and highlights when to use these parameter
classes.</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>let parameters = (ins &quot;ArrayRef&lt;int&gt;&quot;:$dims);
</pre></div>
</div>
<p>The above seems innocuous, but it is often a bug! The default storage
constructor blindly copies parameters by value. It does not know anything about
the types, meaning that the data of this ArrayRef will be copied as-is and is
likely to lead to use-after-free errors when using the created Attribute or
Type if the underlying does not have a lifetime exceeding that of the MLIRContext.
If the lifetime of the data can’t be guaranteed, the <code class="docutils literal notranslate"><span class="pre">ArrayRef&lt;int&gt;</span></code> requires
allocation to ensure that its elements reside within the MLIRContext, e.g. with
<code class="docutils literal notranslate"><span class="pre">dims</span> <span class="pre">=</span> <span class="pre">allocator.copyInto(dims)</span></code>.</p>
<p>Here is a simple example for the exact situation above:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def ArrayRefIntParam : TypeParameter&lt;&quot;::llvm::ArrayRef&lt;int&gt;&quot;, &quot;Array of int&quot;&gt; {
  let allocator = &quot;$_dst = $_allocator.copyInto($_self);&quot;;
}

The parameter can then be used as so:

...
let parameters = (ins ArrayRefIntParam:$dims);
</pre></div>
</div>
<p>Below contains descriptions for other various available fields:</p>
<p>The <code class="docutils literal notranslate"><span class="pre">allocator</span></code> code block has the following substitutions:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">$_allocator</span></code> is the TypeStorageAllocator in which to allocate objects.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">$_dst</span></code> is the variable in which to place the allocated data.</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">comparator</span></code> code block has the following substitutions:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">$_lhs</span></code> is an instance of the parameter type.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">$_rhs</span></code> is an instance of the parameter type.</p></li>
</ul>
<p>MLIR includes several specialized classes for common situations:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">APFloatParameter</span></code> for APFloats.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">StringRefParameter&lt;descriptionOfParam&gt;</span></code> for StringRefs.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ArrayRefParameter&lt;arrayOf,</span> <span class="pre">descriptionOfParam&gt;</span></code> for ArrayRefs of value types.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SelfAllocationParameter&lt;descriptionOfParam&gt;</span></code> for C++ classes which contain a
method called <code class="docutils literal notranslate"><span class="pre">allocateInto(StorageAllocator</span> <span class="pre">&amp;allocator)</span></code> to allocate itself
into <code class="docutils literal notranslate"><span class="pre">allocator</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ArrayRefOfSelfAllocationParameter&lt;arrayOf,</span> <span class="pre">descriptionOfParam&gt;</span></code> for arrays of
objects which self-allocate as per the last specialization.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">AttributeSelfTypeParameter</span></code> is a special <code class="docutils literal notranslate"><span class="pre">AttrParameter</span></code> that represents
parameters derived from the optional trailing type on attributes.</p></li>
</ul>
</section>
</section>
<section id="traits">
<h3>Traits<a class="headerlink" href="#traits" title="此标题的永久链接">¶</a></h3>
<p>Similarly to operations, Attribute and Type classes may attach <code class="docutils literal notranslate"><span class="pre">Traits</span></code> that
provide additional mixin methods and other data. <code class="docutils literal notranslate"><span class="pre">Trait</span></code>s may be attached via
the trailing template argument, i.e. the <code class="docutils literal notranslate"><span class="pre">traits</span></code> list parameter in the example
above. See the main <a class="reference internal" href="../Traits.html"><span class="doc">Trait</span></a> documentation for more information
on defining and using traits.</p>
</section>
<section id="interfaces">
<h3>Interfaces<a class="headerlink" href="#interfaces" title="此标题的永久链接">¶</a></h3>
<p>Attribute and Type classes may attach <code class="docutils literal notranslate"><span class="pre">Interfaces</span></code> to provide an virtual
interface into the Attribute or Type. <code class="docutils literal notranslate"><span class="pre">Interfaces</span></code> are added in the same way as
<a class="reference external" href="#Traits">Traits</a>, by using the <code class="docutils literal notranslate"><span class="pre">traits</span></code> list template parameter of the
<code class="docutils literal notranslate"><span class="pre">AttrDef</span></code> or <code class="docutils literal notranslate"><span class="pre">TypeDef</span></code>. See the main <a class="reference internal" href="../Interfaces.html"><span class="doc">Interface</span></a>
documentation for more information on defining and using interfaces.</p>
</section>
<section id="builders">
<h3>Builders<a class="headerlink" href="#builders" title="此标题的永久链接">¶</a></h3>
<p>For each attribute or type, there are a few builders(<code class="docutils literal notranslate"><span class="pre">get</span></code>/<code class="docutils literal notranslate"><span class="pre">getChecked</span></code>)
automatically generated based on the parameters of the type. These are used to
construct instances of the corresponding attribute or type. For example, given
the following definition:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def MyAttrOrType : ... {
  let parameters = (ins &quot;int&quot;:$intParam);
}
</pre></div>
</div>
<p>The following builders are generated:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Builders are named `get`, and return a new instance for a given set of parameters.</span>
<span class="k">static</span><span class="w"> </span><span class="n">MyAttrOrType</span><span class="w"> </span><span class="nf">get</span><span class="p">(</span><span class="n">MLIRContext</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">intParam</span><span class="p">);</span>

<span class="c1">// If `genVerifyDecl` is set to 1, the following method is also generated. This method</span>
<span class="c1">// is similar to `get`, but is failable and on error will return nullptr.</span>
<span class="k">static</span><span class="w"> </span><span class="n">MyAttrOrType</span><span class="w"> </span><span class="nf">getChecked</span><span class="p">(</span><span class="n">function_ref</span><span class="o">&lt;</span><span class="n">InFlightDiagnostic</span><span class="p">()</span><span class="o">&gt;</span><span class="w"> </span><span class="n">emitError</span><span class="p">,</span>
<span class="w">                               </span><span class="n">MLIRContext</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">intParam</span><span class="p">);</span>
</pre></div>
</div>
<p>If these autogenerated methods are not desired, such as when they conflict with
a custom builder method, the <code class="docutils literal notranslate"><span class="pre">skipDefaultBuilders</span></code> field may be set to 1 to
signal that the default builders should not be generated.</p>
<section id="custom-builder-methods">
<h4>Custom builder methods<a class="headerlink" href="#custom-builder-methods" title="此标题的永久链接">¶</a></h4>
<p>The default builder methods may cover a majority of the simple cases related to
construction, but when they cannot satisfy all of an attribute or type’s needs,
additional builders may be defined via the <code class="docutils literal notranslate"><span class="pre">builders</span></code> field. The <code class="docutils literal notranslate"><span class="pre">builders</span></code>
field is a list of custom builders, either using <code class="docutils literal notranslate"><span class="pre">TypeBuilder</span></code> for types or
<code class="docutils literal notranslate"><span class="pre">AttrBuilder</span></code> for attributes, that are added to the attribute or type class. The
following will showcase several examples for defining builders for a custom type
<code class="docutils literal notranslate"><span class="pre">MyType</span></code>, the process is the same for attributes except that attributes use
<code class="docutils literal notranslate"><span class="pre">AttrBuilder</span></code> instead of <code class="docutils literal notranslate"><span class="pre">TypeBuilder</span></code>.</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def MyType : ... {
  let parameters = (ins &quot;int&quot;:$intParam);

  let builders = [
    TypeBuilder&lt;(ins &quot;int&quot;:$intParam)&gt;,
    TypeBuilder&lt;(ins CArg&lt;&quot;int&quot;, &quot;0&quot;&gt;:$intParam)&gt;,
    TypeBuilder&lt;(ins CArg&lt;&quot;int&quot;, &quot;0&quot;&gt;:$intParam), [{
      // Write the body of the `get` builder inline here.
      return Base::get($_ctxt, intParam);
    }]&gt;,
    TypeBuilderWithInferredContext&lt;(ins &quot;Type&quot;:$typeParam), [{
      // This builder states that it can infer an MLIRContext instance from
      // its arguments.
      return Base::get(typeParam.getContext(), ...);
    }]&gt;,
    TypeBuilder&lt;(ins &quot;int&quot;:$intParam), [{}], &quot;IntegerType&quot;&gt;,
  ];
}
</pre></div>
</div>
<p>In this example, we provide several different convenience builders that are
useful in different scenarios. The <code class="docutils literal notranslate"><span class="pre">ins</span></code> prefix is common to many function
declarations in ODS, which use a TableGen <a class="reference external" href="#tablegen-syntax"><code class="docutils literal notranslate"><span class="pre">dag</span></code></a>. What
follows is a comma-separated list of types (quoted string or <code class="docutils literal notranslate"><span class="pre">CArg</span></code>) and names
prefixed with the <code class="docutils literal notranslate"><span class="pre">$</span></code> sign. The use of <code class="docutils literal notranslate"><span class="pre">CArg</span></code> allows for providing a default
value to that argument. Let’s take a look at each of these builders individually</p>
<p>The first builder will generate the declaration of a builder method that looks
like:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>  let builders = [
    TypeBuilder&lt;(ins &quot;int&quot;:$intParam)&gt;,
  ];
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyType</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="cm">/*...*/</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="cm">/*...*/</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">MyType</span><span class="w"> </span><span class="nf">get</span><span class="p">(</span><span class="o">::</span><span class="n">mlir</span><span class="o">::</span><span class="n">MLIRContext</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">intParam</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This builder is identical to the one that will be automatically generated for
<code class="docutils literal notranslate"><span class="pre">MyType</span></code>. The <code class="docutils literal notranslate"><span class="pre">context</span></code> parameter is implicitly added by the generator, and is
used when building the Type instance (with <code class="docutils literal notranslate"><span class="pre">Base::get</span></code>). The distinction here is
that we can provide the implementation of this <code class="docutils literal notranslate"><span class="pre">get</span></code> method. With this style of
builder definition only the declaration is generated, the implementor of
<code class="docutils literal notranslate"><span class="pre">MyType</span></code> will need to provide a definition of <code class="docutils literal notranslate"><span class="pre">MyType::get</span></code>.</p>
<p>The second builder will generate the declaration of a builder method that looks
like:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>  let builders = [
    TypeBuilder&lt;(ins CArg&lt;&quot;int&quot;, &quot;0&quot;&gt;:$intParam)&gt;,
  ];
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyType</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="cm">/*...*/</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="cm">/*...*/</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">MyType</span><span class="w"> </span><span class="nf">get</span><span class="p">(</span><span class="o">::</span><span class="n">mlir</span><span class="o">::</span><span class="n">MLIRContext</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">intParam</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The constraints here are identical to the first builder example except for the
fact that <code class="docutils literal notranslate"><span class="pre">intParam</span></code> now has a default value attached.</p>
<p>The third builder will generate the declaration of a builder method that looks
like:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>  let builders = [
    TypeBuilder&lt;(ins CArg&lt;&quot;int&quot;, &quot;0&quot;&gt;:$intParam), [{
      // Write the body of the `get` builder inline here.
      return Base::get($_ctxt, intParam);
    }]&gt;,
  ];
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyType</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="cm">/*...*/</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="cm">/*...*/</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">MyType</span><span class="w"> </span><span class="nf">get</span><span class="p">(</span><span class="o">::</span><span class="n">mlir</span><span class="o">::</span><span class="n">MLIRContext</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">intParam</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="p">};</span>

<span class="n">MyType</span><span class="w"> </span><span class="nf">MyType::get</span><span class="p">(</span><span class="o">::</span><span class="n">mlir</span><span class="o">::</span><span class="n">MLIRContext</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">intParam</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Write the body of the `get` builder inline here.</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">Base</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">intParam</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is identical to the second builder example. The difference is that now, a
definition for the builder method will be generated automatically using the
provided code block as the body. When specifying the body inline, <code class="docutils literal notranslate"><span class="pre">$_ctxt</span></code> may
be used to access the <code class="docutils literal notranslate"><span class="pre">MLIRContext</span> <span class="pre">*</span></code> parameter.</p>
<p>The fourth builder will generate the declaration of a builder method that looks
like:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>  let builders = [
    TypeBuilderWithInferredContext&lt;(ins &quot;Type&quot;:$typeParam), [{
      // This builder states that it can infer an MLIRContext instance from
      // its arguments.
      return Base::get(typeParam.getContext(), ...);
    }]&gt;,
  ];
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyType</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="cm">/*...*/</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="cm">/*...*/</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">MyType</span><span class="w"> </span><span class="nf">get</span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="n">typeParam</span><span class="p">);</span>
<span class="p">};</span>

<span class="n">MyType</span><span class="w"> </span><span class="nf">MyType::get</span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="n">typeParam</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// This builder states that it can infer an MLIRContext instance from its</span>
<span class="w">  </span><span class="c1">// arguments.</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">Base</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">typeParam</span><span class="p">.</span><span class="n">getContext</span><span class="p">(),</span><span class="w"> </span><span class="p">...);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this builder example, the main difference from the third builder example
there is that the <code class="docutils literal notranslate"><span class="pre">MLIRContext</span></code> parameter is no longer added. This is because
the builder used <code class="docutils literal notranslate"><span class="pre">TypeBuilderWithInferredContext</span></code> implies that the context
parameter is not necessary as it can be inferred from the arguments to the
builder.</p>
<p>The fifth builder will generate the declaration of a builder method with a
custom return type, like:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>  let builders = [
    TypeBuilder&lt;(ins &quot;int&quot;:$intParam), [{}], &quot;IntegerType&quot;&gt;,
  ]
</pre></div>
</div>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyType</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="cm">/*...*/</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="cm">/*...*/</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">IntegerType</span><span class="w"> </span><span class="nf">get</span><span class="p">(</span><span class="o">::</span><span class="n">mlir</span><span class="o">::</span><span class="n">MLIRContext</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">intParam</span><span class="p">);</span>

<span class="p">};</span>
</pre></div>
</div>
<p>This generates a builder declaration the same as the first three examples, but
the return type of the builder is user-specified instead of the attribute or
type class. This is useful for defining builders of attributes and types that
may fold or canonicalize on construction.</p>
</section>
</section>
<section id="parsing-and-printing">
<h3>Parsing and Printing<a class="headerlink" href="#parsing-and-printing" title="此标题的永久链接">¶</a></h3>
<p>If a mnemonic was specified, the <code class="docutils literal notranslate"><span class="pre">hasCustomAssemblyFormat</span></code> and <code class="docutils literal notranslate"><span class="pre">assemblyFormat</span></code>
fields may be used to specify the assembly format of an attribute or type. Attributes
and Types with no parameters need not use either of these fields, in which case
the syntax for the Attribute or Type is simply the mnemonic.</p>
<p>For each dialect, two “dispatch” functions will be created: one for parsing and
one for printing. These static functions placed alongside the class definitions
and have the following function signatures:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">ParseResult</span><span class="w"> </span><span class="nf">generatedAttributeParser</span><span class="p">(</span><span class="n">DialectAsmParser</span><span class="o">&amp;</span><span class="w"> </span><span class="n">parser</span><span class="p">,</span><span class="w"> </span><span class="n">StringRef</span><span class="w"> </span><span class="o">*</span><span class="n">mnemonic</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="n">attrType</span><span class="p">,</span><span class="w"> </span><span class="n">Attribute</span><span class="w"> </span><span class="o">&amp;</span><span class="n">result</span><span class="p">);</span>
<span class="k">static</span><span class="w"> </span><span class="n">LogicalResult</span><span class="w"> </span><span class="nf">generatedAttributePrinter</span><span class="p">(</span><span class="n">Attribute</span><span class="w"> </span><span class="n">attr</span><span class="p">,</span><span class="w"> </span><span class="n">DialectAsmPrinter</span><span class="o">&amp;</span><span class="w"> </span><span class="n">printer</span><span class="p">);</span>

<span class="k">static</span><span class="w"> </span><span class="n">ParseResult</span><span class="w"> </span><span class="nf">generatedTypeParser</span><span class="p">(</span><span class="n">DialectAsmParser</span><span class="o">&amp;</span><span class="w"> </span><span class="n">parser</span><span class="p">,</span><span class="w"> </span><span class="n">StringRef</span><span class="w"> </span><span class="o">*</span><span class="n">mnemonic</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="o">&amp;</span><span class="n">result</span><span class="p">);</span>
<span class="k">static</span><span class="w"> </span><span class="n">LogicalResult</span><span class="w"> </span><span class="nf">generatedTypePrinter</span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">DialectAsmPrinter</span><span class="o">&amp;</span><span class="w"> </span><span class="n">printer</span><span class="p">);</span>
</pre></div>
</div>
<p>The above functions should be added to the respective in your
<code class="docutils literal notranslate"><span class="pre">Dialect::printType</span></code> and <code class="docutils literal notranslate"><span class="pre">Dialect::parseType</span></code> methods, or consider using the
<code class="docutils literal notranslate"><span class="pre">useDefaultAttributePrinterParser</span></code> and <code class="docutils literal notranslate"><span class="pre">useDefaultTypePrinterParser</span></code> ODS Dialect
options if all attributes or types define a mnemonic.</p>
<p>The mnemonic, hasCustomAssemblyFormat, and assemblyFormat fields are optional.
If none are defined, the generated code will not include any parsing or printing
code and omit the attribute or type from the dispatch functions above. In this
case, the dialect author is responsible for parsing/printing in the respective
<code class="docutils literal notranslate"><span class="pre">Dialect::parseAttribute</span></code>/<code class="docutils literal notranslate"><span class="pre">Dialect::printAttribute</span></code> and
<code class="docutils literal notranslate"><span class="pre">Dialect::parseType</span></code>/<code class="docutils literal notranslate"><span class="pre">Dialect::printType</span></code> methods.</p>
<section id="using-hascustomassemblyformat">
<h4>Using <code class="docutils literal notranslate"><span class="pre">hasCustomAssemblyFormat</span></code><a class="headerlink" href="#using-hascustomassemblyformat" title="此标题的永久链接">¶</a></h4>
<p>Attributes and types defined in ODS with a mnemonic can define an
<code class="docutils literal notranslate"><span class="pre">hasCustomAssemblyFormat</span></code> to specify custom parsers and printers defined in C++.
When set to <code class="docutils literal notranslate"><span class="pre">1</span></code> a corresponding <code class="docutils literal notranslate"><span class="pre">parse</span></code> and <code class="docutils literal notranslate"><span class="pre">print</span></code> method will be declared on
the Attribute or Type class to be defined by the user.</p>
<p>For Types, these methods will have the form:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">Type</span> <span class="pre">MyType::parse(AsmParser</span> <span class="pre">&amp;parser)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Type</span> <span class="pre">MyType::print(AsmPrinter</span> <span class="pre">&amp;p)</span> <span class="pre">const</span></code></p></li>
</ul>
<p>For Attributes, these methods will have the form:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">Attribute</span> <span class="pre">MyAttr::parse(AsmParser</span> <span class="pre">&amp;parser,</span> <span class="pre">Type</span> <span class="pre">attrType)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Attribute</span> <span class="pre">MyAttr::print(AsmPrinter</span> <span class="pre">&amp;p)</span> <span class="pre">const</span></code></p></li>
</ul>
</section>
<section id="using-assemblyformat">
<h4>Using <code class="docutils literal notranslate"><span class="pre">assemblyFormat</span></code><a class="headerlink" href="#using-assemblyformat" title="此标题的永久链接">¶</a></h4>
<p>Attributes and types defined in ODS with a mnemonic can define an
<code class="docutils literal notranslate"><span class="pre">assemblyFormat</span></code> to declaratively describe custom parsers and printers. The
assembly format consists of literals, variables, and directives.</p>
<ul class="simple">
<li><p>A literal is a keyword or valid punctuation enclosed in backticks, e.g.
<code class="docutils literal notranslate"><span class="pre">`keyword`</span></code> or <code class="docutils literal notranslate"><span class="pre">`&lt;`</span></code>.</p></li>
<li><p>A variable is a parameter name preceded by a dollar sign, e.g. <code class="docutils literal notranslate"><span class="pre">$param0</span></code>,
which captures one attribute or type parameter.</p></li>
<li><p>A directive is a keyword followed by an optional argument list that defines
special parser and printer behaviour.</p></li>
</ul>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>// An example type with an assembly format.
def MyType : TypeDef&lt;My_Dialect, &quot;MyType&quot;&gt; {
  // Define a mnemonic to allow the dialect&#39;s parser hook to call into the
  // generated parser.
  let mnemonic = &quot;my_type&quot;;

  // Define two parameters whose C++ types are indicated in string literals.
  let parameters = (ins &quot;int&quot;:$count, &quot;AffineMap&quot;:$map);

  // Define the assembly format. Surround the format with less `&lt;` and greater
  // `&gt;` so that MLIR&#39;s printer uses the pretty format.
  let assemblyFormat = &quot;`&lt;` $count `,` `map` `=` $map `&gt;`&quot;;
}
</pre></div>
</div>
<p>The declarative assembly format for <code class="docutils literal notranslate"><span class="pre">MyType</span></code> results in the following format in
the IR:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>!my_dialect.my_type&lt;42, map = affine_map&lt;(i, j) -&gt; (j, i)&gt;&gt;
</pre></div>
</div>
<section id="parameter-parsing-and-printing">
<h5>Parameter Parsing and Printing<a class="headerlink" href="#parameter-parsing-and-printing" title="此标题的永久链接">¶</a></h5>
<p>For many basic parameter types, no additional work is needed to define how these
parameters are parsed or printed.</p>
<ul class="simple">
<li><p>The default printer for any parameter is <code class="docutils literal notranslate"><span class="pre">$_printer</span> <span class="pre">&lt;&lt;</span> <span class="pre">$_self</span></code>, where <code class="docutils literal notranslate"><span class="pre">$_self</span></code>
is the C++ value of the parameter and <code class="docutils literal notranslate"><span class="pre">$_printer</span></code> is an <code class="docutils literal notranslate"><span class="pre">AsmPrinter</span></code>.</p></li>
<li><p>The default parser for a parameter is
<code class="docutils literal notranslate"><span class="pre">FieldParser&lt;$cppClass&gt;::parse($_parser)</span></code>, where <code class="docutils literal notranslate"><span class="pre">$cppClass</span></code> is the C++ type
of the parameter and <code class="docutils literal notranslate"><span class="pre">$_parser</span></code> is an <code class="docutils literal notranslate"><span class="pre">AsmParser</span></code>.</p></li>
</ul>
<p>Printing and parsing behaviour can be added to additional C++ types by
overloading these functions or by defining a <code class="docutils literal notranslate"><span class="pre">parser</span></code> and <code class="docutils literal notranslate"><span class="pre">printer</span></code> in an ODS
parameter class.</p>
<p>Example of overloading:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span><span class="w"> </span><span class="n">MyParameter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>

<span class="n">AsmPrinter</span><span class="w"> </span><span class="o">&amp;</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">AsmPrinter</span><span class="w"> </span><span class="o">&amp;</span><span class="n">printer</span><span class="p">,</span><span class="w"> </span><span class="n">MyParameter</span><span class="w"> </span><span class="n">param</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">printer</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">param</span><span class="p">.</span><span class="n">first</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; * &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">param</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">FieldParser</span><span class="o">&lt;</span><span class="n">MyParameter</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">FailureOr</span><span class="o">&lt;</span><span class="n">MyParameter</span><span class="o">&gt;</span><span class="w"> </span><span class="n">parse</span><span class="p">(</span><span class="n">AsmParser</span><span class="w"> </span><span class="o">&amp;</span><span class="n">parser</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">parser</span><span class="p">.</span><span class="n">parseInteger</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">parser</span><span class="p">.</span><span class="n">parseStar</span><span class="p">()</span><span class="w"> </span><span class="o">||</span>
<span class="w">        </span><span class="n">parser</span><span class="p">.</span><span class="n">parseInteger</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">failure</span><span class="p">();</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">MyParameter</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Example of using ODS parameter classes:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def MyParameter : TypeParameter&lt;&quot;std::pair&lt;int, int&gt;&quot;, &quot;pair of ints&quot;&gt; {
  let printer = [{ $_printer &lt;&lt; $_self.first &lt;&lt; &quot; * &quot; &lt;&lt; $_self.second }];
  let parser = [{ [&amp;] -&gt; FailureOr&lt;std::pair&lt;int, int&gt;&gt; {
    int a, b;
    if ($_parser.parseInteger(a) || $_parser.parseStar() ||
        $_parser.parseInteger(b))
      return failure();
    return std::make_pair(a, b);
  }() }];
}
</pre></div>
</div>
<p>A type using this parameter with the assembly format <code class="docutils literal notranslate"><span class="pre">`&lt;`</span> <span class="pre">$myParam</span> <span class="pre">`&gt;`</span></code> will
look as follows in the IR:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>!my_dialect.my_type&lt;42 * 24&gt;
</pre></div>
</div>
<section id="non-pod-parameters">
<h6>Non-POD Parameters<a class="headerlink" href="#non-pod-parameters" title="此标题的永久链接">¶</a></h6>
<p>Parameters that aren’t plain-old-data (e.g. references) may need to define a
<code class="docutils literal notranslate"><span class="pre">cppStorageType</span></code> to contain the data until it is copied into the allocator. For
example, <code class="docutils literal notranslate"><span class="pre">StringRefParameter</span></code> uses <code class="docutils literal notranslate"><span class="pre">std::string</span></code> as its storage type, whereas
<code class="docutils literal notranslate"><span class="pre">ArrayRefParameter</span></code> uses <code class="docutils literal notranslate"><span class="pre">SmallVector</span></code> as its storage type. The parsers for
these parameters are expected to return <code class="docutils literal notranslate"><span class="pre">FailureOr&lt;$cppStorageType&gt;</span></code>.</p>
<p>To add a custom conversion between the <code class="docutils literal notranslate"><span class="pre">cppStorageType</span></code> and the C++ type of the
parameter, parameters can override <code class="docutils literal notranslate"><span class="pre">convertFromStorage</span></code>, which by default is
<code class="docutils literal notranslate"><span class="pre">&quot;$_self&quot;</span></code> (i.e., it attempts an implicit conversion from <code class="docutils literal notranslate"><span class="pre">cppStorageType</span></code>).</p>
</section>
<section id="optional-and-default-valued-parameters">
<h6>Optional and Default-Valued Parameters<a class="headerlink" href="#optional-and-default-valued-parameters" title="此标题的永久链接">¶</a></h6>
<p>An optional parameter can be omitted from the assembly format of an attribute or
a type. An optional parameter is omitted when it is equal to its default value.
Optional parameters in the assembly format can be indicated by setting
<code class="docutils literal notranslate"><span class="pre">defaultValue</span></code>, a string of the C++ default value. If a value for the parameter
was not encountered during parsing, it is set to this default value. If a
parameter is equal to its default value, it is not printed. The <code class="docutils literal notranslate"><span class="pre">comparator</span></code>
field of the parameter is used, but if one is not specified, the equality
operator is used.</p>
<p>When using <code class="docutils literal notranslate"><span class="pre">OptionalParameter</span></code>, the default value is set to the C++
default-constructed value for the C++ storage type. For example, <code class="docutils literal notranslate"><span class="pre">Optional&lt;int&gt;</span></code>
will be set to <code class="docutils literal notranslate"><span class="pre">std::nullopt</span></code> and <code class="docutils literal notranslate"><span class="pre">Attribute</span></code> will be set to <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>. The
presence of these parameters is tested by comparing them to their “null” values.</p>
<p>An optional group is a set of elements optionally printed based on the presence
of an anchor. Only optional parameters or directives that only capture optional
parameters can be used in optional groups. The group in which the anchor is
placed is printed if it is present, otherwise the other one is printed. If a
directive that captures more than one optional parameter is used as the anchor,
the optional group is printed if any of the captured parameters is present. For
example, a <code class="docutils literal notranslate"><span class="pre">custom</span></code> directive may only be used as an optional group anchor if it
captures at least one optional parameter.</p>
<p>Suppose parameter <code class="docutils literal notranslate"><span class="pre">a</span></code> is an <code class="docutils literal notranslate"><span class="pre">IntegerAttr</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>( `(` $a^ `)` ) : (`x`)?
</pre></div>
</div>
<p>In the above assembly format, if <code class="docutils literal notranslate"><span class="pre">a</span></code> is present (non-null), then it will be
printed as <code class="docutils literal notranslate"><span class="pre">(5</span> <span class="pre">:</span> <span class="pre">i32)</span></code>. If it is not present, it will be <code class="docutils literal notranslate"><span class="pre">x</span></code>. Directives that
are used inside optional groups are allowed only if all captured parameters are
also optional.</p>
<p>An optional parameter can also be specified with <code class="docutils literal notranslate"><span class="pre">DefaultValuedParameter</span></code>, which
specifies that a parameter should be omitted when it is equal to some given
value.</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>let parameters = (ins DefaultValuedParameter&lt;&quot;Optional&lt;int&gt;&quot;, &quot;5&quot;&gt;:$a)
let mnemonic = &quot;default_valued&quot;;
let assemblyFormat = &quot;(`&lt;` $a^ `&gt;`)?&quot;;
</pre></div>
</div>
<p>Which will look like:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>!test.default_valued     // a = 5
!test.default_valued&lt;10&gt; // a = 10
</pre></div>
</div>
<p>For optional <code class="docutils literal notranslate"><span class="pre">Attribute</span></code> or <code class="docutils literal notranslate"><span class="pre">Type</span></code> parameters, the current MLIR context is
available through <code class="docutils literal notranslate"><span class="pre">$_ctxt</span></code>. E.g.</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>DefaultValuedParameter&lt;&quot;IntegerType&quot;, &quot;IntegerType::get($_ctxt, 32)&quot;&gt;
</pre></div>
</div>
<p>The value of parameters that appear <strong>before</strong> the default-valued parameter in
the parameter declaration list are available as substitutions. E.g.</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>let parameters = (ins
  &quot;IntegerAttr&quot;:$value,
  DefaultValuedParameter&lt;&quot;Type&quot;, &quot;$value.getType()&quot;&gt;:$type
);
</pre></div>
</div>
</section>
<section id="attribute-self-type-parameter">
<h6>Attribute Self Type Parameter<a class="headerlink" href="#attribute-self-type-parameter" title="此标题的永久链接">¶</a></h6>
<p>An attribute optionally has a trailing type after the assembly format of the
attribute value itself. MLIR parses over the attribute value and optionally
parses a colon-type before passing the <code class="docutils literal notranslate"><span class="pre">Type</span></code> into the dialect parser hook.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>dialect-attribute  ::= `#` dialect-namespace `&lt;` attr-data `&gt;`
                       (`:` type)?
                     | `#` alias-name pretty-dialect-sym-body? (`:` type)?
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">AttributeSelfTypeParameter</span></code> is an attribute parameter specially handled by the
assembly format generator. Only one such parameter can be specified, and its
value is derived from the trailing type. This parameter’s default value is
<code class="docutils literal notranslate"><span class="pre">NoneType::get($_ctxt)</span></code>.</p>
<p>In order for the type to be printed by
MLIR, however, the attribute must implement <code class="docutils literal notranslate"><span class="pre">TypedAttrInterface</span></code>. For example,</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>// This attribute has only a self type parameter.
def MyExternAttr : AttrDef&lt;MyDialect, &quot;MyExtern&quot;, [TypedAttrInterface]&gt; {
  let parameters = (AttributeSelfTypeParameter&lt;&quot;&quot;&gt;:$type);
  let mnemonic = &quot;extern&quot;;
  let assemblyFormat = &quot;&quot;;
}
</pre></div>
</div>
<p>This attribute can look like:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>#my_dialect.extern // none
#my_dialect.extern : i32
#my_dialect.extern : tensor&lt;4xi32&gt;
#my_dialect.extern : !my_dialect.my_type
</pre></div>
</div>
</section>
</section>
<section id="assembly-format-directives">
<h5>Assembly Format Directives<a class="headerlink" href="#assembly-format-directives" title="此标题的永久链接">¶</a></h5>
<p>Attribute and type assembly formats have the following directives:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">params</span></code>: capture all parameters of an attribute or type.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">qualified</span></code>: mark a parameter to be printed with its leading dialect and
mnemonic.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">struct</span></code>: generate a “struct-like” parser and printer for a list of key-value
pairs.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">custom</span></code>: dispatch a call to user-define parser and printer functions</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ref</span></code>: in a custom directive, references a previously bound variable</p></li>
</ul>
<section id="params-directive">
<h6><code class="docutils literal notranslate"><span class="pre">params</span></code> Directive<a class="headerlink" href="#params-directive" title="此标题的永久链接">¶</a></h6>
<p>This directive is used to refer to all parameters of an attribute or type, except
for the attribute self type (which is handled separately from normal parameters).
When used as a top-level directive, <code class="docutils literal notranslate"><span class="pre">params</span></code> generates a parser and printer for a
comma-separated list of the parameters. For example:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def MyPairType : TypeDef&lt;My_Dialect, &quot;MyPairType&quot;&gt; {
  let parameters = (ins &quot;int&quot;:$a, &quot;int&quot;:$b);
  let mnemonic = &quot;pair&quot;;
  let assemblyFormat = &quot;`&lt;` params `&gt;`&quot;;
}
</pre></div>
</div>
<p>In the IR, this type will appear as:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>!my_dialect.pair&lt;42, 24&gt;
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">params</span></code> directive can also be passed to other directives, such as <code class="docutils literal notranslate"><span class="pre">struct</span></code>,
as an argument that refers to all parameters in place of explicitly listing all
parameters as variables.</p>
</section>
<section id="qualified-directive">
<h6><code class="docutils literal notranslate"><span class="pre">qualified</span></code> Directive<a class="headerlink" href="#qualified-directive" title="此标题的永久链接">¶</a></h6>
<p>This directive can be used to wrap attribute or type parameters such that they
are printed in a fully qualified form, i.e., they include the dialect name and
mnemonic prefix.</p>
<p>For example:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def OuterType : TypeDef&lt;My_Dialect, &quot;MyOuterType&quot;&gt; {
  let parameters = (ins MyPairType:$inner);
  let mnemonic = &quot;outer&quot;;
  let assemblyFormat = &quot;`&lt;` pair `:` $inner `&gt;`&quot;;
}
def OuterQualifiedType : TypeDef&lt;My_Dialect, &quot;MyOuterQualifiedType&quot;&gt; {
  let parameters = (ins MyPairType:$inner);
  let mnemonic = &quot;outer_qual&quot;;
  let assemblyFormat = &quot;`&lt;` pair `:` qualified($inner) `&gt;`&quot;;
}
</pre></div>
</div>
<p>In the IR, the types will appear as:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>!my_dialect.outer&lt;pair : &lt;42, 24&gt;&gt;
!my_dialect.outer_qual&lt;pair : !mydialect.pair&lt;42, 24&gt;&gt;
</pre></div>
</div>
<p>If optional parameters are present, they are not printed in the parameter list
if they are not present.</p>
</section>
<section id="struct-directive">
<h6><code class="docutils literal notranslate"><span class="pre">struct</span></code> Directive<a class="headerlink" href="#struct-directive" title="此标题的永久链接">¶</a></h6>
<p>The <code class="docutils literal notranslate"><span class="pre">struct</span></code> directive accepts a list of variables to capture and will generate
a parser and printer for a comma-separated list of key-value pairs. If an
optional parameter is included in the <code class="docutils literal notranslate"><span class="pre">struct</span></code>, it can be elided. The variables
are printed in the order they are specified in the argument list <strong>but can be
parsed in any order</strong>. For example:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def MyStructType : TypeDef&lt;My_Dialect, &quot;MyStructType&quot;&gt; {
  let parameters = (ins StringRefParameter&lt;&gt;:$sym_name,
                        &quot;int&quot;:$a, &quot;int&quot;:$b, &quot;int&quot;:$c);
  let mnemonic = &quot;struct&quot;;
  let assemblyFormat = &quot;`&lt;` $sym_name `-&gt;` struct($a, $b, $c) `&gt;`&quot;;
}
</pre></div>
</div>
<p>In the IR, this type can appear with any permutation of the order of the
parameters captured in the directive.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>!my_dialect.struct&lt;&quot;foo&quot; -&gt; a = 1, b = 2, c = 3&gt;
!my_dialect.struct&lt;&quot;foo&quot; -&gt; b = 2, c = 3, a = 1&gt;
</pre></div>
</div>
<p>Passing <code class="docutils literal notranslate"><span class="pre">params</span></code> as the only argument to <code class="docutils literal notranslate"><span class="pre">struct</span></code> makes the directive capture
all the parameters of the attribute or type. For the same type above, an
assembly format of <code class="docutils literal notranslate"><span class="pre">`&lt;`</span> <span class="pre">struct(params)</span> <span class="pre">`&gt;`</span></code> will result in:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>!my_dialect.struct&lt;b = 2, sym_name = &quot;foo&quot;, c = 3, a = 1&gt;
</pre></div>
</div>
<p>The order in which the parameters are printed is the order in which they are
declared in the attribute’s or type’s <code class="docutils literal notranslate"><span class="pre">parameter</span></code> list.</p>
</section>
<section id="custom-and-ref-directive">
<h6><code class="docutils literal notranslate"><span class="pre">custom</span></code> and <code class="docutils literal notranslate"><span class="pre">ref</span></code> directive<a class="headerlink" href="#custom-and-ref-directive" title="此标题的永久链接">¶</a></h6>
<p>The <code class="docutils literal notranslate"><span class="pre">custom</span></code> directive is used to dispatch calls to user-defined printer and
parser functions. For example, suppose we had the following type:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>let parameters = (ins &quot;int&quot;:$foo, &quot;int&quot;:$bar);
let assemblyFormat = &quot;custom&lt;Foo&gt;($foo) custom&lt;Bar&gt;($bar, ref($foo))&quot;;
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">custom</span></code> directive <code class="docutils literal notranslate"><span class="pre">custom&lt;Foo&gt;($foo)</span></code> will in the parser and printer
respectively generate calls to:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">LogicalResult</span><span class="w"> </span><span class="nf">parseFoo</span><span class="p">(</span><span class="n">AsmParser</span><span class="w"> </span><span class="o">&amp;</span><span class="n">parser</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">foo</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">printFoo</span><span class="p">(</span><span class="n">AsmPrinter</span><span class="w"> </span><span class="o">&amp;</span><span class="n">printer</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">foo</span><span class="p">);</span>
</pre></div>
</div>
<p>As you can see, by default parameters are passed into the parse function by
reference. This is only possible if the C++ type is default constructible.
If the C++ type is not default constructible, the parameter is wrapped in a
<code class="docutils literal notranslate"><span class="pre">FailureOr</span></code>. Therefore, given the following definition:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>let parameters = (ins &quot;NotDefaultConstructible&quot;:$foobar);
let assemblyFormat = &quot;custom&lt;Fizz&gt;($foobar)&quot;;
</pre></div>
</div>
<p>It will generate calls expecting the following signature for <code class="docutils literal notranslate"><span class="pre">parseFizz</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">LogicalResult</span><span class="w"> </span><span class="nf">parseFizz</span><span class="p">(</span><span class="n">AsmParser</span><span class="w"> </span><span class="o">&amp;</span><span class="n">parser</span><span class="p">,</span><span class="w"> </span><span class="n">FailureOr</span><span class="o">&lt;</span><span class="n">NotDefaultConstructible</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">foobar</span><span class="p">);</span>
</pre></div>
</div>
<p>A previously bound variable can be passed as a parameter to a <code class="docutils literal notranslate"><span class="pre">custom</span></code> directive
by wrapping it in a <code class="docutils literal notranslate"><span class="pre">ref</span></code> directive. In the previous example, <code class="docutils literal notranslate"><span class="pre">$foo</span></code> is bound by
the first directive. The second directive references it and expects the
following printer and parser signatures:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">LogicalResult</span><span class="w"> </span><span class="nf">parseBar</span><span class="p">(</span><span class="n">AsmParser</span><span class="w"> </span><span class="o">&amp;</span><span class="n">parser</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">foo</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">printBar</span><span class="p">(</span><span class="n">AsmPrinter</span><span class="w"> </span><span class="o">&amp;</span><span class="n">printer</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">foo</span><span class="p">);</span>
</pre></div>
</div>
<p>More complex C++ types can be used with the <code class="docutils literal notranslate"><span class="pre">custom</span></code> directive. The only caveat
is that the parameter for the parser must use the storage type of the parameter.
For example, <code class="docutils literal notranslate"><span class="pre">StringRefParameter</span></code> expects the parser and printer signatures as:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">LogicalResult</span><span class="w"> </span><span class="nf">parseStringParam</span><span class="p">(</span><span class="n">AsmParser</span><span class="w"> </span><span class="o">&amp;</span><span class="n">parser</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">value</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">printStringParam</span><span class="p">(</span><span class="n">AsmPrinter</span><span class="w"> </span><span class="o">&amp;</span><span class="n">printer</span><span class="p">,</span><span class="w"> </span><span class="n">StringRef</span><span class="w"> </span><span class="n">value</span><span class="p">);</span>
</pre></div>
</div>
<p>The custom parser is considered to have failed if it returns failure or if any
bound parameters have failure values afterwards.</p>
<p>A string of C++ code can be used as a <code class="docutils literal notranslate"><span class="pre">custom</span></code> directive argument. When
generating the custom parser and printer call, the string is pasted as a
function argument. For example, <code class="docutils literal notranslate"><span class="pre">parseBar</span></code> and <code class="docutils literal notranslate"><span class="pre">printBar</span></code> can be re-used with
a constant integer:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>let parameters = (ins &quot;int&quot;:$bar);
let assemblyFormat = [{ custom&lt;Bar&gt;($foo, &quot;1&quot;) }];
</pre></div>
</div>
<p>The string is pasted verbatim but with substitutions for <code class="docutils literal notranslate"><span class="pre">$_builder</span></code> and
<code class="docutils literal notranslate"><span class="pre">$_ctxt</span></code>. String literals can be used to parameterize custom directives.</p>
</section>
</section>
</section>
</section>
<section id="verification">
<h3>Verification<a class="headerlink" href="#verification" title="此标题的永久链接">¶</a></h3>
<p>If the <code class="docutils literal notranslate"><span class="pre">genVerifyDecl</span></code> field is set, additional verification methods are
generated on the class.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">LogicalResult</span> <span class="pre">verify(function_ref&lt;InFlightDiagnostic()&gt;</span> <span class="pre">emitError,</span> <span class="pre">parameters...)</span></code></p></li>
</ul>
<p>These methods are used to verify the parameters provided to the attribute or
type class on construction, and emit any necessary diagnostics. This method is
automatically invoked from the builders of the attribute or type class.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">AttrOrType</span> <span class="pre">getChecked(function_ref&lt;InFlightDiagnostic()&gt;</span> <span class="pre">emitError,</span> <span class="pre">parameters...)</span></code></p></li>
</ul>
<p>As noted in the <a class="reference external" href="#Builders">Builders</a> section, these methods are companions to
<code class="docutils literal notranslate"><span class="pre">get</span></code> builders that are failable. If the <code class="docutils literal notranslate"><span class="pre">verify</span></code> invocation fails when these
methods are called, they return nullptr instead of asserting.</p>
</section>
<section id="storage-classes">
<h3>Storage Classes<a class="headerlink" href="#storage-classes" title="此标题的永久链接">¶</a></h3>
<p>Somewhat alluded to in the sections above is the concept of a “storage class”
(often abbreviated to “storage”). Storage classes contain all of the data
necessary to construct and unique a attribute or type instance. These classes
are the “immortal” objects that get uniqued within an MLIRContext and get
wrapped by the <code class="docutils literal notranslate"><span class="pre">Attribute</span></code> and <code class="docutils literal notranslate"><span class="pre">Type</span></code> classes. Every Attribute or Type class has
a corresponding storage class, that can be accessed via the protected
<code class="docutils literal notranslate"><span class="pre">getImpl()</span></code> method.</p>
<p>In most cases the storage class is auto generated, but if necessary it can be
manually defined by setting the <code class="docutils literal notranslate"><span class="pre">genStorageClass</span></code> field to 0. The name and
namespace (defaults to <code class="docutils literal notranslate"><span class="pre">detail</span></code>) can additionally be controlled via the The
<code class="docutils literal notranslate"><span class="pre">storageClass</span></code> and <code class="docutils literal notranslate"><span class="pre">storageNamespace</span></code> fields.</p>
<section id="defining-a-storage-class">
<h4>Defining a storage class<a class="headerlink" href="#defining-a-storage-class" title="此标题的永久链接">¶</a></h4>
<p>User defined storage classes must adhere to the following:</p>
<ul class="simple">
<li><p>Inherit from the base type storage class of <code class="docutils literal notranslate"><span class="pre">AttributeStorage</span></code> or
<code class="docutils literal notranslate"><span class="pre">TypeStorage</span></code> respectively.</p></li>
<li><p>Define a type alias, <code class="docutils literal notranslate"><span class="pre">KeyTy</span></code>, that maps to a type that uniquely identifies an
instance of the derived type. For example, this could be a <code class="docutils literal notranslate"><span class="pre">std::tuple</span></code> of all
of the storage parameters.</p></li>
<li><p>Provide a construction method that is used to allocate a new instance of the
storage class.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">Storage</span> <span class="pre">*construct(StorageAllocator</span> <span class="pre">&amp;allocator,</span> <span class="pre">const</span> <span class="pre">KeyTy</span> <span class="pre">&amp;key)</span></code></p></li>
</ul>
</li>
<li><p>Provide a comparison method between an instance of the storage and the
<code class="docutils literal notranslate"><span class="pre">KeyTy</span></code>.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">operator==(const</span> <span class="pre">KeyTy</span> <span class="pre">&amp;)</span> <span class="pre">const</span></code></p></li>
</ul>
</li>
<li><p>Provide a method to generate the <code class="docutils literal notranslate"><span class="pre">KeyTy</span></code> from a list of arguments passed to
the uniquer when building an Attribute or Type. (Note: This is only necessary
if the <code class="docutils literal notranslate"><span class="pre">KeyTy</span></code> cannot be default constructed from these arguments).</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">KeyTy</span> <span class="pre">getKey(Args...&amp;&amp;</span> <span class="pre">args)</span></code></p></li>
</ul>
</li>
<li><p>Provide a method to hash an instance of the <code class="docutils literal notranslate"><span class="pre">KeyTy</span></code>. (Note: This is not
necessary if an <code class="docutils literal notranslate"><span class="pre">llvm::DenseMapInfo&lt;KeyTy&gt;</span></code> specialization exists)</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">llvm::hash_code</span> <span class="pre">hashKey(const</span> <span class="pre">KeyTy</span> <span class="pre">&amp;)</span></code></p></li>
</ul>
</li>
<li><p>Provide a method to generate the <code class="docutils literal notranslate"><span class="pre">KeyTy</span></code> from an instance of the storage class.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">static</span> <span class="pre">KeyTy</span> <span class="pre">getAsKey()</span></code></p></li>
</ul>
</li>
</ul>
<p>Let’s look at an example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// Here we define a storage class for a ComplexType, that holds a non-zero</span>
<span class="c1">/// integer and an integer type.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">ComplexTypeStorage</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">TypeStorage</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">ComplexTypeStorage</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">nonZeroParam</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="n">integerType</span><span class="p">)</span>
<span class="w">      </span><span class="o">:</span><span class="w"> </span><span class="n">nonZeroParam</span><span class="p">(</span><span class="n">nonZeroParam</span><span class="p">),</span><span class="w"> </span><span class="n">integerType</span><span class="p">(</span><span class="n">integerType</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>

<span class="w">  </span><span class="c1">/// The hash key for this storage is a pair of the integer and type params.</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">KeyTy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">  </span><span class="c1">/// Define the comparison function for the key type.</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">KeyTy</span><span class="w"> </span><span class="o">&amp;</span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">KeyTy</span><span class="p">(</span><span class="n">nonZeroParam</span><span class="p">,</span><span class="w"> </span><span class="n">integerType</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">/// Define a hash function for the key type.</span>
<span class="w">  </span><span class="c1">/// Note: This isn&#39;t necessary because std::pair, unsigned, and Type all have</span>
<span class="w">  </span><span class="c1">/// hash functions already available.</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">hash_code</span><span class="w"> </span><span class="n">hashKey</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">KeyTy</span><span class="w"> </span><span class="o">&amp;</span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">hash_combine</span><span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">/// Define a construction function for the key type.</span>
<span class="w">  </span><span class="c1">/// Note: This isn&#39;t necessary because KeyTy can be directly constructed with</span>
<span class="w">  </span><span class="c1">/// the given parameters.</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">KeyTy</span><span class="w"> </span><span class="n">getKey</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">nonZeroParam</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="n">integerType</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">KeyTy</span><span class="p">(</span><span class="n">nonZeroParam</span><span class="p">,</span><span class="w"> </span><span class="n">integerType</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">/// Define a construction method for creating a new instance of this storage.</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">ComplexTypeStorage</span><span class="w"> </span><span class="o">*</span><span class="n">construct</span><span class="p">(</span><span class="n">StorageAllocator</span><span class="w"> </span><span class="o">&amp;</span><span class="n">allocator</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">KeyTy</span><span class="w"> </span><span class="o">&amp;</span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="p">(</span><span class="n">allocator</span><span class="p">.</span><span class="n">allocate</span><span class="o">&lt;</span><span class="n">ComplexTypeStorage</span><span class="o">&gt;</span><span class="p">())</span>
<span class="w">        </span><span class="n">ComplexTypeStorage</span><span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">first</span><span class="p">,</span><span class="w"> </span><span class="n">key</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">/// Construct an instance of the key from this storage class.</span>
<span class="w">  </span><span class="n">KeyTy</span><span class="w"> </span><span class="n">getAsKey</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">KeyTy</span><span class="p">(</span><span class="n">nonZeroParam</span><span class="p">,</span><span class="w"> </span><span class="n">integerType</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">/// The parametric data held by the storage class.</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">nonZeroParam</span><span class="p">;</span>
<span class="w">  </span><span class="n">Type</span><span class="w"> </span><span class="n">integerType</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
</section>
<section id="mutable-attributes-and-types">
<h3>Mutable attributes and types<a class="headerlink" href="#mutable-attributes-and-types" title="此标题的永久链接">¶</a></h3>
<p>Attributes and Types are immutable objects uniqued within an MLIRContext. That
being said, some parameters may be treated as “mutable” and modified after
construction. Mutable parameters should be reserved for parameters that can not
be reasonably initialized during construction time. Given the mutable component,
these parameters do not take part in the uniquing of the Attribute or Type.</p>
<p>TODO: Mutable parameters are currently not supported in the declarative
specification of attributes and types, and thus requires defining the Attribute
or Type class in C++.</p>
<section id="defining-a-mutable-storage">
<h4>Defining a mutable storage<a class="headerlink" href="#defining-a-mutable-storage" title="此标题的永久链接">¶</a></h4>
<p>In addition to the base requirements for a storage class, instances with a
mutable component must additionally adhere to the following:</p>
<ul class="simple">
<li><p>The mutable component must not participate in the storage <code class="docutils literal notranslate"><span class="pre">KeyTy</span></code>.</p></li>
<li><p>Provide a mutation method that is used to modify an existing instance of the
storage. This method modifies the mutable component based on arguments, using
<code class="docutils literal notranslate"><span class="pre">allocator</span></code> for any newly dynamically-allocated storage, and indicates whether
the modification was successful.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">LogicalResult</span> <span class="pre">mutate(StorageAllocator</span> <span class="pre">&amp;allocator,</span> <span class="pre">Args</span> <span class="pre">...&amp;&amp;</span> <span class="pre">args)</span></code></p></li>
</ul>
</li>
</ul>
<p>Let’s define a simple storage for recursive types, where a type is identified by
its name and may contain another type including itself.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// Here we define a storage class for a RecursiveType that is identified by its</span>
<span class="c1">/// name and contains another type.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">RecursiveTypeStorage</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">TypeStorage</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">/// The type is uniquely identified by its name. Note that the contained type</span>
<span class="w">  </span><span class="c1">/// is _not_ a part of the key.</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">KeyTy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">StringRef</span><span class="p">;</span>

<span class="w">  </span><span class="c1">/// Construct the storage from the type name. Explicitly initialize the</span>
<span class="w">  </span><span class="c1">/// containedType to nullptr, which is used as marker for the mutable</span>
<span class="w">  </span><span class="c1">/// component being not yet initialized.</span>
<span class="w">  </span><span class="n">RecursiveTypeStorage</span><span class="p">(</span><span class="n">StringRef</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">name</span><span class="p">(</span><span class="n">name</span><span class="p">),</span><span class="w"> </span><span class="n">containedType</span><span class="p">(</span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>

<span class="w">  </span><span class="c1">/// Define the comparison function.</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">KeyTy</span><span class="w"> </span><span class="o">&amp;</span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">name</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">  </span><span class="c1">/// Define a construction method for creating a new instance of the storage.</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">RecursiveTypeStorage</span><span class="w"> </span><span class="o">*</span><span class="n">construct</span><span class="p">(</span><span class="n">StorageAllocator</span><span class="w"> </span><span class="o">&amp;</span><span class="n">allocator</span><span class="p">,</span>
<span class="w">                                         </span><span class="k">const</span><span class="w"> </span><span class="n">KeyTy</span><span class="w"> </span><span class="o">&amp;</span><span class="n">key</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Note that the key string is copied into the allocator to ensure it</span>
<span class="w">    </span><span class="c1">// remains live as long as the storage itself.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="p">(</span><span class="n">allocator</span><span class="p">.</span><span class="n">allocate</span><span class="o">&lt;</span><span class="n">RecursiveTypeStorage</span><span class="o">&gt;</span><span class="p">())</span>
<span class="w">        </span><span class="n">RecursiveTypeStorage</span><span class="p">(</span><span class="n">allocator</span><span class="p">.</span><span class="n">copyInto</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">/// Define a mutation method for changing the type after it is created. In</span>
<span class="w">  </span><span class="c1">/// many cases, we only want to set the mutable component once and reject</span>
<span class="w">  </span><span class="c1">/// any further modification, which can be achieved by returning failure from</span>
<span class="w">  </span><span class="c1">/// this function.</span>
<span class="w">  </span><span class="n">LogicalResult</span><span class="w"> </span><span class="n">mutate</span><span class="p">(</span><span class="n">StorageAllocator</span><span class="w"> </span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="n">body</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// If the contained type has been initialized already, and the call tries</span>
<span class="w">    </span><span class="c1">// to change it, reject the change.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">containedType</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">containedType</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">body</span><span class="p">)</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">failure</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Change the body successfully.</span>
<span class="w">    </span><span class="n">containedType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">body</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">success</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">StringRef</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">  </span><span class="n">Type</span><span class="w"> </span><span class="n">containedType</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="type-class-definition">
<h4>Type class definition<a class="headerlink" href="#type-class-definition" title="此标题的永久链接">¶</a></h4>
<p>Having defined the storage class, we can define the type class itself.
<code class="docutils literal notranslate"><span class="pre">Type::TypeBase</span></code> provides a <code class="docutils literal notranslate"><span class="pre">mutate</span></code> method that forwards its arguments to the
<code class="docutils literal notranslate"><span class="pre">mutate</span></code> method of the storage and ensures the mutation happens safely.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">RecursiveType</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Type</span><span class="o">::</span><span class="n">TypeBase</span><span class="o">&lt;</span><span class="n">RecursiveType</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="p">,</span>
<span class="w">                                            </span><span class="n">RecursiveTypeStorage</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="c1">/// Inherit parent constructors.</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">Base</span><span class="o">::</span><span class="n">Base</span><span class="p">;</span>

<span class="w">  </span><span class="c1">/// Creates an instance of the Recursive type. This only takes the type name</span>
<span class="w">  </span><span class="c1">/// and returns the type with uninitialized body.</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="n">RecursiveType</span><span class="w"> </span><span class="nf">get</span><span class="p">(</span><span class="n">MLIRContext</span><span class="w"> </span><span class="o">*</span><span class="n">ctx</span><span class="p">,</span><span class="w"> </span><span class="n">StringRef</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Call into the base to get a uniqued instance of this type. The parameter</span>
<span class="w">    </span><span class="c1">// (name) is passed after the context.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Base</span><span class="o">::</span><span class="n">get</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">/// Now we can change the mutable component of the type. This is an instance</span>
<span class="w">  </span><span class="c1">/// method callable on an already existing RecursiveType.</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">setBody</span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="n">body</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Call into the base to mutate the type.</span>
<span class="w">    </span><span class="n">LogicalResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Base</span><span class="o">::</span><span class="n">mutate</span><span class="p">(</span><span class="n">body</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Most types expect the mutation to always succeed, but types can implement</span>
<span class="w">    </span><span class="c1">// custom logic for handling mutation failures.</span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">succeeded</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">           </span><span class="s">&quot;attempting to change the body of an already-initialized type&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Avoid unused-variable warning when building without assertions.</span>
<span class="w">    </span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">/// Returns the contained type, which may be null if it has not been</span>
<span class="w">  </span><span class="c1">/// initialized yet.</span>
<span class="w">  </span><span class="n">Type</span><span class="w"> </span><span class="nf">getBody</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">getImpl</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">containedType</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">  </span><span class="c1">/// Returns the name.</span>
<span class="w">  </span><span class="n">StringRef</span><span class="w"> </span><span class="nf">getName</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">getImpl</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
</section>
<section id="extra-declarations">
<h3>Extra declarations<a class="headerlink" href="#extra-declarations" title="此标题的永久链接">¶</a></h3>
<p>The declarative Attribute and Type definitions try to auto-generate as much
logic and methods as possible. With that said, there will always be long-tail
cases that won’t be covered. For such cases, <code class="docutils literal notranslate"><span class="pre">extraClassDeclaration</span></code> and
<code class="docutils literal notranslate"><span class="pre">extraClassDefinition</span></code> can be used. Code within the <code class="docutils literal notranslate"><span class="pre">extraClassDeclaration</span></code>
field will be copied literally to the generated C++ Attribute or Type class.
Code within <code class="docutils literal notranslate"><span class="pre">extraClassDefinition</span></code> will be added to the generated source file
inside the class’s C++ namespace. The substitution <code class="docutils literal notranslate"><span class="pre">$cppClass</span></code> will be replaced
by the Attribute or Type’s C++ class name.</p>
<p>Note that these are mechanisms intended for long-tail cases by power users; for
not-yet-implemented widely-applicable cases, improving the infrastructure is
preferable.</p>
</section>
<section id="registering-with-the-dialect">
<h3>Registering with the Dialect<a class="headerlink" href="#registering-with-the-dialect" title="此标题的永久链接">¶</a></h3>
<p>Once the attributes and types have been defined, they must then be registered
with the parent <code class="docutils literal notranslate"><span class="pre">Dialect</span></code>. This is done via the <code class="docutils literal notranslate"><span class="pre">addAttributes</span></code> and <code class="docutils literal notranslate"><span class="pre">addTypes</span></code>
methods. Note that when registering, the full definition of the storage classes
must be visible.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">MyDialect::initialize</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">/// Add the defined attributes to the dialect.</span>
<span class="w">  </span><span class="n">addAttributes</span><span class="o">&lt;</span>
<span class="cp">#define GET_ATTRDEF_LIST</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;MyDialect/Attributes.cpp.inc&quot;</span>
<span class="w">  </span><span class="o">&gt;</span><span class="p">();</span>

<span class="w">    </span><span class="c1">/// Add the defined types to the dialect.</span>
<span class="w">  </span><span class="n">addTypes</span><span class="o">&lt;</span>
<span class="cp">#define GET_TYPEDEF_LIST</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;MyDialect/Types.cpp.inc&quot;</span>
<span class="w">  </span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
</section>


          </div>
          <div class="page-nav">
            <div class="inner"><ul class="page-nav">
</ul><div class="footer" role="contentinfo">
      &#169; 版权所有 2023, yaoyue123.
    <br>
    Created using <a href="http://sphinx-doc.org/">Sphinx</a> 6.1.3 with <a href="https://github.com/schettino72/sphinx_press_theme">Press Theme</a> 0.8.0.
</div>
            </div>
          </div>
      </page>
    </div></div>
    
    
  </body>
</html>