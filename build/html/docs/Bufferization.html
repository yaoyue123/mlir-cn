<!DOCTYPE html>
<html  lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

      <title>Bufferization</title>
    
          <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
          <link rel="stylesheet" href="../_static/theme.css " type="text/css" />
      
      <!-- sphinx script_files -->
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script src="../_static/translations.js"></script>

      
      <!-- bundled in js (rollup iife) -->
      <!-- <script src="../_static/theme-vendors.js"></script> -->
      <script src="../_static/theme.js" defer></script>
    
  <link rel="index" title="索引" href="../genindex.html" />
  <link rel="search" title="搜索" href="../search.html" /> 
  </head>

  <body>
    <div id="app">
    <div class="theme-container" :class="pageClasses"><navbar @toggle-sidebar="toggleSidebar">
  <router-link to="../index.html" class="home-link">
    
      <span class="site-name">MLIR 中文文档</span>
    
  </router-link>

  <div class="links">
    <navlinks class="can-hide">



    </navlinks>
  </div>
</navbar>

      
      <div class="sidebar-mask" @click="toggleSidebar(false)">
      </div>
        <sidebar @toggle-sidebar="toggleSidebar">
          
          <navlinks>
            



            
          </navlinks><div id="searchbox" class="searchbox" role="search">
  <div class="caption"><span class="caption-text">快速搜索</span>
    <div class="searchformwrapper">
      <form class="search" action="../search.html" method="get">
        <input type="text" name="q" />
        <input type="submit" value="搜索" />
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div><div class="sidebar-links" role="navigation" aria-label="main navigation">
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../index.html#mlir">欢迎使用 mlir 中文文档</a></span>
      </p>
      <ul class="">
        
          <li class="toctree-l1 ">
            
              <a href="../_index.html" class="reference internal ">开始使用</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/CreatingADialect.html" class="reference internal ">Creating a Dialect</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/DataFlowAnalysis.html" class="reference internal ">Writing DataFlow Analyses in MLIR</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/QuickstartRewrites.html" class="reference internal ">Quickstart tutorial to adding MLIR graph rewrite</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-1.html" class="reference internal ">Chapter 1: Toy Language and AST</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-2.html" class="reference internal ">Chapter 2: Emitting Basic MLIR</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-3.html" class="reference internal ">Chapter 3: High-level Language-Specific Analysis and Transformation</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-4.html" class="reference internal ">Chapter 4: Enabling Generic Transformation with Interfaces</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-5.html" class="reference internal ">Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-6.html" class="reference internal ">Chapter 6: Lowering to LLVM and CodeGeneration</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-7.html" class="reference internal ">Chapter 7: Adding a Composite Type to Toy</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/_index.html" class="reference internal ">Toy Tutorial</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/UnderstandingTheIRStructure.html" class="reference internal ">Understanding the IR Structure</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/_index.html" class="reference internal ">Tutorials</a>
            

            
          </li>

        
      </ul>
    </div>
  
</div>
        </sidebar>

      <page>
          <div class="body-header" role="navigation" aria-label="navigation">
  
  <ul class="breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
    
    <li>Bufferization</li>
  </ul>
  

  <ul class="page-nav">
</ul>
  
</div>
<hr>
          <div class="content" role="main" v-pre>
            
  <section id="bufferization">
<h1>Bufferization<a class="headerlink" href="#bufferization" title="此标题的永久链接">¶</a></h1>
<p>[TOC]</p>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="此标题的永久链接">¶</a></h2>
<p>Bufferization in MLIR is the process of converting ops with <code class="docutils literal notranslate"><span class="pre">tensor</span></code> semantics
to ops with <code class="docutils literal notranslate"><span class="pre">memref</span></code> semantics. MLIR provides an infrastructure that bufferizes
an entire program in a single pass (<em>One-Shot Bufferize</em>). This infrastructure
bufferizes all ops that implement the
<a class="reference external" href="https://github.com/llvm/llvm-project/blob/17a68065c378da74805e4e1b9a5b78cc9f83e580/mlir/include/mlir/Dialect/Bufferization/IR/BufferizableOpInterface.td"><code class="docutils literal notranslate"><span class="pre">BufferizableOpInterface</span></code></a>
can be bufferized.</p>
<p>MLIR has an older bufferization infrastructure built around
<a class="reference internal" href="DialectConversion.html"><span class="doc">dialect conversion</span></a>. Most dialect conversion
bufferization patterns have been migrated to One-Shot Bufferize, but some
functionality such as function boundary bufferization still depends on dialect
conversion and its type converter. New projects should use One-Shot Bufferize,
as the dialect conversion-based bufferization will eventually be deprecated.
Moreover, One-Shot Bufferize results in better bufferization with fewer memory
allocations and buffer copies. This documentation is mostly about One-Shot
Bufferize, but also describes how to gradually migrate a project from dialect
conversion-based bufferization to One-Shot Bufferize.</p>
</section>
<section id="what-is-one-shot-bufferize">
<h2>What is One-Shot Bufferize?<a class="headerlink" href="#what-is-one-shot-bufferize" title="此标题的永久链接">¶</a></h2>
<p>One-Shot Bufferize is a new tensor bufferization pass designed for IR in
<a class="reference external" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/11/dps-fhpc17.pdf">destination-passing style</a>,
and with aggressive in-place bufferization.</p>
<p>One-Shot Bufferize is:</p>
<ul class="simple">
<li><p><strong>Monolithic</strong>: A single MLIR pass does the entire work, whereas the
previous bufferization in MLIR was split across multiple passes residing in
different dialects. In One-Shot Bufferize, <code class="docutils literal notranslate"><span class="pre">BufferizableOpInterface</span></code>
implementations are spread across different dialects.</p></li>
<li><p>A <strong>whole-function at a time analysis</strong>. In-place bufferization decisions
are made by analyzing SSA use-def chains on tensors. Op interface
implementations not only provide the rewrite logic from tensor ops to memref
ops, but also helper methods for One-Shot Bufferize’s analysis to query
information about an op’s bufferization/memory semantics.</p></li>
<li><p><strong>Extensible</strong> via an op interface: All ops that implement
<code class="docutils literal notranslate"><span class="pre">BufferizableOpInterface</span></code> can be bufferized.</p></li>
<li><p><strong>2-Pass</strong>: Bufferization is internally broken down into 2 steps: First,
analyze the entire IR and make bufferization decisions. Then, bufferize
(rewrite) the IR. The analysis has access to exact SSA use-def information.
It incrementally builds alias and equivalence sets and does not rely on a
posteriori-alias analysis from preallocated memory.</p></li>
<li><p><strong>Greedy</strong>: Operations are analyzed one-by-one and it is decided on the spot
whether a tensor OpOperand must be copied or not. Heuristics determine the
order of analysis.</p></li>
<li><p><strong>Modular</strong>: The current One-Shot Analysis can be replaced with a different
analysis. The result of the analysis are queried by the bufferization via
<code class="docutils literal notranslate"><span class="pre">AnalysisState</span></code>, in particular <code class="docutils literal notranslate"><span class="pre">AnalysisState::isInPlace</span></code>. Any derived class
of <code class="docutils literal notranslate"><span class="pre">AnalysisState</span></code> that implements a small number virtual functions can
serve as a custom analysis. It is even possible to run One-Shot Bufferize
without any analysis (<code class="docutils literal notranslate"><span class="pre">AlwaysCopyAnalysisState</span></code>), in which case One-Shot
Bufferize behaves exactly like the old dialect conversion-based
bufferization (i.e., copy every buffer before writing to it).</p></li>
</ul>
<p>To reduce complexity, One-Shot Bufferize should be
<a class="reference external" href="https://llvm.discourse.group/t/rfc-linalg-on-tensors-update-and-comprehensive-bufferization-rfc/3373">run after other transformations</a>,
typically as one of the last steps right before lowering memref ops. Many
transformations are easier in tensor land; e.g., tile/fuse/… on tensors first,
then bufferize the remaining IR.</p>
<p>From an architecture perspective, One-Shot Bufferize consists of
<a class="reference external" href="https://github.com/llvm/llvm-project/blob/17a68065c378da74805e4e1b9a5b78cc9f83e580/mlir/include/mlir/Dialect/Bufferization/IR/BufferizableOpInterface.td">BufferizableOpInterface</a>
(and its implementations) and an
<a class="reference external" href="https://github.com/llvm/llvm-project/blob/ae2764e835a26bad9774803eca0a6530df2a3e2d/mlir/include/mlir/Dialect/Bufferization/Transforms/OneShotAnalysis.h#L164">analysis</a>
of tensor SSA values that decides if a buffer can be used directly or must be
copied. The [bufferize] method of the op interface inspects analysis results and
rewrites tensor ops into memref ops.</p>
</section>
<section id="goals-of-bufferization">
<h2>Goals of Bufferization<a class="headerlink" href="#goals-of-bufferization" title="此标题的永久链接">¶</a></h2>
<p>The high-level goal of every bufferization technique is to: 1. Use as little
memory as possible. 2. Copy as little memory as possible.</p>
<p>This implies reusing already allocated buffers when possible, turning
bufferization into an algorithmically complex problem with similarities to
register allocation.</p>
<p>Depending on the concrete use case, there may be additional bufferization
requirements. If the contents of a buffer are expensive to compute, there could
be a tradeoff between <em>recomputation</em> and <em>compute once and copy</em>. On the
contrary, it may not even be possible to allocate new buffers at runtime on some
architectures.</p>
</section>
<section id="destination-passing-style">
<h2>Destination-Passing Style<a class="headerlink" href="#destination-passing-style" title="此标题的永久链接">¶</a></h2>
<p>Bufferization is an algorithmically complex problem. Given an op with a tensor
result, bufferization has to choose a memref buffer in which the result can be
stored. It is always safe to allocate a brand new buffer, but such a
bufferization strategy would be unacceptable for high-performance codegen. When
choosing an already existing buffer, we must be careful not to accidentally
overwrite data that is still needed later in the program.</p>
<p>To simplify this problem, One-Shot Bufferize was designed for ops that are in
<em>destination-passing style</em>. For every tensor result, such ops have a tensor
operand, who’s buffer could be for storing the result of the op in the absence
of other conflicts. We call such tensor operands the <em>destination</em>.</p>
<p>As an example, consider the following op: <code class="docutils literal notranslate"><span class="pre">%0</span> <span class="pre">=</span> <span class="pre">tensor.insert</span> <span class="pre">%cst</span> <span class="pre">into</span> <span class="pre">%t[%idx]</span> <span class="pre">:</span> <span class="pre">tensor&lt;?xf32&gt;</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">%t</span></code> is the destination in this example. When choosing a buffer for the result
<code class="docutils literal notranslate"><span class="pre">%0</span></code>, One-Shot Bufferize considers only two options:</p>
<ol class="simple">
<li><p>buffer(<code class="docutils literal notranslate"><span class="pre">%0</span></code>) = buffer(<code class="docutils literal notranslate"><span class="pre">%t</span></code>).</p></li>
<li><p>buffer(<code class="docutils literal notranslate"><span class="pre">%0</span></code>) is a newly allocated buffer.</p></li>
</ol>
<p>There may be other buffers in the same function that could potentially be used
for buffer(<code class="docutils literal notranslate"><span class="pre">%0</span></code>), but those are not considered by One-Shot Bufferize to keep the
bufferization simple. One-Shot Bufferize could be extended to consider such
buffers in the future to achieve a better quality of bufferization.</p>
<p>Tensor ops that are not in destination-passing style always bufferize to a
memory allocation. E.g.:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>%0 = tensor.generate %sz {
^bb0(%i : index):
  %cst = arith.constant 0.0 : f32
  tensor.yield %cst : f32
} : tensor&lt;?xf32&gt;
</pre></div>
</div>
<p>The result of <code class="docutils literal notranslate"><span class="pre">tensor.generate</span></code> does not have a “destination”, so bufferization
allocates a new buffer. This could be avoided by choosing an op such as
<code class="docutils literal notranslate"><span class="pre">linalg.generic</span></code>, which can express the same computation with a destination
(”out”) tensor:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>#map = affine_map&lt;(i) -&gt; (i)&gt;
%0 = linalg.generic {indexing_maps = [#map], iterator_types = [&quot;parallel&quot;]}
                    outs(%t : tensor&lt;?xf32&gt;) {
  ^bb0(%arg0 : f32):
    %cst = arith.constant 0.0 : f32
    linalg.yield %cst : f32
} -&gt; tensor&lt;?xf32&gt;
</pre></div>
</div>
<p>At first glance, the above <code class="docutils literal notranslate"><span class="pre">linalg.generic</span></code> op may not seem very useful because
the output tensor <code class="docutils literal notranslate"><span class="pre">%t</span></code> is entirely overwritten. Why pass the tensor <code class="docutils literal notranslate"><span class="pre">%t</span></code> as an
operand in the first place? As an example, this can be useful for overwriting a
slice of a tensor:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>%t = tensor.extract_slice %s [%idx] [%sz] [1] : tensor&lt;?xf32&gt; to tensor&lt;?xf32&gt;
%0 = linalg.generic ... outs(%t) { ... } -&gt; tensor&lt;?xf32&gt;
%1 = tensor.insert_slice %0 into %s [%idx] [%sz] [1]
    : tensor&lt;?xf32&gt; into tensor&lt;?xf32&gt;
</pre></div>
</div>
<p>The above example bufferizes to a <code class="docutils literal notranslate"><span class="pre">memref.subview</span></code>, followed by a
“<code class="docutils literal notranslate"><span class="pre">linalg.generic</span></code> on memrefs” that overwrites the memory of the subview. The
<code class="docutils literal notranslate"><span class="pre">tensor.insert_slice</span></code> bufferizes to a no-op (in the absence of RaW conflicts
such as a subsequent read of <code class="docutils literal notranslate"><span class="pre">%s</span></code>).</p>
<p>RaW conflicts are detected with an analysis of SSA use-def chains (details
later). One-Shot Bufferize works best if there is a single SSA use-def chain,
where the result of a tensor op is the “destination” operand of the next tensor
ops, e.g.:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>%0 = &quot;my_dialect.some_op&quot;(%t) : (tensor&lt;?xf32&gt;) -&gt; (tensor&lt;?xf32&gt;)
%1 = &quot;my_dialect.another_op&quot;(%0) : (tensor&lt;?xf32&gt;) -&gt; (tensor&lt;?xf32&gt;)
%2 = &quot;my_dialect.yet_another_op&quot;(%1) : (tensor&lt;?xf32&gt;) -&gt; (tensor&lt;?xf32&gt;)
</pre></div>
</div>
<p>Buffer copies are likely inserted if the SSA use-def chain splits at some point,
e.g.:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>%0 = &quot;my_dialect.some_op&quot;(%t) : (tensor&lt;?xf32&gt;) -&gt; (tensor&lt;?xf32&gt;)
%1 = &quot;my_dialect.another_op&quot;(%0) : (tensor&lt;?xf32&gt;) -&gt; (tensor&lt;?xf32&gt;)
%2 = &quot;my_dialect.yet_another_op&quot;(%0) : (tensor&lt;?xf32&gt;) -&gt; (tensor&lt;?xf32&gt;)
</pre></div>
</div>
<p>One-Shot Bufferize has debug flags (<code class="docutils literal notranslate"><span class="pre">test-analysis-only</span> <span class="pre">print-conflicts</span></code>) that
print the results of the analysis and explain to the user why buffer copies were
inserted.</p>
</section>
<section id="using-one-shot-bufferize">
<h2>Using One-Shot Bufferize<a class="headerlink" href="#using-one-shot-bufferize" title="此标题的永久链接">¶</a></h2>
<p>MLIR provides a pass
<a class="reference external" href="https://mlir.llvm.org/docs/Passes/#-one-shot-bufferize-one-shot-bufferize"><code class="docutils literal notranslate"><span class="pre">-one-shot-bufferize</span></code></a>
that performs an analysis and bufferizes all ops with tensor semantics that
implement <code class="docutils literal notranslate"><span class="pre">BufferizableOpInterface</span></code>. For modularity reasons, these op interface
implementations are typically external models that live in a dialect’s
“Transforms” build unit. (External models are a mechanism for implementing an op
interface in a different build unit.) It is the user’s responsibility to ensure
that all needed external models are registered before running One-Shot
Bufferize.</p>
<p>By default, One-Shot Bufferize fails when it encounters an op with tensor
semantics (i.e., tensor result or tensor operand) that is not bufferizable
(i.e., does not implement <code class="docutils literal notranslate"><span class="pre">BufferizableOpInterface</span></code>). This can be avoided with
<code class="docutils literal notranslate"><span class="pre">allow-unknown-ops</span></code>. In that case, One-Shot Bufferize inserts
<code class="docutils literal notranslate"><span class="pre">to_memref</span></code>/<code class="docutils literal notranslate"><span class="pre">to_tensor</span></code> ops around the bufferization boundary. These ops are
named versions of <code class="docutils literal notranslate"><span class="pre">unrealized_conversion_cast</span></code>. Note that One-Shot Bufferize’s
analysis can currently not analyze these ops, so input IR with such ops may fail
bufferization. Therefore, running One-Shot Bufferize multiple times in a
sequence is also not supported at the moment.</p>
<p>One-Shot Bufferize can be configured to bufferize only ops from a set of
dialects with <code class="docutils literal notranslate"><span class="pre">dialect-filter</span></code>. This can be useful for gradually migrating from
dialect conversion-based bufferization to One-Shot Bufferize. One-Shot Bufferize
must run first in such a case, because dialect conversion-based bufferization
generates <code class="docutils literal notranslate"><span class="pre">to_tensor</span></code>/<code class="docutils literal notranslate"><span class="pre">to_memref</span></code> ops which One-Shot Bufferize cannot analyze.</p>
<p>One-Shot Bufferize can also be called programmatically with
<a class="reference external" href="https://github.com/llvm/llvm-project/blob/ae2764e835a26bad9774803eca0a6530df2a3e2d/mlir/include/mlir/Dialect/Bufferization/Transforms/OneShotAnalysis.h#L167"><code class="docutils literal notranslate"><span class="pre">bufferization::runOneShotBufferize</span></code></a>.
Alternatively,
<a class="reference external" href="https://github.com/llvm/llvm-project/blob/ae2764e835a26bad9774803eca0a6530df2a3e2d/mlir/include/mlir/Dialect/Bufferization/Transforms/Bufferize.h#L78"><code class="docutils literal notranslate"><span class="pre">bufferization::bufferizeOp</span></code></a>
skips the analysis and inserts a copy on every buffer write, just like the
dialect conversion-based bufferization.</p>
</section>
<section id="buffer-deallocation">
<h2>Buffer Deallocation<a class="headerlink" href="#buffer-deallocation" title="此标题的永久链接">¶</a></h2>
<p>One-Shot Bufferize deallocates all buffers that it allocates. This is in
contrast to the dialect conversion-based bufferization that delegates this job
to the
<a class="reference external" href="https://mlir.llvm.org/docs/Passes/#-buffer-deallocation-adds-all-required-dealloc-operations-for-all-allocations-in-the-input-program"><code class="docutils literal notranslate"><span class="pre">-buffer-deallocation</span></code></a>
pass. By default, One-Shot Bufferize rejects IR where a newly allocated buffer
is returned from a block. Such IR will fail bufferization.</p>
<p>A new buffer allocation is returned from a block when the result of an op that
is not in destination-passing style is returned. E.g.:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>%0 = scf.if %c -&gt; (tensor&lt;?xf32&gt;) {
  %1 = tensor.generate ... -&gt; tensor&lt;?xf32&gt;
  scf.yield %1 : tensor&lt;?xf32&gt;
} else {
  scf.yield %another_tensor : tensor&lt;?xf32&gt;
}
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">scf.yield</span></code> in the “else” branch is OK, but the <code class="docutils literal notranslate"><span class="pre">scf.yield</span></code> in the “then”
branch will be rejected.</p>
<p>Another case in which a buffer allocation may be returned is when a buffer copy
must be inserted due to a RaW conflict. E.g.:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>%0 = scf.if %c -&gt; (tensor&lt;?xf32&gt;) {
  %1 = tensor.insert %cst into %another_tensor[%idx] : tensor&lt;?xf32&gt;
  &quot;my_dialect.reading_tensor_op&quot;(%another_tensor) : (tensor&lt;?xf32&gt;) -&gt; ()
  ...
  scf.yield %1 : tensor&lt;?xf32&gt;
} else {
  scf.yield %yet_another_tensor : tensor&lt;?xf32&gt;
}
</pre></div>
</div>
<p>In the above example, a buffer copy of buffer(<code class="docutils literal notranslate"><span class="pre">%another_tensor</span></code>) (with <code class="docutils literal notranslate"><span class="pre">%cst</span></code>
inserted) is yielded from the “then” branch.</p>
<p>In both examples, a buffer is allocated inside of a block and then yielded from
the block. Deallocation of such buffers is tricky and not currently implemented
in an efficient way. For this reason, One-Shot Bufferize must be explicitly
configured with <code class="docutils literal notranslate"><span class="pre">allow-return-allocs</span></code> to support such IR.</p>
<p>When running with <code class="docutils literal notranslate"><span class="pre">allow-return-allocs</span></code>, One-Shot Bufferize may introduce
allocations that cannot be deallocated by One-Shot Bufferize yet. For that
reason, <code class="docutils literal notranslate"><span class="pre">-buffer-deallocation</span></code> must be run after One-Shot Bufferize. This buffer
deallocation pass resolves yields of newly allocated buffers with copies. E.g.,
the <code class="docutils literal notranslate"><span class="pre">scf.if</span></code> example above would bufferize to IR similar to the following:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>%0 = scf.if %c -&gt; (memref&lt;?xf32&gt;) {
  %1 = memref.alloc(...) : memref&lt;?xf32&gt;
  ...
  scf.yield %1 : memref&lt;?xf32&gt;
} else {
  %2 = memref.alloc(...) : memref&lt;?xf32&gt;
  memref.copy %another_memref, %2
  scf.yield %2 : memref&lt;?xf32&gt;
}
</pre></div>
</div>
<p>In the bufferized IR, both branches return a newly allocated buffer, so it does
not matter which if-branch was taken. In both cases, the resulting buffer <code class="docutils literal notranslate"><span class="pre">%0</span></code>
must be deallocated at some point after the <code class="docutils literal notranslate"><span class="pre">scf.if</span></code> (unless the <code class="docutils literal notranslate"><span class="pre">%0</span></code> is
returned/yielded from its block).</p>
<p>Note: Buffer allocations that are returned from a function are not deallocated,
not even with <code class="docutils literal notranslate"><span class="pre">-buffer-deallocation</span></code>. It is the caller’s responsibility to
deallocate the buffer. In the future, this could be automated with allocation
hoisting (across function boundaries) or reference counting.</p>
<p>One-Shot Bufferize can be configured to leak all memory and not generate any
buffer deallocations with <code class="docutils literal notranslate"><span class="pre">create-deallocs=0</span></code>. This can be useful for
compatibility with legacy code that has its own method of deallocating buffers.</p>
</section>
<section id="memory-layouts">
<h2>Memory Layouts<a class="headerlink" href="#memory-layouts" title="此标题的永久链接">¶</a></h2>
<p>One-Shot Bufferize bufferizes ops from top to bottom. This works well when all
ops are bufferizable. However, when encountering a non-bufferizable tensor with
<code class="docutils literal notranslate"><span class="pre">allow-unknown-ops</span></code>, One-Shot Bufferize must insert <code class="docutils literal notranslate"><span class="pre">to_memref</span></code> ops at the
bufferization boundary and decide on a memref type. By default, One-Shot
Bufferize choose the most dynamic memref type wrt. layout maps. E.g.:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>%0 = &quot;my_dialect.unbufferizable_op(%t) : (tensor&lt;?x?xf32&gt;) -&gt; (tensor&lt;?x?xf32&gt;)
%1 = tensor.extract %0[%idx1, %idx2] : tensor&lt;?xf32&gt;
</pre></div>
</div>
<p>When bufferizing the above IR, One-Shot Bufferize inserts a <code class="docutils literal notranslate"><span class="pre">to_memref</span></code> ops with
dynamic offset and strides:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>%0 = &quot;my_dialect.unbufferizable_op(%t) : (tensor&lt;?x?xf32&gt;) -&gt; (tensor&lt;?x?xf32&gt;)
%0_m = bufferization.to_memref %0 : memref&lt;?x?xf32, strided&lt;[?, ?], offset: ?&gt;&gt;
%1 = memref.load %0_m[%idx1, %idx2] : memref&lt;?x?xf32, strided&lt;[?, ?], offset: ?&gt;&gt;
</pre></div>
</div>
<p>All users of <code class="docutils literal notranslate"><span class="pre">%0</span></code> have fully dynamic layout maps. This ensures that the
bufferized IR composes well with future bufferizations of <code class="docutils literal notranslate"><span class="pre">unbufferizable_op</span></code>
(maybe bufferized by another pass), regardless of the exact memref type of the
future bufferization. If the op turns out to be bufferized to an op with a
simpler memref type (e.g., identity layout map), we expect that canonicalization
patterns would clean up unnecessarily dynamic layout maps. (Some of these
canonicalization patterns may not be implemented yet.)</p>
<p>One-Shot Bufferize tries to infer the most precise memref type when bufferizing
an op. If the entire IR is bufferizable, we do not have to resort to
conservatively use fully dynamic layout maps. In that case, we also do not have
to rely on canonicalization patterns to clean up the bufferized IR.</p>
<p>Note: There are some bufferizable ops for which a percise layout map cannot be
inferred. E.g., a <code class="docutils literal notranslate"><span class="pre">tensor.cast</span></code> from a <code class="docutils literal notranslate"><span class="pre">tensor&lt;*xf32&gt;</span></code> to a <code class="docutils literal notranslate"><span class="pre">tensor&lt;?x?xf32&gt;</span></code>
must be bufferized to a <code class="docutils literal notranslate"><span class="pre">memref.cast</span></code> with a memref type that has a fully
dynamic layout map.</p>
<p>One-Shot Bufferize has an option <code class="docutils literal notranslate"><span class="pre">unknown-type-conversion</span></code> to control the
generation of layout maps when no precise layout can be inferred:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fully-dynamic-layout-map</span></code> uses fully dynamic layout maps and is the default
behavior. This composes well when IR is partially bufferized.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">identity-layout-map</span></code> uses static identity layout maps. This option can be
useful for legacy code that cannot handle memref types with layout maps.
Note that this setting can lead to additional buffer copies when folding a
<code class="docutils literal notranslate"><span class="pre">to_tensor</span></code>/<code class="docutils literal notranslate"><span class="pre">to_memref</span></code> pair with memref types that are not cast-compatible.</p></li>
</ul>
<p>Note: The <code class="docutils literal notranslate"><span class="pre">unknown-type-conversion</span></code> option does not affect layout maps of
function signatures. There is a separate <code class="docutils literal notranslate"><span class="pre">function-signature-type-conversion</span></code>
option that controls layout maps of function parameters and function results.</p>
</section>
<section id="extending-one-shot-bufferize">
<h2>Extending One-Shot Bufferize<a class="headerlink" href="#extending-one-shot-bufferize" title="此标题的永久链接">¶</a></h2>
<p>Custom ops can be bufferized if they implement <code class="docutils literal notranslate"><span class="pre">BufferizableOpInterface</span></code>. Users
must at least implement the following interface methods.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bufferizesToMemoryRead</span></code>: Return <code class="docutils literal notranslate"><span class="pre">true</span></code> if the buffer of the given tensor
OpOperand is read.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bufferizesToMemoryWrite</span></code>: Return <code class="docutils literal notranslate"><span class="pre">true</span></code> if the buffer of the given tensor
OpOperand is written (if bufferizing in-place).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">getAliasingOpResult</span></code>: Return the OpResults that may share the same buffer
as the given OpOperand. This interface method describes to
OpOperand-to-OpResult mapping wrt. destination-passing style.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bufferRelation</span></code>: Return <code class="docutils literal notranslate"><span class="pre">BufferRelation::Equivalent</span></code> if the given OpResult
is the exact same memref as the aliasing OpOperand after bufferization (in
case of in-place bufferization). Otherwise, (e.g., they overlap but are not
necessarily the exact same memrefs), <code class="docutils literal notranslate"><span class="pre">BufferRelation::Unknown</span></code> should be
returned. Additional buffer relations will be added in the future, but
<code class="docutils literal notranslate"><span class="pre">BufferRelation::Unknown</span></code> is always safe.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bufferize</span></code>: Rewrite the op with the given rewriter. Ops should be replaced
with <code class="docutils literal notranslate"><span class="pre">bufferization::replaceOpWithBufferizedValues</span></code>.</p></li>
</ul>
<p>To get a better intuition of the interface methods, we invite users to take a
look at existing implementations in MLIR, e.g., the implementation of
<code class="docutils literal notranslate"><span class="pre">tensor.insert</span></code> or <code class="docutils literal notranslate"><span class="pre">tensor.extract</span></code>.</p>
</section>
<section id="debugging-buffer-copies">
<h2>Debugging Buffer Copies<a class="headerlink" href="#debugging-buffer-copies" title="此标题的永久链接">¶</a></h2>
<p>To get a better understanding of why One-Shot Bufferize introduced a buffer
copy, users can run the pass with <code class="docutils literal notranslate"><span class="pre">test-analysis-only</span> <span class="pre">print-conflicts</span></code>. Every
tensor op is then annotated with an attribute that has a boolean value for each
tensor OpOperand. <code class="docutils literal notranslate"><span class="pre">true</span></code> means that the OpOperand bufferizes in-place. <code class="docutils literal notranslate"><span class="pre">false</span></code>
means that the OpOperand bufferizes out-of-place and a buffer copy will be
inserted.</p>
<p>There are two reasons why a buffer copy may be inserted.</p>
<ol class="simple">
<li><p>Due to a RaW conflict, it is not safe to bufferize in-place. I.e., the
overwritten data is still needed.</p></li>
<li><p>The buffer is not writable. E.g., <code class="docutils literal notranslate"><span class="pre">memref.global</span></code> buffers that are the
result of <code class="docutils literal notranslate"><span class="pre">arith.constant</span></code> ops are never modified.</p></li>
</ol>
<p>In the first case, <code class="docutils literal notranslate"><span class="pre">print-conflicts</span></code> illustrates the conflict in the form of a
(”read”, “conflicting write”, “last write”) tuple.</p>
</section>
<section id="understanding-the-ssa-use-def-chain-analysis">
<h2>Understanding the SSA Use-Def Chain Analysis<a class="headerlink" href="#understanding-the-ssa-use-def-chain-analysis" title="此标题的永久链接">¶</a></h2>
<p>To get a better understanding of the SSA Use-Def Chain Analysis and the RaW
conflict detection algorithm, we invite interested users to read the
<a class="reference external" href="https://discourse.llvm.org/uploads/short-url/5kckJ3DftYwQokG252teFgw3sYa.pdf">design document</a>
and watch the corresponding <a class="reference external" href="https://youtu.be/TXEo59CYS9A">ODM talk</a>
(<a class="reference external" href="https://mlir.llvm.org/OpenMeetings/2022-01-13-One-Shot-Bufferization.pdf">slides</a>).
can be used to bufferize a program in a single pass, as long as each op</p>
</section>
<section id="migrating-from-dialect-conversion-based-bufferization">
<h2>Migrating from Dialect Conversion-based Bufferization<a class="headerlink" href="#migrating-from-dialect-conversion-based-bufferization" title="此标题的永久链接">¶</a></h2>
<p>Both dialect conversion-based bufferization and One-Shot Bufferize generate
<code class="docutils literal notranslate"><span class="pre">to_tensor</span></code>/<code class="docutils literal notranslate"><span class="pre">to_memref</span></code> ops at the bufferization boundary (when run with
<code class="docutils literal notranslate"><span class="pre">allow-unknown-ops</span></code>). They can be combined and run in sequence. However,
One-Shot Bufferize must run first because it cannot analyze those boundary ops.
To update existing code step-by-step, it may be useful to specify a dialect
filter for One-Shot Bufferize, so that dialects can be switched over one-by-one.</p>
</section>
<section id="bufferization-function-graphs">
<h2>Bufferization Function Graphs<a class="headerlink" href="#bufferization-function-graphs" title="此标题的永久链接">¶</a></h2>
<p>One-Shot Bufferize does currently not support function graph bufferization.
I.e., <code class="docutils literal notranslate"><span class="pre">CallOp</span></code>, <code class="docutils literal notranslate"><span class="pre">ReturnOp</span></code> and function bbArgs are not bufferizable. Users can
run the existing <code class="docutils literal notranslate"><span class="pre">--func-bufferize</span></code> bufferization pass after One-Shot Bufferize.</p>
<p>Alternatively, users can try
<a class="reference external" href="https://github.com/llvm/llvm-project/blob/ae2764e835a26bad9774803eca0a6530df2a3e2d/mlir/include/mlir/Dialect/Linalg/ComprehensiveBufferize/ModuleBufferization.h#L31"><code class="docutils literal notranslate"><span class="pre">ModuleBufferization</span></code></a>,
which is an extension of One-Shot Bufferize. This bufferization is still under
development and does not support arbitrary IR. In essence, returning a tensor
from a function is not supported, unless it is equivalent to a function bbArg.
In that case, the corresponding return value can simply be dropped during
bufferization.</p>
</section>
<section id="dialect-conversion-based-bufferization">
<h2>Dialect Conversion-based Bufferization<a class="headerlink" href="#dialect-conversion-based-bufferization" title="此标题的永久链接">¶</a></h2>
<p>Disclaimer: Most dialect conversion-based bufferization has been migrated to
One-Shot Bufferize. New users should use One-Shot Bufferize (with or without
analysis). The following documentation is only for existing users of dialect
conversion-based bufferization.</p>
<p>This system is a simple application of MLIR’s dialect conversion infrastructure.
The bulk of the code related to bufferization is a set of ordinary
<code class="docutils literal notranslate"><span class="pre">ConversionPattern</span></code>’s that dialect authors write for converting ops that operate
on <code class="docutils literal notranslate"><span class="pre">tensor</span></code>’s to ops that operate on <code class="docutils literal notranslate"><span class="pre">memref</span></code>’s. A set of conventions and best
practices are followed that allow these patterns to be run across multiple
independent passes (rather than requiring a single huge atomic conversion pass),
which makes the compilation pipelines scalable, robust, and easy to debug.</p>
<p>This document is targeted at people looking to utilize MLIR’s bufferization
functionality, along with people who want to extend it to cover their own ops.</p>
<p><a name="the-talk"><strong>NOTE:</strong></a> Before reading this document, please watch the
talk “Type Conversions the Not-So-Hard-Way: MLIR’s New Bufferization
Infrastructure”
(<a class="reference external" href="https://drive.google.com/file/d/1FVbzCXxZzS9LBLuvpPNLWJD-XDkt54ky/view?usp=sharing">slides</a>,
<a class="reference external" href="https://drive.google.com/file/d/1VfVajitgf8ZPnd-HRkJvaJiFLhBsluXN/view?usp=sharing">recording</a>).
That talk gives a high-level overview of the bufferization infrastructure and
important conceptual details related to using the MLIR dialect conversion
infrastructure.</p>
<section id="bufferization-s-place-in-a-compilation-pipeline">
<h3>Bufferization’s place in a compilation pipeline<a class="headerlink" href="#bufferization-s-place-in-a-compilation-pipeline" title="此标题的永久链接">¶</a></h3>
<p>Bufferization itself does not free any of the buffers that have been allocated,
nor does it do anything particularly intelligent with the placement of buffers
w.r.t. control flow. Thus, a realistic compilation pipeline will usually consist
of:</p>
<ol class="simple">
<li><p>Bufferization</p></li>
<li><p>Buffer optimizations such as <code class="docutils literal notranslate"><span class="pre">buffer-hoisting</span></code>, <code class="docutils literal notranslate"><span class="pre">buffer-loop-hoisting</span></code>, and
<code class="docutils literal notranslate"><span class="pre">promote-buffers-to-stack</span></code>, which do optimizations that are only exposed
after bufferization.</p></li>
<li><p>Finally, running the <a class="reference internal" href="BufferDeallocationInternals.html"><span class="doc">buffer deallocation</span></a>
pass.</p></li>
</ol>
<p>After buffer deallocation has been completed, the program will be quite
difficult to transform due to the presence of the deallocation ops. Thus, other
optimizations such as linalg fusion on memrefs should be done before that stage.</p>
</section>
<section id="general-structure-of-the-bufferization-process">
<h3>General structure of the bufferization process<a class="headerlink" href="#general-structure-of-the-bufferization-process" title="此标题的永久链接">¶</a></h3>
<p>Bufferization consists of running multiple <em>partial</em> bufferization passes,
followed by one <em>finalizing</em> bufferization pass.</p>
<p>There is typically one partial bufferization pass per dialect (though other
subdivisions are possible). For example, for a dialect <code class="docutils literal notranslate"><span class="pre">X</span></code> there will typically
be a pass <code class="docutils literal notranslate"><span class="pre">X-bufferize</span></code> that knows how to bufferize all the ops in that dialect.
By running pass <code class="docutils literal notranslate"><span class="pre">X-bufferize</span></code> for each dialect <code class="docutils literal notranslate"><span class="pre">X</span></code> in the program, all the ops
in the program are incrementally bufferized.</p>
<p>Partial bufferization passes create programs where only some ops have been
bufferized. These passes will create <em>materializations</em> (also sometimes called
“casts”) that convert between the <code class="docutils literal notranslate"><span class="pre">tensor</span></code> and <code class="docutils literal notranslate"><span class="pre">memref</span></code> type, which allows
bridging between ops that have been bufferized and ops that have not yet been
bufferized.</p>
<p>Finalizing bufferizations complete the bufferization process, and guarantee that
there are no tensors remaining in the program. This involves eliminating the
materializations. The pass <code class="docutils literal notranslate"><span class="pre">finalizing-bufferize</span></code> provides a minimal pass that
only eliminates materializations and issues an error if any unbufferized ops
exist in the program.</p>
<p>However, it is possible for a finalizing bufferization to do more than just
eliminate materializations. By adding patterns (just as a partial bufferization
would), it is possible for a finalizing bufferization pass to simultaneously
bufferize ops and eliminate materializations. This has a number of disadvantages
discussed in the talk and should generally be avoided.</p>
</section>
<section id="example">
<h3>Example<a class="headerlink" href="#example" title="此标题的永久链接">¶</a></h3>
<p>As a concrete example, we will look at the bufferization pipeline from the
<code class="docutils literal notranslate"><span class="pre">mlir-npcomp</span></code> reference backend
(<a class="reference external" href="https://github.com/llvm/mlir-npcomp/blob/97d6d04d41216e73d40b89ffd79620973fc14ce3/lib/RefBackend/RefBackend.cpp#L232">code</a>).
The code, slightly simplified and annotated, is reproduced here:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">  </span><span class="c1">// Partial bufferization passes.</span>
<span class="w">  </span><span class="n">pm</span><span class="p">.</span><span class="n">addPass</span><span class="p">(</span><span class="n">createTensorConstantBufferizePass</span><span class="p">());</span>
<span class="w">  </span><span class="n">pm</span><span class="p">.</span><span class="n">addNestedPass</span><span class="o">&lt;</span><span class="n">func</span><span class="o">::</span><span class="n">FuncOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">createTCPBufferizePass</span><span class="p">());</span><span class="w"> </span><span class="c1">// Bufferizes the downstream `tcp` dialect.</span>
<span class="w">  </span><span class="n">pm</span><span class="p">.</span><span class="n">addNestedPass</span><span class="o">&lt;</span><span class="n">func</span><span class="o">::</span><span class="n">FuncOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">createSCFBufferizePass</span><span class="p">());</span>
<span class="w">  </span><span class="n">pm</span><span class="p">.</span><span class="n">addNestedPass</span><span class="o">&lt;</span><span class="n">func</span><span class="o">::</span><span class="n">FuncOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">createLinalgBufferizePass</span><span class="p">());</span>
<span class="w">  </span><span class="n">pm</span><span class="p">.</span><span class="n">addNestedPass</span><span class="o">&lt;</span><span class="n">func</span><span class="o">::</span><span class="n">FuncOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">createTensorBufferizePass</span><span class="p">());</span>
<span class="w">  </span><span class="n">pm</span><span class="p">.</span><span class="n">addPass</span><span class="p">(</span><span class="n">createFuncBufferizePass</span><span class="p">());</span>

<span class="w">  </span><span class="c1">// Finalizing bufferization pass.</span>
<span class="w">  </span><span class="n">pm</span><span class="p">.</span><span class="n">addNestedPass</span><span class="o">&lt;</span><span class="n">func</span><span class="o">::</span><span class="n">FuncOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">createFinalizingBufferizePass</span><span class="p">());</span>
</pre></div>
</div>
<p>Looking first at the partial bufferization passes, we see that there are a
sequence of <code class="docutils literal notranslate"><span class="pre">FuncOp</span></code> passes (which run in parallel on functions). These function
passes are bracketed by <code class="docutils literal notranslate"><span class="pre">arith-bufferize</span></code> and <code class="docutils literal notranslate"><span class="pre">func-bufferize</span></code>, which are module
passes (and thus serialize the parallel compilation process). These two passes
must be module passes because they make changes to the top-level module.</p>
<p>The bulk of the bufferization work is done by the function passes. Most of these
passes are provided as part of the upstream MLIR distribution and bufferize
their respective dialects (e.g. <code class="docutils literal notranslate"><span class="pre">scf-bufferize</span></code> bufferizes the <code class="docutils literal notranslate"><span class="pre">scf</span></code> dialect).
The <code class="docutils literal notranslate"><span class="pre">tcp-bufferize</span></code> pass is an exception – it is a partial bufferization pass
used to bufferize the downstream <code class="docutils literal notranslate"><span class="pre">tcp</span></code> dialect, and fits in perfectly with all
the other passes provided upstream.</p>
<p>The last pass is the finalizing bufferization pass. The <code class="docutils literal notranslate"><span class="pre">mlir-npcomp</span></code> reference
backend has arranged that all ops are bufferized by partial bufferizations, so
that the upstream <code class="docutils literal notranslate"><span class="pre">finalizing-bufferize</span></code> pass can be used as the finalizing
bufferization pass. This gives excellent diagnostics when something goes wrong
with the bufferization process, such as due to an op that wasn’t handled by any
pattern.</p>
</section>
<section id="how-to-write-a-partial-bufferization-pass">
<h3>How to write a partial bufferization pass<a class="headerlink" href="#how-to-write-a-partial-bufferization-pass" title="此标题的永久链接">¶</a></h3>
<p>The contract of a partial bufferization pass is that a subset of ops (or kinds
of ops, customizable by a ConversionTarget) get bufferized.</p>
<p>A partial bufferization pass is just a pass that uses the
<a class="reference internal" href="DialectConversion.html"><span class="doc">dialect conversion</span></a> framework to apply
<code class="docutils literal notranslate"><span class="pre">ConversionPattern</span></code>s with a <code class="docutils literal notranslate"><span class="pre">tensor</span></code> to <code class="docutils literal notranslate"><span class="pre">memref</span></code> type conversion.</p>
<p>To describe how to write such a pass, we will walk through an example, the
<code class="docutils literal notranslate"><span class="pre">tensor-bufferize</span></code> pass
(<a class="reference external" href="https://github.com/llvm/llvm-project/blob/bc8acf2ce8ad6e8c9b1d97b2e02d3f4ad26e1d9d/mlir/lib/Dialect/Tensor/Transforms/Bufferize.cpp#L23">code</a>,
<a class="reference external" href="https://github.com/llvm/llvm-project/blob/bc8acf2ce8ad6e8c9b1d97b2e02d3f4ad26e1d9d/mlir/test/Dialect/Tensor/bufferize.mlir#L1">test</a>)
that bufferizes the <code class="docutils literal notranslate"><span class="pre">tensor</span></code> dialect. Note that these passes have been replaced
with a <code class="docutils literal notranslate"><span class="pre">BufferizableOpInterface</span></code>-based implementation in the meantime, so we
have to take a looker at an older version of the code.</p>
<p>The bulk of the code in the pass will be a set of conversion patterns, with a
simple example being
<a class="reference external" href="https://github.com/llvm/llvm-project/blob/2bf6e443e54604c7818c4d1a1837f3d091023270/mlir/lib/Dialect/Tensor/Transforms/Bufferize.cpp#L23">BufferizeCastOp</a>).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">BufferizeCastOp</span> <span class="p">:</span> <span class="n">public</span> <span class="n">OpConversionPattern</span><span class="o">&lt;</span><span class="n">tensor</span><span class="p">::</span><span class="n">CastOp</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="n">public</span><span class="p">:</span>
  <span class="n">using</span> <span class="n">OpConversionPattern</span><span class="p">::</span><span class="n">OpConversionPattern</span><span class="p">;</span>
  <span class="n">LogicalResult</span>
  <span class="n">matchAndRewrite</span><span class="p">(</span><span class="n">tensor</span><span class="p">::</span><span class="n">CastOp</span> <span class="n">op</span><span class="p">,</span> <span class="n">OpAdaptor</span> <span class="n">adaptor</span><span class="p">,</span>
                  <span class="n">ConversionPatternRewriter</span> <span class="o">&amp;</span><span class="n">rewriter</span><span class="p">)</span> <span class="n">const</span> <span class="n">override</span> <span class="p">{</span>
    <span class="n">auto</span> <span class="n">resultType</span> <span class="o">=</span> <span class="n">getTypeConverter</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">convertType</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">getType</span><span class="p">());</span>
    <span class="n">rewriter</span><span class="o">.</span><span class="n">replaceOpWithNewOp</span><span class="o">&lt;</span><span class="n">MemRefCastOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">resultType</span><span class="p">,</span> <span class="n">adaptor</span><span class="o">.</span><span class="n">source</span><span class="p">());</span>
    <span class="k">return</span> <span class="n">success</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>See <a class="reference external" href="#the-talk">the talk</a> for more details on how to write these patterns.</p>
<p>The
<a class="reference external" href="https://github.com/llvm/llvm-project/blob/bc8acf2ce8ad6e8c9b1d97b2e02d3f4ad26e1d9d/mlir/lib/Dialect/Tensor/Transforms/Bufferize.cpp#L57">pass itself</a>
is very small, and follows the basic pattern of any dialect conversion pass.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">mlir</span><span class="p">::</span><span class="n">populateTensorBufferizePatterns</span><span class="p">(</span>
    <span class="n">BufferizeTypeConverter</span> <span class="o">&amp;</span><span class="n">typeConverter</span><span class="p">,</span> <span class="n">RewritePatternSet</span> <span class="o">&amp;</span><span class="n">patterns</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">patterns</span><span class="o">.</span><span class="n">add</span><span class="o">&lt;</span><span class="n">BufferizeCastOp</span><span class="p">,</span> <span class="n">BufferizeExtractOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">typeConverter</span><span class="p">,</span>
                                                    <span class="n">patterns</span><span class="o">.</span><span class="n">getContext</span><span class="p">());</span>
<span class="p">}</span>

<span class="n">struct</span> <span class="n">TensorBufferizePass</span> <span class="p">:</span> <span class="n">public</span> <span class="n">TensorBufferizeBase</span><span class="o">&lt;</span><span class="n">TensorBufferizePass</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">void</span> <span class="n">runOnOperation</span><span class="p">()</span> <span class="n">override</span> <span class="p">{</span>
    <span class="n">auto</span> <span class="o">*</span><span class="n">context</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">getContext</span><span class="p">();</span>
    <span class="n">BufferizeTypeConverter</span> <span class="n">typeConverter</span><span class="p">;</span>
    <span class="n">RewritePatternSet</span> <span class="n">patterns</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
    <span class="n">ConversionTarget</span> <span class="n">target</span><span class="p">(</span><span class="o">*</span><span class="n">context</span><span class="p">);</span>

    <span class="n">populateTensorBufferizePatterns</span><span class="p">(</span><span class="n">typeConverter</span><span class="p">,</span> <span class="n">patterns</span><span class="p">);</span>
    <span class="n">target</span><span class="o">.</span><span class="n">addIllegalOp</span><span class="o">&lt;</span><span class="n">tensor</span><span class="p">::</span><span class="n">CastOp</span><span class="p">,</span> <span class="n">tensor</span><span class="p">::</span><span class="n">ExtractOp</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">target</span><span class="o">.</span><span class="n">addLegalDialect</span><span class="o">&lt;</span><span class="n">func</span><span class="p">::</span><span class="n">FuncDialect</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">failed</span><span class="p">(</span>
            <span class="n">applyPartialConversion</span><span class="p">(</span><span class="n">getOperation</span><span class="p">(),</span> <span class="n">target</span><span class="p">,</span> <span class="n">std</span><span class="p">::</span><span class="n">move</span><span class="p">(</span><span class="n">patterns</span><span class="p">))))</span>
      <span class="n">signalPassFailure</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The pass has all the hallmarks of a dialect conversion pass that does type
conversions: a <code class="docutils literal notranslate"><span class="pre">TypeConverter</span></code>, a <code class="docutils literal notranslate"><span class="pre">RewritePatternSet</span></code>, and a <code class="docutils literal notranslate"><span class="pre">ConversionTarget</span></code>,
and a call to <code class="docutils literal notranslate"><span class="pre">applyPartialConversion</span></code>. Note that a function
<code class="docutils literal notranslate"><span class="pre">populateTensorBufferizePatterns</span></code> is separated, so that power users can use the
patterns independently, if necessary (such as to combine multiple sets of
conversion patterns into a single conversion call, for performance).</p>
<p>One convenient utility provided by the MLIR bufferization infrastructure is the
<code class="docutils literal notranslate"><span class="pre">BufferizeTypeConverter</span></code>, which comes pre-loaded with the necessary conversions
and materializations between <code class="docutils literal notranslate"><span class="pre">tensor</span></code> and <code class="docutils literal notranslate"><span class="pre">memref</span></code>.</p>
<p>In this case, the <code class="docutils literal notranslate"><span class="pre">BufferizationOpsDialect</span></code> is marked as legal, so the
<code class="docutils literal notranslate"><span class="pre">bufferization.to_tensor</span></code> and <code class="docutils literal notranslate"><span class="pre">bufferization.to_memref</span></code> ops, which are inserted
automatically by the dialect conversion framework as materializations, are
legal. There is a helper <code class="docutils literal notranslate"><span class="pre">populateBufferizeMaterializationLegality</span></code>
(<a class="reference external" href="https://github.com/llvm/llvm-project/blob/a0b65a7bcd6065688189b3d678c42ed6af9603db/mlir/include/mlir/Transforms/Bufferize.h#L53">code</a>)
which helps with this in general.</p>
</section>
<section id="other-partial-bufferization-examples">
<h3>Other partial bufferization examples<a class="headerlink" href="#other-partial-bufferization-examples" title="此标题的永久链接">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">scf-bufferize</span></code>
(<a class="reference external" href="https://github.com/llvm/llvm-project/blob/bc8acf2ce8ad6e8c9b1d97b2e02d3f4ad26e1d9d/mlir/lib/Dialect/SCF/Transforms/Bufferize.cpp#L1">code</a>,
<a class="reference external" href="https://github.com/llvm/llvm-project/blob/bc8acf2ce8ad6e8c9b1d97b2e02d3f4ad26e1d9d/mlir/test/Dialect/SCF/bufferize.mlir#L1">test</a>)</p>
<ul>
<li><p>Bufferizes ops from the <code class="docutils literal notranslate"><span class="pre">scf</span></code> dialect.</p></li>
<li><p>This is an example of how to bufferize ops that implement
<code class="docutils literal notranslate"><span class="pre">RegionBranchOpInterface</span></code> (that is, they use regions to represent
control flow).</p></li>
<li><p>The bulk of the work is done by
<code class="docutils literal notranslate"><span class="pre">lib/Dialect/SCF/Transforms/StructuralTypeConversions.cpp</span></code>
(<a class="reference external" href="https://github.com/llvm/llvm-project/blob/daaaed6bb89044ac58a23f1bb1ccdd12342a5a58/mlir/lib/Dialect/SCF/Transforms/StructuralTypeConversions.cpp#L1">code</a>),
which is well-commented and covers how to correctly convert ops that
contain regions.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">func-bufferize</span></code>
(<a class="reference external" href="https://github.com/llvm/llvm-project/blob/2f5715dc78328215d51d5664c72c632a6dac1046/mlir/lib/Dialect/Func/Transforms/FuncBufferize.cpp#L1">code</a>,
<a class="reference external" href="https://github.com/llvm/llvm-project/blob/2f5715dc78328215d51d5664c72c632a6dac1046/mlir/test/Dialect/Func/func-bufferize.mlir#L1">test</a>)</p>
<ul>
<li><p>Bufferizes <code class="docutils literal notranslate"><span class="pre">func</span></code>, <code class="docutils literal notranslate"><span class="pre">call</span></code>, and <code class="docutils literal notranslate"><span class="pre">BranchOpInterface</span></code> ops.</p></li>
<li><p>This is an example of how to bufferize ops that have multi-block
regions.</p></li>
<li><p>This is an example of a pass that is not split along dialect
subdivisions.</p></li>
</ul>
</li>
</ul>
</section>
<section id="how-to-write-a-finalizing-bufferization-pass">
<h3>How to write a finalizing bufferization pass<a class="headerlink" href="#how-to-write-a-finalizing-bufferization-pass" title="此标题的永久链接">¶</a></h3>
<p>The contract of a finalizing bufferization pass is that all tensors are gone
from the program.</p>
<p>The easiest way to write a finalizing bufferize pass is to not write one at all!
MLIR provides a pass <code class="docutils literal notranslate"><span class="pre">finalizing-bufferize</span></code> which eliminates the
<code class="docutils literal notranslate"><span class="pre">bufferization.to_tensor</span></code> / <code class="docutils literal notranslate"><span class="pre">bufferization.to_memref</span></code> materialization ops
inserted by partial bufferization passes and emits an error if that is not
sufficient to remove all tensors from the program.</p>
<p>This pass is sufficient when partial bufferization passes have bufferized all
the ops in the program, leaving behind only the materializations. When possible,
it is recommended to structure your pass pipeline this way, as this has the
significant advantage that if an op does not get bufferized (due to a missing
pattern, bug in the code, etc.), <code class="docutils literal notranslate"><span class="pre">finalizing-bufferize</span></code> will emit a nice clean
error, and the IR seen by <code class="docutils literal notranslate"><span class="pre">finalizing-bufferize</span></code> will only contain only one
unbufferized op.</p>
<p>However, before the current bufferization infrastructure was put in place,
bufferization could only be done as a single finalizing bufferization mega-pass
that used the <code class="docutils literal notranslate"><span class="pre">populate*BufferizePatterns</span></code> functions from multiple dialects to
simultaneously bufferize everything at once. Thus, one might see code in
downstream projects structured this way. This structure is not recommended in
new code. A helper, <code class="docutils literal notranslate"><span class="pre">populateEliminateBufferizeMaterializationsPatterns</span></code>
(<a class="reference external" href="https://github.com/llvm/llvm-project/blob/a0b65a7bcd6065688189b3d678c42ed6af9603db/mlir/include/mlir/Transforms/Bufferize.h#L58">code</a>)
is available for such passes to provide patterns that eliminate
<code class="docutils literal notranslate"><span class="pre">bufferization.to_tensor</span></code> and <code class="docutils literal notranslate"><span class="pre">bufferization.to_memref</span></code>.</p>
</section>
<section id="changes-since-the-talk">
<h3>Changes since <a class="reference external" href="#the-talk">the talk</a><a class="headerlink" href="#changes-since-the-talk" title="此标题的永久链接">¶</a></h3>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">func-bufferize</span></code> was changed to be a partial conversion pass, and there is a
new <code class="docutils literal notranslate"><span class="pre">finalizing-bufferize</span></code> which serves as a general finalizing
bufferization pass.</p></li>
<li><p>Most partial bufferization passes have been reimplemented in terms of
<code class="docutils literal notranslate"><span class="pre">BufferizableOpInterface</span></code>. New users should use One-Shot Bufferize instead
of dialect conversion-based bufferization.</p></li>
</ul>
</section>
</section>
</section>


          </div>
          <div class="page-nav">
            <div class="inner"><ul class="page-nav">
</ul><div class="footer" role="contentinfo">
      &#169; 版权所有 2023, yaoyue123.
    <br>
    Created using <a href="http://sphinx-doc.org/">Sphinx</a> 6.1.3 with <a href="https://github.com/schettino72/sphinx_press_theme">Press Theme</a> 0.8.0.
</div>
            </div>
          </div>
      </page>
    </div></div>
    
    
  </body>
</html>