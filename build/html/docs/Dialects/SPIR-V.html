<!DOCTYPE html>
<html  lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

      <title>SPIR-V Dialect</title>
    
          <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
          <link rel="stylesheet" href="../../_static/theme.css " type="text/css" />
      
      <!-- sphinx script_files -->
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
        <script src="../../_static/translations.js"></script>

      
      <!-- bundled in js (rollup iife) -->
      <!-- <script src="../../_static/theme-vendors.js"></script> -->
      <script src="../../_static/theme.js" defer></script>
    
  <link rel="index" title="索引" href="../../genindex.html" />
  <link rel="search" title="搜索" href="../../search.html" /> 
  </head>

  <body>
    <div id="app">
    <div class="theme-container" :class="pageClasses"><navbar @toggle-sidebar="toggleSidebar">
  <router-link to="../../index.html" class="home-link">
    
      <span class="site-name">MLIR 中文文档</span>
    
  </router-link>

  <div class="links">
    <navlinks class="can-hide">



    </navlinks>
  </div>
</navbar>

      
      <div class="sidebar-mask" @click="toggleSidebar(false)">
      </div>
        <sidebar @toggle-sidebar="toggleSidebar">
          
          <navlinks>
            



            
          </navlinks><div id="searchbox" class="searchbox" role="search">
  <div class="caption"><span class="caption-text">快速搜索</span>
    <div class="searchformwrapper">
      <form class="search" action="../../search.html" method="get">
        <input type="text" name="q" />
        <input type="submit" value="搜索" />
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div><div class="sidebar-links" role="navigation" aria-label="main navigation">
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../../index.html#mlir">欢迎使用 mlir 中文文档</a></span>
      </p>
      <ul class="">
        
          <li class="toctree-l1 ">
            
              <a href="../../_index.html" class="reference internal ">开始使用MLIR</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/CreatingADialect.html" class="reference internal ">Creating a Dialect</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/DataFlowAnalysis.html" class="reference internal ">Writing DataFlow Analyses in MLIR</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/QuickstartRewrites.html" class="reference internal ">Quickstart tutorial to adding MLIR graph rewrite</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/Toy/Ch-1.html" class="reference internal ">第1章：Toy语言和AST（抽象语法树）</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/Toy/Ch-2.html" class="reference internal ">Chapter 2: Emitting Basic MLIR</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/Toy/Ch-3.html" class="reference internal ">Chapter 3: High-level Language-Specific Analysis and Transformation</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/Toy/Ch-4.html" class="reference internal ">Chapter 4: Enabling Generic Transformation with Interfaces</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/Toy/Ch-5.html" class="reference internal ">Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/Toy/Ch-6.html" class="reference internal ">Chapter 6: Lowering to LLVM and CodeGeneration</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/Toy/Ch-7.html" class="reference internal ">Chapter 7: Adding a Composite Type to Toy</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/Toy/_index.html" class="reference internal ">Toy 入门教程</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/UnderstandingTheIRStructure.html" class="reference internal ">Understanding the IR Structure</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="../Tutorials/_index.html" class="reference internal ">Tutorials</a>
            

            
          </li>

        
      </ul>
    </div>
  
</div>
        </sidebar>

      <page>
          <div class="body-header" role="navigation" aria-label="navigation">
  
  <ul class="breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
    
    <li>SPIR-V Dialect</li>
  </ul>
  

  <ul class="page-nav">
</ul>
  
</div>
<hr>
          <div class="content" role="main" v-pre>
            
  <section id="spir-v-dialect">
<h1>SPIR-V Dialect<a class="headerlink" href="#spir-v-dialect" title="此标题的永久链接">¶</a></h1>
<p>This document describes the design of the SPIR-V dialect in MLIR. It lists
various design choices we made for modeling different SPIR-V mechanisms, and
their rationale.</p>
<p>This document also explains in a high-level manner how different components are
organized and implemented in the code and gives steps to follow for extending
them.</p>
<p>This document assumes familiarity with SPIR-V. <a class="reference external" href="https://www.khronos.org/registry/spir-v/">SPIR-V</a> is the Khronos
Group’s binary intermediate language for representing graphics shaders and
compute kernels. It is adopted by multiple Khronos Group’s APIs, including
Vulkan and OpenCL. It is fully defined in a
<a class="reference external" href="https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html">human-readable specification</a>; the syntax of various SPIR-V
instructions are encoded in a <a class="reference external" href="https://raw.githubusercontent.com/KhronosGroup/SPIRV-Headers/master/include/spirv/unified1/spirv.core.grammar.json">machine-readable grammar</a>.</p>
<p>[TOC]</p>
<section id="design-guidelines">
<h2>Design Guidelines<a class="headerlink" href="#design-guidelines" title="此标题的永久链接">¶</a></h2>
<p>SPIR-V is a binary intermediate language that serves dual purpose: on one side,
it is an intermediate language to represent graphics shaders and compute kernels
for high-level languages to target; on the other side, it defines a stable
binary format for hardware driver consumption. As a result, SPIR-V has design
principles pertain to not only intermediate language, but also binary format.
For example, regularity is one of the design goals of SPIR-V. All concepts are
represented as SPIR-V instructions, including declaring extensions and
capabilities, defining types and constants, defining functions, attaching
additional properties to computation results, etc. This way favors binary
encoding and decoding for driver consumption but not necessarily compiler
transformations.</p>
<section id="dialect-design-principles">
<h3>Dialect design principles<a class="headerlink" href="#dialect-design-principles" title="此标题的永久链接">¶</a></h3>
<p>The main objective of the SPIR-V dialect is to be a proper intermediate
representation (IR) to facilitate compiler transformations. While we still aim
to support serializing to and deserializing from the binary format for various
good reasons, the binary format and its concerns play less a role in the design
of the SPIR-V dialect: when there is a trade-off to be made between favoring IR
and supporting binary format, we lean towards the former.</p>
<p>On the IR aspect, the SPIR-V dialect aims to model SPIR-V at the same semantic
level. It is not intended to be a higher level or lower level abstraction than
the SPIR-V specification. Those abstractions are easily outside the domain of
SPIR-V and should be modeled with other proper dialects so they can be shared
among various compilation paths. Because of the dual purpose of SPIR-V, SPIR-V
dialect staying at the same semantic level as the SPIR-V specification also
means we can still have straightforward serialization and deserialization for
the majority of functionalities.</p>
<p>To summarize, the SPIR-V dialect follows the following design principles:</p>
<ul class="simple">
<li><p>Stay as the same semantic level as the SPIR-V specification by having
one-to-one mapping for most concepts and entities.</p></li>
<li><p>Adopt SPIR-V specification’s syntax if possible, but deviate intentionally
to utilize MLIR mechanisms if it results in better representation and
benefits transformation.</p></li>
<li><p>Be straightforward to serialize into and deserialize from the SPIR-V binary
format.</p></li>
</ul>
<p>SPIR-V is designed to be consumed by hardware drivers, so its representation is
quite clear, yet verbose for some cases. Allowing representational deviation
gives us the flexibility to reduce the verbosity by using MLIR mechanisms.</p>
</section>
<section id="dialect-scopes">
<h3>Dialect scopes<a class="headerlink" href="#dialect-scopes" title="此标题的永久链接">¶</a></h3>
<p>SPIR-V supports multiple execution environments, specified by client APIs.
Notable adopters include Vulkan and OpenCL. It follows that the SPIR-V dialect
should support multiple execution environments if to be a proper proxy of SPIR-V
in MLIR systems. The SPIR-V dialect is designed with these considerations: it
has proper support for versions, extensions, and capabilities and is as
extensible as SPIR-V specification.</p>
</section>
</section>
<section id="conventions">
<h2>Conventions<a class="headerlink" href="#conventions" title="此标题的永久链接">¶</a></h2>
<p>The SPIR-V dialect adopts the following conventions for IR:</p>
<ul class="simple">
<li><p>The prefix for all SPIR-V types and operations are <code class="docutils literal notranslate"><span class="pre">spirv.</span></code>.</p></li>
<li><p>All instructions in an extended instruction set are further qualified with
the extended instruction set’s prefix. For example, all operations in the
GLSL extended instruction set have the prefix of <code class="docutils literal notranslate"><span class="pre">spirv.GL.</span></code>.</p></li>
<li><p>Ops that directly mirror instructions in the specification have <code class="docutils literal notranslate"><span class="pre">CamelCase</span></code>
names that are the same as the instruction opnames (without the <code class="docutils literal notranslate"><span class="pre">Op</span></code>
prefix). For example, <code class="docutils literal notranslate"><span class="pre">spirv.FMul</span></code> is a direct mirror of <code class="docutils literal notranslate"><span class="pre">OpFMul</span></code> in the
specification. Such an op will be serialized into and deserialized from one
SPIR-V instruction.</p></li>
<li><p>Ops with <code class="docutils literal notranslate"><span class="pre">snake_case</span></code> names are those that have different representation
from corresponding instructions (or concepts) in the specification. These
ops are mostly for defining the SPIR-V structure. For example, <code class="docutils literal notranslate"><span class="pre">spirv.module</span></code>
and <code class="docutils literal notranslate"><span class="pre">spirv.Constant</span></code>. They may correspond to one or more instructions during
(de)serialization.</p></li>
<li><p>Ops with <code class="docutils literal notranslate"><span class="pre">mlir.snake_case</span></code> names are those that have no corresponding
instructions (or concepts) in the binary format. They are introduced to
satisfy MLIR structural requirements. For example, <code class="docutils literal notranslate"><span class="pre">spirv.mlir.merge</span></code>. They
map to no instructions during (de)serialization.</p></li>
</ul>
<p>(TODO: consider merging the last two cases and adopting <code class="docutils literal notranslate"><span class="pre">spirv.mlir.</span></code> prefix for
them.)</p>
</section>
<section id="module">
<h2>Module<a class="headerlink" href="#module" title="此标题的永久链接">¶</a></h2>
<p>A SPIR-V module is defined via the <code class="docutils literal notranslate"><span class="pre">spirv.module</span></code> op, which has one region that
contains one block. Model-level instructions, including function definitions,
are all placed inside the block. Functions are defined using the builtin <code class="docutils literal notranslate"><span class="pre">func</span></code>
op.</p>
<p>We choose to model a SPIR-V module with a dedicated <code class="docutils literal notranslate"><span class="pre">spirv.module</span></code> op based on the
following considerations:</p>
<ul class="simple">
<li><p>It maps cleanly to a SPIR-V module in the specification.</p></li>
<li><p>We can enforce SPIR-V specific verification that is suitable to be performed
at the module-level.</p></li>
<li><p>We can attach additional model-level attributes.</p></li>
<li><p>We can control custom assembly form.</p></li>
</ul>
<p>The <code class="docutils literal notranslate"><span class="pre">spirv.module</span></code> op’s region cannot capture SSA values from outside, neither
implicitly nor explicitly. The <code class="docutils literal notranslate"><span class="pre">spirv.module</span></code> op’s region is closed as to what ops
can appear inside: apart from the builtin <code class="docutils literal notranslate"><span class="pre">func</span></code> op, it can only contain ops
from the SPIR-V dialect. The <code class="docutils literal notranslate"><span class="pre">spirv.module</span></code> op’s verifier enforces this rule. This
meaningfully guarantees that a <code class="docutils literal notranslate"><span class="pre">spirv.module</span></code> can be the entry point and boundary
for serialization.</p>
<section id="module-level-operations">
<h3>Module-level operations<a class="headerlink" href="#module-level-operations" title="此标题的永久链接">¶</a></h3>
<p>SPIR-V binary format defines the following <a class="reference external" href="https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html#_a_id_logicallayout_a_logical_layout_of_a_module">sections</a>:</p>
<ol class="simple">
<li><p>Capabilities required by the module.</p></li>
<li><p>Extensions required by the module.</p></li>
<li><p>Extended instructions sets required by the module.</p></li>
<li><p>Addressing and memory model specification.</p></li>
<li><p>Entry point specifications.</p></li>
<li><p>Execution mode declarations.</p></li>
<li><p>Debug instructions.</p></li>
<li><p>Annotation/decoration instructions.</p></li>
<li><p>Type, constant, global variables.</p></li>
<li><p>Function declarations.</p></li>
<li><p>Function definitions.</p></li>
</ol>
<p>Basically, a SPIR-V binary module contains multiple module-level instructions
followed by a list of functions. Those module-level instructions are essential
and they can generate result ids referenced by functions, notably, declaring
resource variables to interact with the execution environment.</p>
<p>Compared to the binary format, we adjust how these module-level SPIR-V
instructions are represented in the SPIR-V dialect:</p>
<section id="use-mlir-attributes-for-metadata">
<h4>Use MLIR attributes for metadata<a class="headerlink" href="#use-mlir-attributes-for-metadata" title="此标题的永久链接">¶</a></h4>
<ul class="simple">
<li><p>Requirements for capabilities, extensions, extended instruction sets,
addressing model, and memory model are conveyed using <code class="docutils literal notranslate"><span class="pre">spirv.module</span></code>
attributes. This is considered better because these information are for the
execution environment. It’s easier to probe them if on the module op itself.</p></li>
<li><p>Annotations/decoration instructions are “folded” into the instructions they
decorate and represented as attributes on those ops. This eliminates
potential forward references of SSA values, improves IR readability, and
makes querying the annotations more direct. More discussions can be found in
the <a class="reference external" href="#decorations"><code class="docutils literal notranslate"><span class="pre">Decorations</span></code></a> section.</p></li>
</ul>
</section>
<section id="model-types-with-mlir-custom-types">
<h4>Model types with MLIR custom types<a class="headerlink" href="#model-types-with-mlir-custom-types" title="此标题的永久链接">¶</a></h4>
<ul class="simple">
<li><p>Types are represented using MLIR builtin types and SPIR-V dialect specific
types. There are no type declaration ops in the SPIR-V dialect. More
discussions can be found in the <a class="reference external" href="#types">Types</a> section later.</p></li>
</ul>
</section>
<section id="unify-and-localize-constants">
<h4>Unify and localize constants<a class="headerlink" href="#unify-and-localize-constants" title="此标题的永久链接">¶</a></h4>
<ul class="simple">
<li><p>Various normal constant instructions are represented by the same
<code class="docutils literal notranslate"><span class="pre">spirv.Constant</span></code> op. Those instructions are just for constants of different
types; using one op to represent them reduces IR verbosity and makes
transformations less tedious.</p></li>
<li><p>Normal constants are not placed in <code class="docutils literal notranslate"><span class="pre">spirv.module</span></code>’s region; they are localized
into functions. This is to make functions in the SPIR-V dialect to be
isolated and explicit capturing. Constants are cheap to duplicate given
attributes are made unique in <code class="docutils literal notranslate"><span class="pre">MLIRContext</span></code>.</p></li>
</ul>
</section>
<section id="adopt-symbol-based-global-variables-and-specialization-constant">
<h4>Adopt symbol-based global variables and specialization constant<a class="headerlink" href="#adopt-symbol-based-global-variables-and-specialization-constant" title="此标题的永久链接">¶</a></h4>
<ul class="simple">
<li><p>Global variables are defined with the <code class="docutils literal notranslate"><span class="pre">spirv.GlobalVariable</span></code> op. They do not
generate SSA values. Instead they have symbols and should be referenced via
symbols. To use global variables in a function block, <code class="docutils literal notranslate"><span class="pre">spirv.mlir.addressof</span></code> is
needed to turn the symbol into an SSA value.</p></li>
<li><p>Specialization constants are defined with the <code class="docutils literal notranslate"><span class="pre">spirv.SpecConstant</span></code> op. Similar
to global variables, they do not generate SSA values and have symbols for
reference, too. <code class="docutils literal notranslate"><span class="pre">spirv.mlir.referenceof</span></code> is needed to turn the symbol into an SSA
value for use in a function block.</p></li>
</ul>
<p>The above choices enables functions in the SPIR-V dialect to be isolated and
explicit capturing.</p>
</section>
<section id="disallow-implicit-capturing-in-functions">
<h4>Disallow implicit capturing in functions<a class="headerlink" href="#disallow-implicit-capturing-in-functions" title="此标题的永久链接">¶</a></h4>
<ul class="simple">
<li><p>In SPIR-V specification, functions support implicit capturing: they can
reference SSA values defined in modules. In the SPIR-V dialect functions are
defined with <code class="docutils literal notranslate"><span class="pre">func</span></code> op, which disallows implicit capturing. This is more
friendly to compiler analyses and transformations. More discussions can be
found in the <a class="reference external" href="#function">Function</a> section later.</p></li>
</ul>
</section>
<section id="model-entry-points-and-execution-models-as-normal-ops">
<h4>Model entry points and execution models as normal ops<a class="headerlink" href="#model-entry-points-and-execution-models-as-normal-ops" title="此标题的永久链接">¶</a></h4>
<ul class="simple">
<li><p>A SPIR-V module can have multiple entry points. And these entry points refer
to the function and interface variables. It’s not suitable to model them as
<code class="docutils literal notranslate"><span class="pre">spirv.module</span></code> op attributes. We can model them as normal ops of using symbol
references.</p></li>
<li><p>Similarly for execution modes, which are coupled with entry points, we can
model them as normal ops in <code class="docutils literal notranslate"><span class="pre">spirv.module</span></code>’s region.</p></li>
</ul>
</section>
</section>
</section>
<section id="decorations">
<h2>Decorations<a class="headerlink" href="#decorations" title="此标题的永久链接">¶</a></h2>
<p>Annotations/decorations provide additional information on result ids. In SPIR-V,
all instructions can generate result ids, including value-computing and
type-defining ones.</p>
<p>For decorations on value result ids, we can just have a corresponding attribute
attached to the operation generating the SSA value. For example, for the
following SPIR-V:</p>
<div class="highlight-spirv notranslate"><div class="highlight"><pre><span></span>OpDecorate %v1 RelaxedPrecision
OpDecorate %v2 NoContraction
...
%v1 = OpFMul %float %0 %0
%v2 = OpFMul %float %1 %1
</pre></div>
</div>
<p>We can represent them in the SPIR-V dialect as:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>%v1 = &quot;spirv.FMul&quot;(%0, %0) {RelaxedPrecision: unit} : (f32, f32) -&gt; (f32)
%v2 = &quot;spirv.FMul&quot;(%1, %1) {NoContraction: unit} : (f32, f32) -&gt; (f32)
</pre></div>
</div>
<p>This approach benefits transformations. Essentially those decorations are just
additional properties of the result ids (and thus their defining instructions).
In SPIR-V binary format, they are just represented as instructions. Literally
following SPIR-V binary format means we need to through def-use chains to find
the decoration instructions and query information from them.</p>
<p>For decorations on type result ids, notice that practically, only result ids
generated from composite types (e.g., <code class="docutils literal notranslate"><span class="pre">OpTypeArray</span></code>, <code class="docutils literal notranslate"><span class="pre">OpTypeStruct</span></code>) need to be
decorated for memory layouting purpose (e.g., <code class="docutils literal notranslate"><span class="pre">ArrayStride</span></code>, <code class="docutils literal notranslate"><span class="pre">Offset</span></code>, etc.);
scalar/vector types are required to be uniqued in SPIR-V. Therefore, we can just
encode them directly in the dialect-specific type.</p>
</section>
<section id="types">
<h2>Types<a class="headerlink" href="#types" title="此标题的永久链接">¶</a></h2>
<p>Theoretically we can define all SPIR-V types using MLIR extensible type system,
but other than representational purity, it does not buy us more. Instead, we
need to maintain the code and invest in pretty printing them. So we prefer to
use builtin types if possible.</p>
<p>The SPIR-V dialect reuses builtin integer, float, and vector types:</p>
<table border="1" class="docutils">
<thead>
<tr>
<th style="text-align: center;">Specification</th>
<th style="text-align: center;">Dialect</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><code>OpTypeBool</code></td>
<td style="text-align: center;"><code>i1</code></td>
</tr>
<tr>
<td style="text-align: center;"><code>OpTypeFloat &lt;bitwidth&gt;</code></td>
<td style="text-align: center;"><code>f&lt;bitwidth&gt;</code></td>
</tr>
<tr>
<td style="text-align: center;"><code>OpTypeVector &lt;scalar-type&gt; &lt;count&gt;</code></td>
<td style="text-align: center;"><code>vector&lt;&lt;count&gt; x &lt;scalar-type&gt;&gt;</code></td>
</tr>
</tbody>
</table><p>For integer types, the SPIR-V dialect supports all signedness semantics
(signless, signed, unsigned) in order to ease transformations from higher level
dialects. However, SPIR-V spec only defines two signedness semantics state: 0
indicates unsigned, or no signedness semantics, 1 indicates signed semantics. So
both <code class="docutils literal notranslate"><span class="pre">iN</span></code> and <code class="docutils literal notranslate"><span class="pre">uiN</span></code> are serialized into the same <code class="docutils literal notranslate"><span class="pre">OpTypeInt</span> <span class="pre">N</span> <span class="pre">0</span></code>. For
deserialization, we always treat <code class="docutils literal notranslate"><span class="pre">OpTypeInt</span> <span class="pre">N</span> <span class="pre">0</span></code> as <code class="docutils literal notranslate"><span class="pre">iN</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">mlir::NoneType</span></code> is used for SPIR-V <code class="docutils literal notranslate"><span class="pre">OpTypeVoid</span></code>; builtin function types are
used for SPIR-V <code class="docutils literal notranslate"><span class="pre">OpTypeFunction</span></code> types.</p>
<p>The SPIR-V dialect and defines the following dialect-specific types:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">spirv</span><span class="o">-</span><span class="nb">type</span> <span class="p">:</span><span class="o">:=</span> <span class="n">array</span><span class="o">-</span><span class="nb">type</span>
             <span class="o">|</span> <span class="n">image</span><span class="o">-</span><span class="nb">type</span>
             <span class="o">|</span> <span class="n">pointer</span><span class="o">-</span><span class="nb">type</span>
             <span class="o">|</span> <span class="n">runtime</span><span class="o">-</span><span class="n">array</span><span class="o">-</span><span class="nb">type</span>
             <span class="o">|</span> <span class="n">sampled</span><span class="o">-</span><span class="n">image</span><span class="o">-</span><span class="nb">type</span>
             <span class="o">|</span> <span class="n">struct</span><span class="o">-</span><span class="nb">type</span>
</pre></div>
</div>
<section id="array-type">
<h3>Array type<a class="headerlink" href="#array-type" title="此标题的永久链接">¶</a></h3>
<p>This corresponds to SPIR-V <a class="reference external" href="https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html#OpTypeArray">array type</a>. Its syntax is</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>element-type ::= integer-type
               | floating-point-type
               | vector-type
               | spirv-type

array-type ::= `!spirv.array` `&lt;` integer-literal `x` element-type
               (`,` `stride` `=` integer-literal)? `&gt;`
</pre></div>
</div>
<p>For example,</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>!spirv.array&lt;4 x i32&gt;
!spirv.array&lt;4 x i32, stride = 4&gt;
!spirv.array&lt;16 x vector&lt;4 x f32&gt;&gt;
</pre></div>
</div>
</section>
<section id="image-type">
<h3>Image type<a class="headerlink" href="#image-type" title="此标题的永久链接">¶</a></h3>
<p>This corresponds to SPIR-V <a class="reference external" href="https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html#OpTypeImage">image type</a>. Its syntax is</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>dim ::= `1D` | `2D` | `3D` | `Cube` | &lt;and other SPIR-V Dim specifiers...&gt;

depth-info ::= `NoDepth` | `IsDepth` | `DepthUnknown`

arrayed-info ::= `NonArrayed` | `Arrayed`

sampling-info ::= `SingleSampled` | `MultiSampled`

sampler-use-info ::= `SamplerUnknown` | `NeedSampler` | `NoSampler`

format ::= `Unknown` | `Rgba32f` | &lt;and other SPIR-V Image Formats...&gt;

image-type ::= `!spirv.image&lt;` element-type `,` dim `,` depth-info `,`
                           arrayed-info `,` sampling-info `,`
                           sampler-use-info `,` format `&gt;`
</pre></div>
</div>
<p>For example,</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>!spirv.image&lt;f32, 1D, NoDepth, NonArrayed, SingleSampled, SamplerUnknown, Unknown&gt;
!spirv.image&lt;f32, Cube, IsDepth, Arrayed, MultiSampled, NeedSampler, Rgba32f&gt;
</pre></div>
</div>
</section>
<section id="pointer-type">
<h3>Pointer type<a class="headerlink" href="#pointer-type" title="此标题的永久链接">¶</a></h3>
<p>This corresponds to SPIR-V <a class="reference external" href="https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html#OpTypePointer">pointer type</a>. Its syntax is</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>storage-class ::= `UniformConstant`
                | `Uniform`
                | `Workgroup`
                | &lt;and other storage classes...&gt;

pointer-type ::= `!spirv.ptr&lt;` element-type `,` storage-class `&gt;`
</pre></div>
</div>
<p>For example,</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>!spirv.ptr&lt;i32, Function&gt;
!spirv.ptr&lt;vector&lt;4 x f32&gt;, Uniform&gt;
</pre></div>
</div>
</section>
<section id="runtime-array-type">
<h3>Runtime array type<a class="headerlink" href="#runtime-array-type" title="此标题的永久链接">¶</a></h3>
<p>This corresponds to SPIR-V <a class="reference external" href="https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html#OpTypeRuntimeArray">runtime array type</a>. Its syntax is</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>runtime-array-type ::= `!spirv.rtarray` `&lt;` element-type (`,` `stride` `=` integer-literal)? `&gt;`
</pre></div>
</div>
<p>For example,</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>!spirv.rtarray&lt;i32&gt;
!spirv.rtarray&lt;i32, stride=4&gt;
!spirv.rtarray&lt;vector&lt;4 x f32&gt;&gt;
</pre></div>
</div>
</section>
<section id="sampled-image-type">
<h3>Sampled image type<a class="headerlink" href="#sampled-image-type" title="此标题的永久链接">¶</a></h3>
<p>This corresponds to SPIR-V <a class="reference external" href="https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html#OpTypeSampledImage">sampled image type</a>. Its syntax is</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>sampled-image-type ::= `!spirv.sampled_image&lt;!spirv.image&lt;` element-type `,` dim `,` depth-info `,`
                                                        arrayed-info `,` sampling-info `,`
                                                        sampler-use-info `,` format `&gt;&gt;`
</pre></div>
</div>
<p>For example,</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>!spirv.sampled_image&lt;!spirv.image&lt;f32, Dim1D, NoDepth, NonArrayed, SingleSampled, NoSampler, Unknown&gt;&gt;
!spirv.sampled_image&lt;!spirv.image&lt;i32, Rect, DepthUnknown, Arrayed, MultiSampled, NeedSampler, R8ui&gt;&gt;
</pre></div>
</div>
</section>
<section id="struct-type">
<h3>Struct type<a class="headerlink" href="#struct-type" title="此标题的永久链接">¶</a></h3>
<p>This corresponds to SPIR-V <a class="reference external" href="https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html#Structure">struct type</a>. Its syntax is</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>struct-member-decoration ::= integer-literal? spirv-decoration*
struct-type ::= `!spirv.struct&lt;` spirv-type (`[` struct-member-decoration `]`)?
                     (`, ` spirv-type (`[` struct-member-decoration `]`)?
</pre></div>
</div>
<p>For Example,</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>!spirv.struct&lt;f32&gt;
!spirv.struct&lt;f32 [0]&gt;
!spirv.struct&lt;f32, !spirv.image&lt;f32, 1D, NoDepth, NonArrayed, SingleSampled, SamplerUnknown, Unknown&gt;&gt;
!spirv.struct&lt;f32 [0], i32 [4]&gt;
</pre></div>
</div>
</section>
</section>
<section id="function">
<h2>Function<a class="headerlink" href="#function" title="此标题的永久链接">¶</a></h2>
<p>In SPIR-V, a function construct consists of multiple instructions involving
<code class="docutils literal notranslate"><span class="pre">OpFunction</span></code>, <code class="docutils literal notranslate"><span class="pre">OpFunctionParameter</span></code>, <code class="docutils literal notranslate"><span class="pre">OpLabel</span></code>, <code class="docutils literal notranslate"><span class="pre">OpFunctionEnd</span></code>.</p>
<div class="highlight-spirv notranslate"><div class="highlight"><pre><span></span>// int f(int v) { return v; }
%1 = OpTypeInt 32 0
%2 = OpTypeFunction %1 %1
%3 = OpFunction %1 %2
%4 = OpFunctionParameter %1
%5 = OpLabel
%6 = OpReturnValue %4
     OpFunctionEnd
</pre></div>
</div>
<p>This construct is very clear yet quite verbose. It is intended for driver
consumption. There is little benefit to literally replicate this construct in
the SPIR-V dialect. Instead, we reuse the builtin <code class="docutils literal notranslate"><span class="pre">func</span></code> op to express functions
more concisely:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>func.func @f(%arg: i32) -&gt; i32 {
  &quot;spirv.ReturnValue&quot;(%arg) : (i32) -&gt; (i32)
}
</pre></div>
</div>
<p>A SPIR-V function can have at most one result. It cannot contain nested
functions or non-SPIR-V operations. <code class="docutils literal notranslate"><span class="pre">spirv.module</span></code> verifies these requirements.</p>
<p>A major difference between the SPIR-V dialect and the SPIR-V specification for
functions is that the former are isolated and require explicit capturing, while
the latter allows implicit capturing. In SPIR-V specification, functions can
refer to SSA values (generated by constants, global variables, etc.) defined in
modules. The SPIR-V dialect adjusted how constants and global variables are
modeled to enable isolated functions. Isolated functions are more friendly to
compiler analyses and transformations. This also enables the SPIR-V dialect to
better utilize core infrastructure: many functionalities in the core
infrastructure require ops to be isolated, e.g., the
<a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp">greedy pattern rewriter</a> can only act on ops isolated
from above.</p>
<p>(TODO: create a dedicated <code class="docutils literal notranslate"><span class="pre">spirv.fn</span></code> op for SPIR-V functions.)</p>
</section>
<section id="operations">
<h2>Operations<a class="headerlink" href="#operations" title="此标题的永久链接">¶</a></h2>
<p>In SPIR-V, instruction is a generalized concept; a SPIR-V module is just a
sequence of instructions. Declaring types, expressing computations, annotating
result ids, expressing control flows and others are all in the form of
instructions.</p>
<p>We only discuss instructions expressing computations here, which can be
represented via SPIR-V dialect ops. Module-level instructions for declarations
and definitions are represented differently in the SPIR-V dialect as explained
earlier in the <a class="reference external" href="#module-level-operations">Module-level operations</a> section.</p>
<p>An instruction computes zero or one result from zero or more operands. The
result is a new result id. An operand can be a result id generated by a previous
instruction, an immediate value, or a case of an enum type. We can model result
id operands and results with MLIR SSA values; for immediate value and enum
cases, we can model them with MLIR attributes.</p>
<p>For example,</p>
<div class="highlight-spirv notranslate"><div class="highlight"><pre><span></span>%i32 = OpTypeInt 32 0
%c42 = OpConstant %i32 42
...
%3 = OpVariable %i32 Function 42
%4 = OpIAdd %i32 %c42 %c42
</pre></div>
</div>
<p>can be represented in the dialect as</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>%0 = &quot;spirv.Constant&quot;() { value = 42 : i32 } : () -&gt; i32
%1 = &quot;spirv.Variable&quot;(%0) { storage_class = &quot;Function&quot; } : (i32) -&gt; !spirv.ptr&lt;i32, Function&gt;
%2 = &quot;spirv.IAdd&quot;(%0, %0) : (i32, i32) -&gt; i32
</pre></div>
</div>
<p>Operation documentation is written in each op’s Op Definition Spec using
TableGen. A markdown version of the doc can be generated using
<code class="docutils literal notranslate"><span class="pre">mlir-tblgen</span> <span class="pre">-gen-doc</span></code> and is attached in the
<a class="reference external" href="#operation-definitions">Operation definitions</a> section.</p>
<section id="ops-from-extended-instruction-sets">
<h3>Ops from extended instruction sets<a class="headerlink" href="#ops-from-extended-instruction-sets" title="此标题的永久链接">¶</a></h3>
<p>Analogically extended instruction set is a mechanism to import SPIR-V
instructions within another namespace. <a class="reference external" href="https://www.khronos.org/registry/spir-v/specs/1.0/GLSL.std.450.html"><code class="docutils literal notranslate"><span class="pre">GLSL.std.450</span></code></a> is an
extended instruction set that provides common mathematical routines that should
be supported. Instead of modeling <code class="docutils literal notranslate"><span class="pre">OpExtInstImport</span></code> as a separate op and use a
single op to model <code class="docutils literal notranslate"><span class="pre">OpExtInst</span></code> for all extended instructions, we model each
SPIR-V instruction in an extended instruction set as a separate op with the
proper name prefix. For example, for</p>
<div class="highlight-spirv notranslate"><div class="highlight"><pre><span></span>%glsl = OpExtInstImport &quot;GLSL.std.450&quot;

%f32 = OpTypeFloat 32
%cst = OpConstant %f32 ...

%1 = OpExtInst %f32 %glsl 28 %cst
%2 = OpExtInst %f32 %glsl 31 %cst
</pre></div>
</div>
<p>we can have</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>%1 = &quot;spirv.GL.Log&quot;(%cst) : (f32) -&gt; (f32)
%2 = &quot;spirv.GL.Sqrt&quot;(%cst) : (f32) -&gt; (f32)
</pre></div>
</div>
</section>
</section>
<section id="control-flow">
<h2>Control Flow<a class="headerlink" href="#control-flow" title="此标题的永久链接">¶</a></h2>
<p>SPIR-V binary format uses merge instructions (<code class="docutils literal notranslate"><span class="pre">OpSelectionMerge</span></code> and
<code class="docutils literal notranslate"><span class="pre">OpLoopMerge</span></code>) to declare structured control flow. They explicitly declare a
header block before the control flow diverges and a merge block where control
flow subsequently converges. These blocks delimit constructs that must nest, and
can only be entered and exited in structured ways.</p>
<p>In the SPIR-V dialect, we use regions to mark the boundary of a structured
control flow construct. With this approach, it’s easier to discover all blocks
belonging to a structured control flow construct. It is also more idiomatic to
MLIR system.</p>
<p>We introduce a <code class="docutils literal notranslate"><span class="pre">spirv.mlir.selection</span></code> and <code class="docutils literal notranslate"><span class="pre">spirv.mlir.loop</span></code> op for structured selections and
loops, respectively. The merge targets are the next ops following them. Inside
their regions, a special terminator, <code class="docutils literal notranslate"><span class="pre">spirv.mlir.merge</span></code> is introduced for branching to
the merge target.</p>
<section id="selection">
<h3>Selection<a class="headerlink" href="#selection" title="此标题的永久链接">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">spirv.mlir.selection</span></code> defines a selection construct. It contains one region. The
region should contain at least two blocks: one selection header block and one
merge block.</p>
<ul class="simple">
<li><p>The selection header block should be the first block. It should contain the
<code class="docutils literal notranslate"><span class="pre">spirv.BranchConditional</span></code> or <code class="docutils literal notranslate"><span class="pre">spirv.Switch</span></code> op.</p></li>
<li><p>The merge block should be the last block. The merge block should only
contain a <code class="docutils literal notranslate"><span class="pre">spirv.mlir.merge</span></code> op. Any block can branch to the merge block for early
exit.</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>               <span class="o">+--------------+</span>
               <span class="o">|</span> <span class="n">header</span> <span class="n">block</span> <span class="o">|</span>                 <span class="p">(</span><span class="n">may</span> <span class="n">have</span> <span class="n">multiple</span> <span class="n">outgoing</span> <span class="n">branches</span><span class="p">)</span>
               <span class="o">+--------------+</span>
                    <span class="o">/</span> <span class="o">|</span> \
                     <span class="o">...</span>


   <span class="o">+---------+</span>   <span class="o">+---------+</span>   <span class="o">+---------+</span>
   <span class="o">|</span> <span class="n">case</span> <span class="c1">#0 |   | case #1 |   | case #2 |  ... (may have branches between each other)</span>
   <span class="o">+---------+</span>   <span class="o">+---------+</span>   <span class="o">+---------+</span>


                     <span class="o">...</span>
                    \ <span class="o">|</span> <span class="o">/</span>
                      <span class="n">v</span>
               <span class="o">+-------------+</span>
               <span class="o">|</span> <span class="n">merge</span> <span class="n">block</span> <span class="o">|</span>                  <span class="p">(</span><span class="n">may</span> <span class="n">have</span> <span class="n">multiple</span> <span class="n">incoming</span> <span class="n">branches</span><span class="p">)</span>
               <span class="o">+-------------+</span>
</pre></div>
</div>
<p>For example, for the given function</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">loop</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">cond</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cond</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It will be represented as</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>func.func @selection(%cond: i1) -&gt; () {
  %zero = spirv.Constant 0: i32
  %one = spirv.Constant 1: i32
  %two = spirv.Constant 2: i32
  %x = spirv.Variable init(%zero) : !spirv.ptr&lt;i32, Function&gt;

  spirv.mlir.selection {
    spirv.BranchConditional %cond, ^then, ^else

  ^then:
    spirv.Store &quot;Function&quot; %x, %one : i32
    spirv.Branch ^merge

  ^else:
    spirv.Store &quot;Function&quot; %x, %two : i32
    spirv.Branch ^merge

  ^merge:
    spirv.mlir.merge
  }

  // ...
}
</pre></div>
</div>
</section>
<section id="loop">
<h3>Loop<a class="headerlink" href="#loop" title="此标题的永久链接">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">spirv.mlir.loop</span></code> defines a loop construct. It contains one region. The region should
contain at least four blocks: one entry block, one loop header block, one loop
continue block, one merge block.</p>
<ul class="simple">
<li><p>The entry block should be the first block and it should jump to the loop
header block, which is the second block.</p></li>
<li><p>The merge block should be the last block. The merge block should only
contain a <code class="docutils literal notranslate"><span class="pre">spirv.mlir.merge</span></code> op. Any block except the entry block can branch to
the merge block for early exit.</p></li>
<li><p>The continue block should be the second to last block and it should have a
branch to the loop header block.</p></li>
<li><p>The loop continue block should be the only block, except the entry block,
branching to the loop header block.</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="o">+-------------+</span>
    <span class="o">|</span> <span class="n">entry</span> <span class="n">block</span> <span class="o">|</span>           <span class="p">(</span><span class="n">one</span> <span class="n">outgoing</span> <span class="n">branch</span><span class="p">)</span>
    <span class="o">+-------------+</span>
           <span class="o">|</span>
           <span class="n">v</span>
    <span class="o">+-------------+</span>           <span class="p">(</span><span class="n">two</span> <span class="n">incoming</span> <span class="n">branches</span><span class="p">)</span>
    <span class="o">|</span> <span class="n">loop</span> <span class="n">header</span> <span class="o">|</span> <span class="o">&lt;-----+</span>   <span class="p">(</span><span class="n">may</span> <span class="n">have</span> <span class="n">one</span> <span class="ow">or</span> <span class="n">two</span> <span class="n">outgoing</span> <span class="n">branches</span><span class="p">)</span>
    <span class="o">+-------------+</span>       <span class="o">|</span>
                          <span class="o">|</span>
          <span class="o">...</span>             <span class="o">|</span>
         \ <span class="o">|</span> <span class="o">/</span>            <span class="o">|</span>
           <span class="n">v</span>              <span class="o">|</span>
   <span class="o">+---------------+</span>      <span class="o">|</span>   <span class="p">(</span><span class="n">may</span> <span class="n">have</span> <span class="n">multiple</span> <span class="n">incoming</span> <span class="n">branches</span><span class="p">)</span>
   <span class="o">|</span> <span class="n">loop</span> <span class="k">continue</span> <span class="o">|</span> <span class="o">-----+</span>   <span class="p">(</span><span class="n">may</span> <span class="n">have</span> <span class="n">one</span> <span class="ow">or</span> <span class="n">two</span> <span class="n">outgoing</span> <span class="n">branches</span><span class="p">)</span>
   <span class="o">+---------------+</span>

          <span class="o">...</span>
         \ <span class="o">|</span> <span class="o">/</span>
           <span class="n">v</span>
    <span class="o">+-------------+</span>           <span class="p">(</span><span class="n">may</span> <span class="n">have</span> <span class="n">multiple</span> <span class="n">incoming</span> <span class="n">branches</span><span class="p">)</span>
    <span class="o">|</span> <span class="n">merge</span> <span class="n">block</span> <span class="o">|</span>
    <span class="o">+-------------+</span>
</pre></div>
</div>
<p>The reason to have another entry block instead of directly using the loop header
block as the entry block is to satisfy region’s requirement: entry block of
region may not have predecessors. We have a merge block so that branch ops can
reference it as successors. The loop continue block here corresponds to
“continue construct” using SPIR-V spec’s term; it does not mean the “continue
block” as defined in the SPIR-V spec, which is “a block containing a branch to
an OpLoopMerge instruction’s Continue Target.”</p>
<p>For example, for the given function</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">loop</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">count</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>It will be represented as</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>func.func @loop(%count : i32) -&gt; () {
  %zero = spirv.Constant 0: i32
  %one = spirv.Constant 1: i32
  %var = spirv.Variable init(%zero) : !spirv.ptr&lt;i32, Function&gt;

  spirv.mlir.loop {
    spirv.Branch ^header

  ^header:
    %val0 = spirv.Load &quot;Function&quot; %var : i32
    %cmp = spirv.SLessThan %val0, %count : i32
    spirv.BranchConditional %cmp, ^body, ^merge

  ^body:
    // ...
    spirv.Branch ^continue

  ^continue:
    %val1 = spirv.Load &quot;Function&quot; %var : i32
    %add = spirv.IAdd %val1, %one : i32
    spirv.Store &quot;Function&quot; %var, %add : i32
    spirv.Branch ^header

  ^merge:
    spirv.mlir.merge
  }
  return
}
</pre></div>
</div>
</section>
<section id="block-argument-for-phi">
<h3>Block argument for Phi<a class="headerlink" href="#block-argument-for-phi" title="此标题的永久链接">¶</a></h3>
<p>There are no direct Phi operations in the SPIR-V dialect; SPIR-V <code class="docutils literal notranslate"><span class="pre">OpPhi</span></code>
instructions are modelled as block arguments in the SPIR-V dialect. (See the
<a class="reference external" href="../Rationale/Rationale.md/#block-arguments-vs-phi-nodes">Rationale</a> doc for “Block Arguments vs Phi nodes”.) Each block
argument corresponds to one <code class="docutils literal notranslate"><span class="pre">OpPhi</span></code> instruction in the SPIR-V binary format. For
example, for the following SPIR-V function <code class="docutils literal notranslate"><span class="pre">foo</span></code>:</p>
<div class="highlight-spirv notranslate"><div class="highlight"><pre><span></span>  %foo = OpFunction %void None ...
%entry = OpLabel
  %var = OpVariable %_ptr_Function_int Function
         OpSelectionMerge %merge None
         OpBranchConditional %true %true %false
 %true = OpLabel
         OpBranch %phi
%false = OpLabel
         OpBranch %phi
  %phi = OpLabel
  %val = OpPhi %int %int_1 %false %int_0 %true
         OpStore %var %val
         OpReturn
%merge = OpLabel
         OpReturn
         OpFunctionEnd
</pre></div>
</div>
<p>It will be represented as:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>func.func @foo() -&gt; () {
  %var = spirv.Variable : !spirv.ptr&lt;i32, Function&gt;

  spirv.mlir.selection {
    %true = spirv.Constant true
    spirv.BranchConditional %true, ^true, ^false

  ^true:
    %zero = spirv.Constant 0 : i32
    spirv.Branch ^phi(%zero: i32)

  ^false:
    %one = spirv.Constant 1 : i32
    spirv.Branch ^phi(%one: i32)

  ^phi(%arg: i32):
    spirv.Store &quot;Function&quot; %var, %arg : i32
    spirv.Return

  ^merge:
    spirv.mlir.merge
  }
  spirv.Return
}
</pre></div>
</div>
</section>
</section>
<section id="version-extensions-capabilities">
<h2>Version, extensions, capabilities<a class="headerlink" href="#version-extensions-capabilities" title="此标题的永久链接">¶</a></h2>
<p>SPIR-V supports versions, extensions, and capabilities as ways to indicate the
availability of various features (types, ops, enum cases) on target hardware.
For example, non-uniform group operations were missing before v1.3, and they
require special capabilities like <code class="docutils literal notranslate"><span class="pre">GroupNonUniformArithmetic</span></code> to be used. These
availability information relates to <a class="reference external" href="#target-environment">target environment</a>
and affects the legality of patterns during dialect conversion.</p>
<p>SPIR-V ops’ availability requirements are modeled with
<a class="reference external" href="../Interfaces/#operation-interfaces">op interfaces</a>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">QueryMinVersionInterface</span></code> and <code class="docutils literal notranslate"><span class="pre">QueryMaxVersionInterface</span></code> for version
requirements</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">QueryExtensionInterface</span></code> for extension requirements</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">QueryCapabilityInterface</span></code> for capability requirements</p></li>
</ul>
<p>These interface declarations are auto-generated from TableGen definitions
included in <a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVBase.td"><code class="docutils literal notranslate"><span class="pre">SPIRVBase.td</span></code></a>. At the moment all SPIR-V ops
implement the above interfaces.</p>
<p>SPIR-V ops’ availability implementation methods are automatically synthesized
from the availability specification on each op and enum attribute in TableGen.
An op needs to look into not only the opcode but also operands to derive its
availability requirements. For example, <code class="docutils literal notranslate"><span class="pre">spirv.ControlBarrier</span></code> requires no
special capability if the execution scope is <code class="docutils literal notranslate"><span class="pre">Subgroup</span></code>, but it will require
the <code class="docutils literal notranslate"><span class="pre">VulkanMemoryModel</span></code> capability if the scope is <code class="docutils literal notranslate"><span class="pre">QueueFamily</span></code>.</p>
<p>SPIR-V types’ availability implementation methods are manually written as
overrides in the SPIR-V <a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVTypes.h">type hierarchy</a>.</p>
<p>These availability requirements serve as the “ingredients” for the
<a class="reference external" href="#spirvconversiontarget"><code class="docutils literal notranslate"><span class="pre">SPIRVConversionTarget</span></code></a> and
<a class="reference external" href="#spirvtypeconverter"><code class="docutils literal notranslate"><span class="pre">SPIRVTypeConverter</span></code></a> to perform op and type conversions,
by following the requirements in <a class="reference external" href="#target-environment">target environment</a>.</p>
</section>
<section id="target-environment">
<h2>Target environment<a class="headerlink" href="#target-environment" title="此标题的永久链接">¶</a></h2>
<p>SPIR-V aims to support multiple execution environments as specified by client
APIs. These execution environments affect the availability of certain SPIR-V
features. For example, a <a class="reference external" href="https://renderdoc.org/vkspec_chunked/chap40.html#spirvenv">Vulkan 1.1</a> implementation must support
the 1.0, 1.1, 1.2, and 1.3 versions of SPIR-V and the 1.0 version of the SPIR-V
extended instructions for GLSL. Further Vulkan extensions may enable more SPIR-V
instructions.</p>
<p>SPIR-V compilation should also take into consideration of the execution
environment, so we generate SPIR-V modules valid for the target environment.
This is conveyed by the <code class="docutils literal notranslate"><span class="pre">spirv.target_env</span></code> (<code class="docutils literal notranslate"><span class="pre">spirv::TargetEnvAttr</span></code>) attribute. It
should be of <code class="docutils literal notranslate"><span class="pre">#spirv.target_env</span></code> attribute kind, which is defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>spirv-version    ::= `v1.0` | `v1.1` | ...
spirv-extension  ::= `SPV_KHR_16bit_storage` | `SPV_EXT_physical_storage_buffer` | ...
spirv-capability ::= `Shader` | `Kernel` | `GroupNonUniform` | ...

spirv-extension-list     ::= `[` (spirv-extension-elements)? `]`
spirv-extension-elements ::= spirv-extension (`,` spirv-extension)*

spirv-capability-list     ::= `[` (spirv-capability-elements)? `]`
spirv-capability-elements ::= spirv-capability (`,` spirv-capability)*

spirv-resource-limits ::= dictionary-attribute

spirv-vce-attribute ::= `#` `spirv.vce` `&lt;`
                            spirv-version `,`
                            spirv-capability-list `,`
                            spirv-extensions-list `&gt;`

spirv-vendor-id ::= `AMD` | `NVIDIA` | ...
spirv-device-type ::= `DiscreteGPU` | `IntegratedGPU` | `CPU` | ...
spirv-device-id ::= integer-literal
spirv-device-info ::= spirv-vendor-id (`:` spirv-device-type (`:` spirv-device-id)?)?

spirv-target-env-attribute ::= `#` `spirv.target_env` `&lt;`
                                  spirv-vce-attribute,
                                  (spirv-device-info `,`)?
                                  spirv-resource-limits `&gt;`
</pre></div>
</div>
<p>The attribute has a few fields:</p>
<ul class="simple">
<li><p>A <code class="docutils literal notranslate"><span class="pre">#spirv.vce</span></code> (<code class="docutils literal notranslate"><span class="pre">spirv::VerCapExtAttr</span></code>) attribute:</p>
<ul>
<li><p>The target SPIR-V version.</p></li>
<li><p>A list of SPIR-V extensions for the target.</p></li>
<li><p>A list of SPIR-V capabilities for the target.</p></li>
</ul>
</li>
<li><p>A dictionary of target resource limits (see the
<a class="reference external" href="https://renderdoc.org/vkspec_chunked/chap36.html#limits">Vulkan spec</a> for explanation):</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">max_compute_workgroup_invocations</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">max_compute_workgroup_size</span></code></p></li>
</ul>
</li>
</ul>
<p>For example,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">module</span> <span class="n">attributes</span> <span class="p">{</span>
<span class="n">spirv</span><span class="o">.</span><span class="n">target_env</span> <span class="o">=</span> <span class="c1">#spirv.target_env&lt;</span>
    <span class="c1">#spirv.vce&lt;v1.3, [Shader, GroupNonUniform], [SPV_KHR_8bit_storage]&gt;,</span>
    <span class="n">ARM</span><span class="p">:</span><span class="n">IntegratedGPU</span><span class="p">,</span>
    <span class="p">{</span>
      <span class="n">max_compute_workgroup_invocations</span> <span class="o">=</span> <span class="mi">128</span> <span class="p">:</span> <span class="n">i32</span><span class="p">,</span>
      <span class="n">max_compute_workgroup_size</span> <span class="o">=</span> <span class="n">dense</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">64</span><span class="p">]</span><span class="o">&gt;</span> <span class="p">:</span> <span class="n">vector</span><span class="o">&lt;</span><span class="mi">3</span><span class="n">xi32</span><span class="o">&gt;</span>
    <span class="p">}</span><span class="o">&gt;</span>
<span class="p">}</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</pre></div>
</div>
<p>Dialect conversion framework will utilize the information in <code class="docutils literal notranslate"><span class="pre">spirv.target_env</span></code> to
properly filter out patterns and ops not available in the target execution
environment. When targeting SPIR-V, one needs to create a
<a class="reference external" href="#spirvconversiontarget"><code class="docutils literal notranslate"><span class="pre">SPIRVConversionTarget</span></code></a> by providing such an
attribute.</p>
</section>
<section id="shader-interface-abi">
<h2>Shader interface (ABI)<a class="headerlink" href="#shader-interface-abi" title="此标题的永久链接">¶</a></h2>
<p>SPIR-V itself is just expressing computation happening on GPU device. SPIR-V
programs themselves are not enough for running workloads on GPU; a companion
host application is needed to manage the resources referenced by SPIR-V programs
and dispatch the workload. For the Vulkan execution environment, the host
application will be written using Vulkan API. Unlike CUDA, the SPIR-V program
and the Vulkan application are typically authored with different front-end
languages, which isolates these two worlds. Yet they still need to match
<em>interfaces</em>: the variables declared in a SPIR-V program for referencing
resources need to match with the actual resources managed by the application
regarding their parameters.</p>
<p>Still using Vulkan as an example execution environment, there are two primary
resource types in Vulkan: buffers and images. They are used to back various uses
that may differ regarding the classes of operations (load, store, atomic) to be
performed. These uses are differentiated via descriptor types. (For example,
uniform storage buffer descriptors can only support load operations while
storage buffer descriptors can support load, store, and atomic operations.)
Vulkan uses a binding model for resources. Resources are associated with
descriptors and descriptors are further grouped into sets. Each descriptor thus
has a set number and a binding number. Descriptors in the application
corresponds to variables in the SPIR-V program. Their parameters must match,
including but not limited to set and binding numbers.</p>
<p>Apart from buffers and images, there is other data that is set up by Vulkan and
referenced inside the SPIR-V program, for example, push constants. They also
have parameters that require matching between the two worlds.</p>
<p>The interface requirements are external information to the SPIR-V compilation
path in MLIR. Besides, each Vulkan application may want to handle resources
differently. To avoid duplication and to share common utilities, a SPIR-V shader
interface specification needs to be defined to provide the external requirements
to and guide the SPIR-V compilation path.</p>
<section id="shader-interface-attributes">
<h3>Shader interface attributes<a class="headerlink" href="#shader-interface-attributes" title="此标题的永久链接">¶</a></h3>
<p>The SPIR-V dialect defines <a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/SPIRV/IR/TargetAndABI.h">a few attributes</a> for specifying these
interfaces:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">spirv.entry_point_abi</span></code> is a struct attribute that should be attached to the
entry function. It contains:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">local_size</span></code> for specifying the local work group size for the dispatch.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">spirv.interface_var_abi</span></code> is attribute that should be attached to each operand
and result of the entry function. It should be of <code class="docutils literal notranslate"><span class="pre">#spirv.interface_var_abi</span></code>
attribute kind, which is defined as:</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>spv-storage-class     ::= `StorageBuffer` | ...
spv-descriptor-set    ::= integer-literal
spv-binding           ::= integer-literal
spv-interface-var-abi ::= `#` `spirv.interface_var_abi` `&lt;(` spv-descriptor-set
                          `,` spv-binding `)` (`,` spv-storage-class)? `&gt;`
</pre></div>
</div>
<p>For example,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#spirv.interface_var_abi&lt;(0, 0), StorageBuffer&gt;</span>
<span class="c1">#spirv.interface_var_abi&lt;(0, 1)&gt;</span>
</pre></div>
</div>
<p>The attribute has a few fields:</p>
<ul class="simple">
<li><p>Descriptor set number for the corresponding resource variable.</p></li>
<li><p>Binding number for the corresponding resource variable.</p></li>
<li><p>Storage class for the corresponding resource variable.</p></li>
</ul>
<p>The SPIR-V dialect provides a <a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/SPIRV/Transforms/Passes.h"><code class="docutils literal notranslate"><span class="pre">LowerABIAttributesPass</span></code></a> that
uses this information to lower the entry point function and its ABI consistent
with the Vulkan validation rules. Specifically,</p>
<ul class="simple">
<li><p>Creates <code class="docutils literal notranslate"><span class="pre">spirv.GlobalVariable</span></code>s for the arguments, and replaces all uses of
the argument with this variable. The SSA value used for replacement is
obtained using the <code class="docutils literal notranslate"><span class="pre">spirv.mlir.addressof</span></code> operation.</p></li>
<li><p>Adds the <code class="docutils literal notranslate"><span class="pre">spirv.EntryPoint</span></code> and <code class="docutils literal notranslate"><span class="pre">spirv.ExecutionMode</span></code> operations into the
<code class="docutils literal notranslate"><span class="pre">spirv.module</span></code> for the entry function.</p></li>
</ul>
</section>
</section>
<section id="serialization-and-deserialization">
<h2>Serialization and deserialization<a class="headerlink" href="#serialization-and-deserialization" title="此标题的永久链接">¶</a></h2>
<p>Although the main objective of the SPIR-V dialect is to act as a proper IR for
compiler transformations, being able to serialize to and deserialize from the
binary format is still very valuable for many good reasons. Serialization
enables the artifacts of SPIR-V compilation to be consumed by an execution
environment; deserialization allows us to import SPIR-V binary modules and run
transformations on them. So serialization and deserialization are supported from
the very beginning of the development of the SPIR-V dialect.</p>
<p>The serialization library provides two entry points, <code class="docutils literal notranslate"><span class="pre">mlir::spirv::serialize()</span></code>
and <code class="docutils literal notranslate"><span class="pre">mlir::spirv::deserialize()</span></code>, for converting a MLIR SPIR-V module to binary
format and back. The <a class="reference external" href="#code-organization">Code organization</a> explains more about
this.</p>
<p>Given that the focus is transformations, which inevitably means changes to the
binary module; so serialization is not designed to be a general tool for
investigating the SPIR-V binary module and does not guarantee roundtrip
equivalence (at least for now). For the latter, please use the
assembler/disassembler in the <a class="reference external" href="https://github.com/KhronosGroup/SPIRV-Tools">SPIRV-Tools</a> project.</p>
<p>A few transformations are performed in the process of serialization because of
the representational differences between SPIR-V dialect and binary format:</p>
<ul class="simple">
<li><p>Attributes on <code class="docutils literal notranslate"><span class="pre">spirv.module</span></code> are emitted as their corresponding SPIR-V
instructions.</p></li>
<li><p>Types are serialized into <code class="docutils literal notranslate"><span class="pre">OpType*</span></code> instructions in the SPIR-V binary module
section for types, constants, and global variables.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">spirv.Constant</span></code>s are unified and placed in the SPIR-V binary module section
for types, constants, and global variables.</p></li>
<li><p>Attributes on ops, if not part of the op’s binary encoding, are emitted as
<code class="docutils literal notranslate"><span class="pre">OpDecorate*</span></code> instructions in the SPIR-V binary module section for
decorations.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">spirv.mlir.selection</span></code>s and <code class="docutils literal notranslate"><span class="pre">spirv.mlir.loop</span></code>s are emitted as basic blocks with <code class="docutils literal notranslate"><span class="pre">Op*Merge</span></code>
instructions in the header block as required by the binary format.</p></li>
<li><p>Block arguments are materialized as <code class="docutils literal notranslate"><span class="pre">OpPhi</span></code> instructions at the beginning of
the corresponding blocks.</p></li>
</ul>
<p>Similarly, a few transformations are performed during deserialization:</p>
<ul class="simple">
<li><p>Instructions for execution environment requirements (extensions,
capabilities, extended instruction sets, etc.) will be placed as attributes
on <code class="docutils literal notranslate"><span class="pre">spirv.module</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">OpType*</span></code> instructions will be converted into proper <code class="docutils literal notranslate"><span class="pre">mlir::Type</span></code>s.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">OpConstant*</span></code> instructions are materialized as <code class="docutils literal notranslate"><span class="pre">spirv.Constant</span></code> at each use
site.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">OpVariable</span></code> instructions will be converted to <code class="docutils literal notranslate"><span class="pre">spirv.GlobalVariable</span></code> ops if
in module-level; otherwise they will be converted into <code class="docutils literal notranslate"><span class="pre">spirv.Variable</span></code> ops.</p></li>
<li><p>Every use of a module-level <code class="docutils literal notranslate"><span class="pre">OpVariable</span></code> instruction will materialize a
<code class="docutils literal notranslate"><span class="pre">spirv.mlir.addressof</span></code> op to turn the symbol of the corresponding
<code class="docutils literal notranslate"><span class="pre">spirv.GlobalVariable</span></code> into an SSA value.</p></li>
<li><p>Every use of a <code class="docutils literal notranslate"><span class="pre">OpSpecConstant</span></code> instruction will materialize a
<code class="docutils literal notranslate"><span class="pre">spirv.mlir.referenceof</span></code> op to turn the symbol of the corresponding
<code class="docutils literal notranslate"><span class="pre">spirv.SpecConstant</span></code> into an SSA value.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">OpPhi</span></code> instructions are converted to block arguments.</p></li>
<li><p>Structured control flow are placed inside <code class="docutils literal notranslate"><span class="pre">spirv.mlir.selection</span></code> and <code class="docutils literal notranslate"><span class="pre">spirv.mlir.loop</span></code>.</p></li>
</ul>
</section>
<section id="conversions">
<h2>Conversions<a class="headerlink" href="#conversions" title="此标题的永久链接">¶</a></h2>
<p>One of the main features of MLIR is the ability to progressively lower from
dialects that capture programmer abstraction into dialects that are closer to a
machine representation, like SPIR-V dialect. This progressive lowering through
multiple dialects is enabled through the use of the
<a class="reference internal" href="../DialectConversion.html"><span class="doc">DialectConversion</span></a> framework in MLIR. To simplify
targeting SPIR-V dialect using the Dialect Conversion framework, two utility
classes are provided.</p>
<p>(<strong>Note</strong> : While SPIR-V has some <a class="reference external" href="https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html#_a_id_shadervalidation_a_validation_rules_for_shader_a_href_capability_capabilities_a">validation rules</a>,
additional rules are imposed by <a class="reference external" href="https://renderdoc.org/vkspec_chunked/chap40.html#spirvenv">Vulkan execution environment</a>. The
lowering described below implements both these requirements.)</p>
<section id="spirvconversiontarget">
<h3><code class="docutils literal notranslate"><span class="pre">SPIRVConversionTarget</span></code><a class="headerlink" href="#spirvconversiontarget" title="此标题的永久链接">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">mlir::spirv::SPIRVConversionTarget</span></code> class derives from the
<code class="docutils literal notranslate"><span class="pre">mlir::ConversionTarget</span></code> class and serves as a utility to define a conversion
target satisfying a given <a class="reference external" href="#target-environment"><code class="docutils literal notranslate"><span class="pre">spirv.target_env</span></code></a>. It registers
proper hooks to check the dynamic legality of SPIR-V ops. Users can further
register other legality constraints into the returned <code class="docutils literal notranslate"><span class="pre">SPIRVConversionTarget</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">spirv::lookupTargetEnvOrDefault()</span></code> is a handy utility function to query an
<code class="docutils literal notranslate"><span class="pre">spirv.target_env</span></code> attached in the input IR or use the default to construct a
<code class="docutils literal notranslate"><span class="pre">SPIRVConversionTarget</span></code>.</p>
</section>
<section id="spirvtypeconverter">
<h3><code class="docutils literal notranslate"><span class="pre">SPIRVTypeConverter</span></code><a class="headerlink" href="#spirvtypeconverter" title="此标题的永久链接">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">mlir::SPIRVTypeConverter</span></code> derives from <code class="docutils literal notranslate"><span class="pre">mlir::TypeConverter</span></code> and provides
type conversion for builtin types to SPIR-V types conforming to the
<a class="reference external" href="#target-environment">target environment</a> it is constructed with. If the
required extension/capability for the resultant type is not available in the
given target environment, <code class="docutils literal notranslate"><span class="pre">convertType()</span></code> will return a null type.</p>
<p>Builtin scalar types are converted to their corresponding SPIR-V scalar types.</p>
<p>(TODO: Note that if the bitwidth is not available in the target environment,
it will be unconditionally converted to 32-bit. This should be switched to
properly emulating non-32-bit scalar types.)</p>
<p><a class="reference external" href="Builtin.md/#indextype">Builtin index type</a> need special handling since they are not
directly supported in SPIR-V. Currently the <code class="docutils literal notranslate"><span class="pre">index</span></code> type is converted to <code class="docutils literal notranslate"><span class="pre">i32</span></code>.</p>
<p>(TODO: Allow for configuring the integer width to use for <code class="docutils literal notranslate"><span class="pre">index</span></code> types in the
SPIR-V dialect)</p>
<p>SPIR-V only supports vectors of 2/3/4 elements; so
<a class="reference external" href="Builtin.md/#vectortype">builtin vector types</a> of these lengths can be converted
directly.</p>
<p>(TODO: Convert other vectors of lengths to scalars or arrays)</p>
<p><a class="reference external" href="Builtin.md/#memreftype">Builtin memref types</a> with static shape and stride are
converted to <code class="docutils literal notranslate"><span class="pre">spirv.ptr&lt;spirv.struct&lt;spirv.array&lt;...&gt;&gt;&gt;</span></code>s. The resultant SPIR-V array
types have the same element type as the source memref and its number of elements
is obtained from the layout specification of the memref. The storage class of
the pointer type are derived from the memref’s memory space with
<code class="docutils literal notranslate"><span class="pre">SPIRVTypeConverter::getStorageClassForMemorySpace()</span></code>.</p>
</section>
<section id="utility-functions-for-lowering">
<h3>Utility functions for lowering<a class="headerlink" href="#utility-functions-for-lowering" title="此标题的永久链接">¶</a></h3>
<section id="setting-layout-for-shader-interface-variables">
<h4>Setting layout for shader interface variables<a class="headerlink" href="#setting-layout-for-shader-interface-variables" title="此标题的永久链接">¶</a></h4>
<p>SPIR-V validation rules for shaders require composite objects to be explicitly
laid out. If a <code class="docutils literal notranslate"><span class="pre">spirv.GlobalVariable</span></code> is not explicitly laid out, the utility
method <code class="docutils literal notranslate"><span class="pre">mlir::spirv::decorateType</span></code> implements a layout consistent with
the <a class="reference external" href="https://renderdoc.org/vkspec_chunked/chap14.html#interfaces-resources">Vulkan shader requirements</a>.</p>
</section>
<section id="creating-builtin-variables">
<h4>Creating builtin variables<a class="headerlink" href="#creating-builtin-variables" title="此标题的永久链接">¶</a></h4>
<p>In SPIR-V dialect, builtins are represented using <code class="docutils literal notranslate"><span class="pre">spirv.GlobalVariable</span></code>s, with
<code class="docutils literal notranslate"><span class="pre">spirv.mlir.addressof</span></code> used to get a handle to the builtin as an SSA value.  The
method <code class="docutils literal notranslate"><span class="pre">mlir::spirv::getBuiltinVariableValue</span></code> creates a <code class="docutils literal notranslate"><span class="pre">spirv.GlobalVariable</span></code> for
the builtin in the current <code class="docutils literal notranslate"><span class="pre">spirv.module</span></code> if it does not exist already, and
returns an SSA value generated from an <code class="docutils literal notranslate"><span class="pre">spirv.mlir.addressof</span></code> operation.</p>
</section>
</section>
<section id="current-conversions-to-spir-v">
<h3>Current conversions to SPIR-V<a class="headerlink" href="#current-conversions-to-spir-v" title="此标题的永久链接">¶</a></h3>
<p>Using the above infrastructure, conversions are implemented from</p>
<ul class="simple">
<li><p>[Arith Dialect][MlirArithDialect]</p></li>
<li><p><a class="reference internal" href="GPU.html"><span class="doc">GPU Dialect</span></a> : A gpu.module is converted to a <code class="docutils literal notranslate"><span class="pre">spirv.module</span></code>.
A gpu.function within this module is lowered as an entry function.</p></li>
</ul>
</section>
</section>
<section id="code-organization">
<h2>Code organization<a class="headerlink" href="#code-organization" title="此标题的永久链接">¶</a></h2>
<p>We aim to provide multiple libraries with clear dependencies for SPIR-V related
functionalities in MLIR so developers can just choose the needed components
without pulling in the whole world.</p>
<section id="the-dialect">
<h3>The dialect<a class="headerlink" href="#the-dialect" title="此标题的永久链接">¶</a></h3>
<p>The code for the SPIR-V dialect resides in a few places:</p>
<ul class="simple">
<li><p>Public headers are placed in <a class="reference external" href="https://github.com/llvm/llvm-project/tree/main/mlir/include/mlir/Dialect/SPIRV">include/mlir/Dialect/SPIRV</a>.</p></li>
<li><p>Libraries are placed in <a class="reference external" href="https://github.com/llvm/llvm-project/tree/main/mlir/lib/Dialect/SPIRV">lib/Dialect/SPIRV</a>.</p></li>
<li><p>IR tests are placed in <a class="reference external" href="https://github.com/llvm/llvm-project/tree/main/mlir/test/Dialect/SPIRV">test/Dialect/SPIRV</a>.</p></li>
<li><p>Unit tests are placed in <a class="reference external" href="https://github.com/llvm/llvm-project/tree/main/mlir/unittests/Dialect/SPIRV">unittests/Dialect/SPIRV</a>.</p></li>
</ul>
<p>The whole SPIR-V dialect is exposed via multiple headers for better
organization:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVDialect.h">SPIRVDialect.h</a> defines the SPIR-V dialect.</p></li>
<li><p><a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVTypes.h">SPIRVTypes.h</a> defines all SPIR-V specific types.</p></li>
<li><p><a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVOps.h">SPIRVOps.h</a> defines all SPIR-V operations.</p></li>
<li><p><a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Target/SPIRV/Serialization.h">Serialization.h</a> defines the entry points for
serialization and deserialization.</p></li>
</ul>
<p>The dialect itself, including all types and ops, is in the <code class="docutils literal notranslate"><span class="pre">MLIRSPIRV</span></code> library.
Serialization functionalities are in the <code class="docutils literal notranslate"><span class="pre">MLIRSPIRVSerialization</span></code> library.</p>
</section>
<section id="op-definitions">
<h3>Op definitions<a class="headerlink" href="#op-definitions" title="此标题的永久链接">¶</a></h3>
<p>We use <a class="reference internal" href="../DefiningDialects/Operations.html"><span class="doc">Op Definition Spec</span></a> to define all SPIR-V ops. They are written in
TableGen syntax and placed in various <code class="docutils literal notranslate"><span class="pre">*Ops.td</span></code> files in the header directory.
Those <code class="docutils literal notranslate"><span class="pre">*Ops.td</span></code> files are organized according to the instruction categories used
in the SPIR-V specification, for example, an op belonging to the “Atomics
Instructions” section is put in the <code class="docutils literal notranslate"><span class="pre">SPIRVAtomicOps.td</span></code> file.</p>
<p><code class="docutils literal notranslate"><span class="pre">SPIRVOps.td</span></code> serves as the main op definition file that includes all files
for specific categories.</p>
<p><code class="docutils literal notranslate"><span class="pre">SPIRVBase.td</span></code> defines common classes and utilities used by various op
definitions. It contains the TableGen SPIR-V dialect definition, SPIR-V
versions, known extensions, various SPIR-V enums, TableGen SPIR-V types, and
base op classes, etc.</p>
<p>Many of the contents in <code class="docutils literal notranslate"><span class="pre">SPIRVBase.td</span></code>, e.g., the opcodes and various enums, and
all <code class="docutils literal notranslate"><span class="pre">*Ops.td</span></code> files can be automatically updated via a Python script, which
queries the SPIR-V specification and grammar. This greatly reduces the burden of
supporting new ops and keeping updated with the SPIR-V spec. More details on
this automated development can be found in the
<a class="reference external" href="#automated-development-flow">Automated development flow</a> section.</p>
</section>
<section id="dialect-conversions">
<h3>Dialect conversions<a class="headerlink" href="#dialect-conversions" title="此标题的永久链接">¶</a></h3>
<p>The code for conversions from other dialects to the SPIR-V dialect also resides
in a few places:</p>
<ul class="simple">
<li><p>From GPU dialect: headers are at
<a class="reference external" href="https://github.com/llvm/llvm-project/tree/main/mlir/include/mlir/Conversion/GPUToSPIRV">include/mlir/Conversion/GPUTOSPIRV</a>; libraries are
at <a class="reference external" href="https://github.com/llvm/llvm-project/tree/main/mlir/lib/Conversion/GPUToSPIRV">lib/Conversion/GPUToSPIRV</a>.</p></li>
<li><p>From Func dialect: headers are at
<a class="reference external" href="https://github.com/llvm/llvm-project/tree/main/mlir/include/mlir/Conversion/FuncToSPIRV">include/mlir/Conversion/FuncToSPIRV</a>; libraries
are at <a class="reference external" href="https://github.com/llvm/llvm-project/tree/main/mlir/lib/Conversion/FuncToSPIRV">lib/Conversion/FuncToSPIRV</a>.</p></li>
</ul>
<p>These dialect to dialect conversions have their dedicated libraries,
<code class="docutils literal notranslate"><span class="pre">MLIRGPUToSPIRV</span></code> and <code class="docutils literal notranslate"><span class="pre">MLIRFuncToSPIRV</span></code>, respectively.</p>
<p>There are also common utilities when targeting SPIR-V from any dialect:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/SPIRV/Transforms/SPIRVConversion.h">include/mlir/Dialect/SPIRV/Transforms/SPIRVConversion.h</a>
contains type converters and other utility functions.</p></li>
<li><p><a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/SPIRV/Transforms/Passes.h">include/mlir/Dialect/SPIRV/Transforms/Passes.h</a> contains
SPIR-V specific analyses and transformations.</p></li>
</ul>
<p>These common utilities are implemented in the <code class="docutils literal notranslate"><span class="pre">MLIRSPIRVConversion</span></code> and
<code class="docutils literal notranslate"><span class="pre">MLIRSPIRVTransforms</span></code> library, respectively.</p>
</section>
</section>
<section id="rationale">
<h2>Rationale<a class="headerlink" href="#rationale" title="此标题的永久链接">¶</a></h2>
<section id="lowering-memrefs-to-spirv-array-and-spirv-rtarray">
<h3>Lowering <code class="docutils literal notranslate"><span class="pre">memref</span></code>s to <code class="docutils literal notranslate"><span class="pre">!spirv.array&lt;..&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">!spirv.rtarray&lt;..&gt;</span></code>.<a class="headerlink" href="#lowering-memrefs-to-spirv-array-and-spirv-rtarray" title="此标题的永久链接">¶</a></h3>
<p>The LLVM dialect lowers <code class="docutils literal notranslate"><span class="pre">memref</span></code> types to a <code class="docutils literal notranslate"><span class="pre">MemrefDescriptor</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">MemrefDescriptor</span> <span class="p">{</span>
  <span class="n">void</span> <span class="o">*</span><span class="n">allocated_ptr</span><span class="p">;</span> <span class="o">//</span> <span class="n">Pointer</span> <span class="n">to</span> <span class="n">the</span> <span class="n">base</span> <span class="n">allocation</span><span class="o">.</span>
  <span class="n">void</span> <span class="o">*</span><span class="n">aligned_ptr</span><span class="p">;</span>   <span class="o">//</span> <span class="n">Pointer</span> <span class="n">within</span> <span class="n">base</span> <span class="n">allocation</span> <span class="n">which</span> <span class="ow">is</span> <span class="n">aligned</span> <span class="n">to</span>
                       <span class="o">//</span> <span class="n">the</span> <span class="n">value</span> <span class="nb">set</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">memref</span><span class="o">.</span>
  <span class="n">size_t</span> <span class="n">offset</span><span class="p">;</span>       <span class="o">//</span> <span class="n">Offset</span> <span class="kn">from</span> <span class="nn">aligned_ptr</span> <span class="kn">from</span> <span class="nn">where</span> <span class="n">to</span> <span class="n">get</span> <span class="n">values</span>
                       <span class="o">//</span> <span class="n">corresponding</span> <span class="n">to</span> <span class="n">the</span> <span class="n">memref</span><span class="o">.</span>
  <span class="n">size_t</span> <span class="n">shape</span><span class="p">[</span><span class="n">rank</span><span class="p">];</span>  <span class="o">//</span> <span class="n">Shape</span> <span class="n">of</span> <span class="n">the</span> <span class="n">memref</span><span class="o">.</span>
  <span class="n">size_t</span> <span class="n">stride</span><span class="p">[</span><span class="n">rank</span><span class="p">];</span> <span class="o">//</span> <span class="n">Strides</span> <span class="n">used</span> <span class="k">while</span> <span class="n">accessing</span> <span class="n">elements</span> <span class="n">of</span> <span class="n">the</span> <span class="n">memref</span><span class="o">.</span>
<span class="p">};</span>
</pre></div>
</div>
<p>In SPIR-V dialect, we chose not to use a <code class="docutils literal notranslate"><span class="pre">MemrefDescriptor</span></code>. Instead a <code class="docutils literal notranslate"><span class="pre">memref</span></code>
is lowered directly to a <code class="docutils literal notranslate"><span class="pre">!spirv.ptr&lt;!spirv.array&lt;nelts</span> <span class="pre">x</span> <span class="pre">elem_type&gt;&gt;</span></code> when the
<code class="docutils literal notranslate"><span class="pre">memref</span></code> is statically shaped, and <code class="docutils literal notranslate"><span class="pre">!spirv.ptr&lt;!spirv.rtarray&lt;elem_type&gt;&gt;</span></code> when the
<code class="docutils literal notranslate"><span class="pre">memref</span></code> is dynamically shaped. The rationale behind this choice is described
below.</p>
<ol class="simple">
<li><p>Inputs/output buffers to a SPIR-V kernel are specified using
<a class="reference external" href="https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html#OpVariable"><code class="docutils literal notranslate"><span class="pre">OpVariable</span></code></a> inside <a class="reference external" href="https://renderdoc.org/vkspec_chunked/chap15.html#interfaces">interface storage
classes</a> (e.g., Uniform, StorageBuffer,
etc.), while kernel private variables reside in non-interface storage
classes (e.g., Function, Workgroup, etc.). By default, Vulkan-flavored
SPIR-V requires logical addressing mode: one cannot load/store pointers
from/to variables and cannot perform pointer arithmetic.  Expressing a
struct like <code class="docutils literal notranslate"><span class="pre">MemrefDescriptor</span></code> in interface storage class requires special
addressing mode
(<a class="reference external" href="https://github.com/KhronosGroup/SPIRV-Registry/blob/main/extensions/KHR/SPV_KHR_physical_storage_buffer.html">PhysicalStorageBuffer</a>) and
manipulating such a struct in non-interface storage classes requires special
capabilities (<a class="reference external" href="https://github.com/KhronosGroup/SPIRV-Registry/blob/main/extensions/KHR/SPV_KHR_variable_pointers.html">VariablePointers</a>).
Requiring these two extensions together will significantly limit the
Vulkan-capable device we can target; basically ruling out mobile support..</p></li>
<li><p>An alternative to having one level of indirection (as is the case with
<code class="docutils literal notranslate"><span class="pre">MemrefDescriptor</span></code>s), is to embed the <code class="docutils literal notranslate"><span class="pre">!spirv.array</span></code> or <code class="docutils literal notranslate"><span class="pre">!spirv.rtarray</span></code>
directly in the <code class="docutils literal notranslate"><span class="pre">MemrefDescriptor</span></code>, Having such a descriptor at the ABI
boundary implies that the first few bytes of the input/output buffers would
need to be reserved for shape/stride information. This adds an unnecessary
burden on the host side.</p></li>
<li><p>A more performant approach would be to have the data be an <code class="docutils literal notranslate"><span class="pre">OpVariable</span></code>,
with the shape and strides passed using a separate <code class="docutils literal notranslate"><span class="pre">OpVariable</span></code>. This has
further advantages:</p>
<ul class="simple">
<li><p>All the dynamic shape/stride information of the <code class="docutils literal notranslate"><span class="pre">memref</span></code> can be combined
into a single descriptor. Descriptors are <a class="reference external" href="https://vulkan.gpuinfo.org/displaydevicelimit.php?name=maxPerStageDescriptorStorageBuffers&amp;platform=android">limited resources on many
Vulkan hardware</a>.  So
combining them would help make the generated code more portable across
devices.</p></li>
<li><p>If the shape/stride information is small enough, they could be accessed
using <a class="reference external" href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/vkCmdPushConstants.html">PushConstants</a> that are faster to access and
avoid buffer allocation overheads. These would be unnecessary if all
shapes are static. In the dynamic shape cases, a few parameters are
typically enough to compute the shape of all <code class="docutils literal notranslate"><span class="pre">memref</span></code>s used/referenced
within the kernel making the use of PushConstants possible.</p></li>
<li><p>The shape/stride information (typically) needs to be update less
frequently than the data stored in the buffers. They could be part of
different descriptor sets.</p></li>
</ul>
</li>
</ol>
</section>
</section>
<section id="contribution">
<h2>Contribution<a class="headerlink" href="#contribution" title="此标题的永久链接">¶</a></h2>
<p>All kinds of contributions are highly appreciated! :) We have GitHub issues for
tracking the <a class="reference external" href="https://github.com/tensorflow/mlir/issues/302">dialect</a> and
<a class="reference external" href="https://github.com/tensorflow/mlir/issues/303">lowering</a> development. You can find todo tasks there.
The <a class="reference external" href="#code-organization">Code organization</a> section gives an overview of how
SPIR-V related functionalities are implemented in MLIR. This section gives more
concrete steps on how to contribute.</p>
<section id="automated-development-flow">
<h3>Automated development flow<a class="headerlink" href="#automated-development-flow" title="此标题的永久链接">¶</a></h3>
<p>One of the goals of SPIR-V dialect development is to leverage both the SPIR-V
<a class="reference external" href="https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html">human-readable specification</a> and
<a class="reference external" href="https://raw.githubusercontent.com/KhronosGroup/SPIRV-Headers/master/include/spirv/unified1/spirv.core.grammar.json">machine-readable grammar</a> to auto-generate as much contents as
possible. Specifically, the following tasks can be automated (partially or
fully):</p>
<ul class="simple">
<li><p>Adding support for a new operation.</p></li>
<li><p>Adding support for a new SPIR-V enum.</p></li>
<li><p>Serialization and deserialization of a new operation.</p></li>
</ul>
<p>We achieve this using the Python script
<a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/mlir/utils/spirv/gen_spirv_dialect.py"><code class="docutils literal notranslate"><span class="pre">gen_spirv_dialect.py</span></code></a>. It fetches the human-readable
specification and machine-readable grammar directly from the Internet and
updates various SPIR-V <code class="docutils literal notranslate"><span class="pre">*.td</span></code> files in place. The script gives us an automated
flow for adding support for new ops or enums.</p>
<p>Afterwards, we have SPIR-V specific <code class="docutils literal notranslate"><span class="pre">mlir-tblgen</span></code> backends for reading the Op
Definition Spec and generate various components, including (de)serialization
logic for ops. Together with standard <code class="docutils literal notranslate"><span class="pre">mlir-tblgen</span></code> backends, we auto-generate
all op classes, enum classes, etc.</p>
<p>In the following subsections, we list the detailed steps to follow for common
tasks.</p>
</section>
<section id="add-a-new-op">
<h3>Add a new op<a class="headerlink" href="#add-a-new-op" title="此标题的永久链接">¶</a></h3>
<p>To add a new op, invoke the <code class="docutils literal notranslate"><span class="pre">define_inst.sh</span></code> script wrapper in utils/spirv.
<code class="docutils literal notranslate"><span class="pre">define_inst.sh</span></code> requires a few parameters:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>./define_inst.sh<span class="w"> </span>&lt;filename&gt;<span class="w"> </span>&lt;base-class-name&gt;<span class="w"> </span>&lt;opname&gt;
</pre></div>
</div>
<p>For example, to define the op for <code class="docutils literal notranslate"><span class="pre">OpIAdd</span></code>, invoke</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>./define_inst.sh<span class="w"> </span>SPIRVArithmeticOps.td<span class="w"> </span>ArithmeticBinaryOp<span class="w"> </span>OpIAdd
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">SPIRVArithmeticOps.td</span></code> is the filename for hosting the new op and
<code class="docutils literal notranslate"><span class="pre">ArithmeticBinaryOp</span></code> is the direct base class the newly defined op will derive
from.</p>
<p>Similarly, to define the op for <code class="docutils literal notranslate"><span class="pre">OpAtomicAnd</span></code>,</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>./define_inst.sh<span class="w"> </span>SPIRVAtomicOps.td<span class="w"> </span>AtomicUpdateWithValueOp<span class="w"> </span>OpAtomicAnd
</pre></div>
</div>
<p>Note that the generated SPIR-V op definition is just a best-effort template; it
is still expected to be updated to have more accurate traits, arguments, and
results.</p>
<p>It is also expected that a custom assembly form is defined for the new op,
which will require providing the parser and printer. The EBNF form of the
custom assembly should be described in the op’s description and the parser
and printer should be placed in <a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/mlir/lib/Dialect/SPIRV/IR/SPIRVOps.cpp"><code class="docutils literal notranslate"><span class="pre">SPIRVOps.cpp</span></code></a> with the
following signatures:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="n">ParseResult</span><span class="w"> </span><span class="n">parse</span><span class="o">&lt;</span><span class="n">spirv</span><span class="o">-</span><span class="n">op</span><span class="o">-</span><span class="n">symbol</span><span class="o">&gt;</span><span class="n">Op</span><span class="p">(</span><span class="n">OpAsmParser</span><span class="w"> </span><span class="o">&amp;</span><span class="n">parser</span><span class="p">,</span>
<span class="w">                                            </span><span class="n">OperationState</span><span class="w"> </span><span class="o">&amp;</span><span class="n">state</span><span class="p">);</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">print</span><span class="p">(</span><span class="n">spirv</span><span class="o">::&lt;</span><span class="n">spirv</span><span class="o">-</span><span class="n">op</span><span class="o">-</span><span class="n">symbol</span><span class="o">&gt;</span><span class="n">Op</span><span class="w"> </span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="n">OpAsmPrinter</span><span class="w"> </span><span class="o">&amp;</span><span class="n">printer</span><span class="p">);</span>
</pre></div>
</div>
<p>See any existing op as an example.</p>
<p>Verification should be provided for the new op to cover all the rules described
in the SPIR-V specification. Choosing the proper ODS types and attribute kinds,
which can be found in <a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVBase.td"><code class="docutils literal notranslate"><span class="pre">SPIRVBase.td</span></code></a>, can help here. Still
sometimes we need to manually write additional verification logic in
<a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/mlir/lib/Dialect/SPIRV/IR/SPIRVOps.cpp"><code class="docutils literal notranslate"><span class="pre">SPIRVOps.cpp</span></code></a> in a function with the following signature:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">LogicalResult</span><span class="w"> </span><span class="n">spirv</span><span class="o">::&lt;</span><span class="n">spirv</span><span class="o">-</span><span class="n">op</span><span class="o">-</span><span class="n">symbol</span><span class="o">&gt;</span><span class="n">Op</span><span class="o">::</span><span class="n">verify</span><span class="p">();</span>
</pre></div>
</div>
<p>See any such function in <a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/mlir/lib/Dialect/SPIRV/IR/SPIRVOps.cpp"><code class="docutils literal notranslate"><span class="pre">SPIRVOps.cpp</span></code></a> as an example.</p>
<p>If no additional verification is needed, one needs to add the following to
the op’s Op Definition Spec:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">let</span> <span class="n">hasVerifier</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>To suppress the requirement of the above C++ verification function.</p>
<p>Tests for the op’s custom assembly form and verification should be added to
the proper file in test/Dialect/SPIRV/.</p>
<p>The generated op will automatically gain the logic for (de)serialization.
However, tests still need to be coupled with the change to make sure no
surprises. Serialization tests live in test/Dialect/SPIRV/Serialization.</p>
</section>
<section id="add-a-new-enum">
<h3>Add a new enum<a class="headerlink" href="#add-a-new-enum" title="此标题的永久链接">¶</a></h3>
<p>To add a new enum, invoke the <code class="docutils literal notranslate"><span class="pre">define_enum.sh</span></code> script wrapper in utils/spirv.
<code class="docutils literal notranslate"><span class="pre">define_enum.sh</span></code> expects the following parameters:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>./define_enum.sh<span class="w"> </span>&lt;enum-class-name&gt;
</pre></div>
</div>
<p>For example, to add the definition for SPIR-V storage class in to
<code class="docutils literal notranslate"><span class="pre">SPIRVBase.td</span></code>:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>./define_enum.sh<span class="w"> </span>StorageClass
</pre></div>
</div>
</section>
<section id="add-a-new-custom-type">
<h3>Add a new custom type<a class="headerlink" href="#add-a-new-custom-type" title="此标题的永久链接">¶</a></h3>
<p>SPIR-V specific types are defined in <a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVTypes.h"><code class="docutils literal notranslate"><span class="pre">SPIRVTypes.h</span></code></a>. See
examples there and the <a class="reference internal" href="../DefiningDialects/AttributesAndTypes.html"><span class="doc">tutorial</span></a> for defining new
custom types.</p>
</section>
<section id="add-a-new-conversion">
<h3>Add a new conversion<a class="headerlink" href="#add-a-new-conversion" title="此标题的永久链接">¶</a></h3>
<p>To add conversion for a type update the <code class="docutils literal notranslate"><span class="pre">mlir::spirv::SPIRVTypeConverter</span></code> to
return the converted type (must be a valid SPIR-V type). See <a class="reference external" href="../DialectConversion.md/#type-converter">Type
Conversion</a> for more details.</p>
<p>To lower an operation into SPIR-V dialect, implement a <a class="reference external" href="../DialectConversion.md/#conversion-patterns">conversion
pattern</a>. If the conversion requires type
conversion as well, the pattern must inherit from the
<code class="docutils literal notranslate"><span class="pre">mlir::spirv::SPIRVOpLowering</span></code> class to get access to
<code class="docutils literal notranslate"><span class="pre">mlir::spirv::SPIRVTypeConverter</span></code>.  If the operation has a region, <a class="reference external" href="../DialectConversion.md/#region-signature-conversion">signature
conversion</a> might be needed as well.</p>
<p><strong>Note</strong>: The current validation rules of <code class="docutils literal notranslate"><span class="pre">spirv.module</span></code> require that all
operations contained within its region are valid operations in the SPIR-V
dialect.</p>
</section>
</section>
<section id="operation-definitions">
<h2>Operation definitions<a class="headerlink" href="#operation-definitions" title="此标题的永久链接">¶</a></h2>
<p>[include “Dialects/SPIRVOps.md”]</p>
</section>
</section>


          </div>
          <div class="page-nav">
            <div class="inner"><ul class="page-nav">
</ul><div class="footer" role="contentinfo">
      &#169; 版权所有 2023, yaoyue123.
    <br>
    Created using <a href="http://sphinx-doc.org/">Sphinx</a> 6.1.3 with <a href="https://github.com/schettino72/sphinx_press_theme">Press Theme</a> 0.8.0.
</div>
            </div>
          </div>
      </page>
    </div></div>
    
    
  </body>
</html>