<!DOCTYPE html>
<html  lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

      <title>Dialect Conversion</title>
    
          <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
          <link rel="stylesheet" href="../_static/theme.css " type="text/css" />
      
      <!-- sphinx script_files -->
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script src="../_static/translations.js"></script>

      
      <!-- bundled in js (rollup iife) -->
      <!-- <script src="../_static/theme-vendors.js"></script> -->
      <script src="../_static/theme.js" defer></script>
    
  <link rel="index" title="索引" href="../genindex.html" />
  <link rel="search" title="搜索" href="../search.html" /> 
  </head>

  <body>
    <div id="app">
    <div class="theme-container" :class="pageClasses"><navbar @toggle-sidebar="toggleSidebar">
  <router-link to="../index.html" class="home-link">
    
      <span class="site-name">MLIR 中文文档</span>
    
  </router-link>

  <div class="links">
    <navlinks class="can-hide">



    </navlinks>
  </div>
</navbar>

      
      <div class="sidebar-mask" @click="toggleSidebar(false)">
      </div>
        <sidebar @toggle-sidebar="toggleSidebar">
          
          <navlinks>
            



            
          </navlinks><div id="searchbox" class="searchbox" role="search">
  <div class="caption"><span class="caption-text">快速搜索</span>
    <div class="searchformwrapper">
      <form class="search" action="../search.html" method="get">
        <input type="text" name="q" />
        <input type="submit" value="搜索" />
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div><div class="sidebar-links" role="navigation" aria-label="main navigation">
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../index.html#mlir">欢迎使用 mlir 中文文档</a></span>
      </p>
      <ul class="">
        
          <li class="toctree-l1 ">
            
              <a href="../_index.html" class="reference internal ">开始使用</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/CreatingADialect.html" class="reference internal ">Creating a Dialect</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/DataFlowAnalysis.html" class="reference internal ">Writing DataFlow Analyses in MLIR</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/QuickstartRewrites.html" class="reference internal ">Quickstart tutorial to adding MLIR graph rewrite</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-1.html" class="reference internal ">Chapter 1: Toy Language and AST</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-2.html" class="reference internal ">Chapter 2: Emitting Basic MLIR</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-3.html" class="reference internal ">Chapter 3: High-level Language-Specific Analysis and Transformation</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-4.html" class="reference internal ">Chapter 4: Enabling Generic Transformation with Interfaces</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-5.html" class="reference internal ">Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-6.html" class="reference internal ">Chapter 6: Lowering to LLVM and CodeGeneration</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-7.html" class="reference internal ">Chapter 7: Adding a Composite Type to Toy</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/_index.html" class="reference internal ">Toy Tutorial</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/UnderstandingTheIRStructure.html" class="reference internal ">Understanding the IR Structure</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/_index.html" class="reference internal ">Tutorials</a>
            

            
          </li>

        
      </ul>
    </div>
  
</div>
        </sidebar>

      <page>
          <div class="body-header" role="navigation" aria-label="navigation">
  
  <ul class="breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
    
    <li>Dialect Conversion</li>
  </ul>
  

  <ul class="page-nav">
</ul>
  
</div>
<hr>
          <div class="content" role="main" v-pre>
            
  <section id="dialect-conversion">
<h1>Dialect Conversion<a class="headerlink" href="#dialect-conversion" title="此标题的永久链接">¶</a></h1>
<p>This document describes a framework in MLIR in which to perform operation
conversions between, and within dialects. This framework allows for transforming
illegal operations to those supported by a provided conversion target, via a set
of pattern-based operation rewriting patterns.</p>
<p>The dialect conversion framework consists of the following components:</p>
<ul class="simple">
<li><p>A <a class="reference external" href="#conversion-target">Conversion Target</a></p></li>
<li><p>A set of <a class="reference external" href="#rewrite-pattern-specification">Rewrite Patterns</a></p></li>
<li><p>A <a class="reference external" href="#type-conversion">Type Converter</a> (Optional)</p></li>
</ul>
<p>[TOC]</p>
<section id="modes-of-conversion">
<h2>Modes of Conversion<a class="headerlink" href="#modes-of-conversion" title="此标题的永久链接">¶</a></h2>
<p>When applying a conversion to a set of operations, there are several different
conversion modes that may be selected from:</p>
<ul class="simple">
<li><p>Partial Conversion</p>
<ul>
<li><p>A partial conversion will legalize as many operations to the target as
possible, but will allow pre-existing operations that were not
explicitly marked as “illegal” to remain unconverted. This allows for
partially lowering parts of the input in the presence of unknown
operations.</p></li>
<li><p>A partial conversion can be applied via <code class="docutils literal notranslate"><span class="pre">applyPartialConversion</span></code>.</p></li>
</ul>
</li>
<li><p>Full Conversion</p>
<ul>
<li><p>A full conversion legalizes all input operations, and is only successful
if all operations are properly legalized to the given conversion target.
This ensures that only known operations will exist after the conversion
process.</p></li>
<li><p>A full conversion can be applied via <code class="docutils literal notranslate"><span class="pre">applyFullConversion</span></code>.</p></li>
</ul>
</li>
<li><p>Analysis Conversion</p>
<ul>
<li><p>An analysis conversion will analyze which operations are legalizable to
the given conversion target if a conversion were to be applied. This is
done by performing a ‘partial’ conversion and recording which operations
would have been successfully converted if successful. Note that no
rewrites, or transformations, are actually applied to the input
operations.</p></li>
<li><p>An analysis conversion can be applied via <code class="docutils literal notranslate"><span class="pre">applyAnalysisConversion</span></code>.</p></li>
</ul>
</li>
</ul>
<p>In all cases, the framework walks the operations in preorder, examining an op
before the ops in any regions it has.</p>
</section>
<section id="conversion-target">
<h2>Conversion Target<a class="headerlink" href="#conversion-target" title="此标题的永久链接">¶</a></h2>
<p>The conversion target is a formal definition of what is considered to be legal
during the conversion process. The final operations generated by the conversion
framework must be marked as legal on the <code class="docutils literal notranslate"><span class="pre">ConversionTarget</span></code> for the rewrite to
be a success. Depending on the conversion mode, existing operations need not
always be legal. Operations and dialects may be marked with any of the provided
legality actions below:</p>
<ul class="simple">
<li><p>Legal</p>
<ul>
<li><p>This action signals that every instance of a given operation is legal,
i.e. any combination of attributes, operands, types, etc. are valid.</p></li>
</ul>
</li>
<li><p>Dynamic</p>
<ul>
<li><p>This action signals that only some instances of a given operation are
legal. This allows for defining fine-tune constraints, e.g. saying that
<code class="docutils literal notranslate"><span class="pre">arith.addi</span></code> is only legal when operating on 32-bit integers.</p></li>
</ul>
</li>
<li><p>Illegal</p>
<ul>
<li><p>This action signals that no instance of a given operation is legal.
Operations marked as “illegal” must always be converted for the
conversion to be successful. This action also allows for selectively
marking specific operations as illegal in an otherwise legal dialect.</p></li>
</ul>
</li>
</ul>
<p>Operations and dialects that are neither explicitly marked legal nor illegal are
separate from the above (”unknown” operations) and are treated differently, for
example, for the purposes of partial conversion as mentioned above.</p>
<p>An example conversion target is shown below:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">MyTarget</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">ConversionTarget</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">MyTarget</span><span class="p">(</span><span class="n">MLIRContext</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ctx</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ConversionTarget</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">//--------------------------------------------------------------------------</span>
<span class="w">    </span><span class="c1">// Marking an operation as Legal:</span>

<span class="w">    </span><span class="c1">/// Mark all operations within the LLVM dialect are legal.</span>
<span class="w">    </span><span class="n">addLegalDialect</span><span class="o">&lt;</span><span class="n">LLVMDialect</span><span class="o">&gt;</span><span class="p">();</span>

<span class="w">    </span><span class="c1">/// Mark `arith.constant` op is always legal on this target.</span>
<span class="w">    </span><span class="n">addLegalOp</span><span class="o">&lt;</span><span class="n">arith</span><span class="o">::</span><span class="n">ConstantOp</span><span class="o">&gt;</span><span class="p">();</span>

<span class="w">    </span><span class="c1">//--------------------------------------------------------------------------</span>
<span class="w">    </span><span class="c1">// Marking an operation as dynamically legal.</span>

<span class="w">    </span><span class="c1">/// Mark all operations within Affine dialect have dynamic legality</span>
<span class="w">    </span><span class="c1">/// constraints.</span>
<span class="w">    </span><span class="n">addDynamicallyLegalDialect</span><span class="o">&lt;</span><span class="n">affine</span><span class="o">::</span><span class="n">AffineDialect</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">        </span><span class="p">[](</span><span class="n">Operation</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">});</span>

<span class="w">    </span><span class="c1">/// Mark `func.return` as dynamically legal, but provide a specific legality</span>
<span class="w">    </span><span class="c1">/// callback.</span>
<span class="w">    </span><span class="n">addDynamicallyLegalOp</span><span class="o">&lt;</span><span class="n">func</span><span class="o">::</span><span class="n">ReturnOp</span><span class="o">&gt;</span><span class="p">([](</span><span class="n">func</span><span class="o">::</span><span class="n">ReturnOp</span><span class="w"> </span><span class="n">op</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">});</span>

<span class="w">    </span><span class="c1">/// Treat unknown operations, i.e. those without a legalization action</span>
<span class="w">    </span><span class="c1">/// directly set, as dynamically legal.</span>
<span class="w">    </span><span class="n">markUnknownOpDynamicallyLegal</span><span class="p">([](</span><span class="n">Operation</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">});</span>

<span class="w">    </span><span class="c1">//--------------------------------------------------------------------------</span>
<span class="w">    </span><span class="c1">// Marking an operation as illegal.</span>

<span class="w">    </span><span class="c1">/// All operations within the GPU dialect are illegal.</span>
<span class="w">    </span><span class="n">addIllegalDialect</span><span class="o">&lt;</span><span class="n">GPUDialect</span><span class="o">&gt;</span><span class="p">();</span>

<span class="w">    </span><span class="c1">/// Mark `cf.br` and `cf.cond_br` as illegal.</span>
<span class="w">    </span><span class="n">addIllegalOp</span><span class="o">&lt;</span><span class="n">cf</span><span class="o">::</span><span class="n">BranchOp</span><span class="p">,</span><span class="w"> </span><span class="n">cf</span><span class="o">::</span><span class="n">CondBranchOp</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">/// Implement the default legalization handler to handle operations marked as</span>
<span class="w">  </span><span class="c1">/// dynamically legal that were not provided with an explicit handler.</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">isDynamicallyLegal</span><span class="p">(</span><span class="n">Operation</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<section id="recursive-legality">
<h3>Recursive Legality<a class="headerlink" href="#recursive-legality" title="此标题的永久链接">¶</a></h3>
<p>In some cases, it may be desirable to mark entire regions as legal. This
provides an additional granularity of context to the concept of “legal”. If an
operation is marked recursively legal, either statically or dynamically, then
all of the operations nested within are also considered legal even if they would
otherwise be considered “illegal”. An operation can be marked via
<code class="docutils literal notranslate"><span class="pre">markOpRecursivelyLegal&lt;&gt;</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ConversionTarget</span><span class="w"> </span><span class="o">&amp;</span><span class="n">target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>

<span class="c1">/// The operation must first be marked as `Legal` or `Dynamic`.</span>
<span class="n">target</span><span class="p">.</span><span class="n">addLegalOp</span><span class="o">&lt;</span><span class="n">MyOp</span><span class="o">&gt;</span><span class="p">(...);</span>
<span class="n">target</span><span class="p">.</span><span class="n">addDynamicallyLegalOp</span><span class="o">&lt;</span><span class="n">MySecondOp</span><span class="o">&gt;</span><span class="p">(...);</span>

<span class="c1">/// Mark the operation as always recursively legal.</span>
<span class="n">target</span><span class="p">.</span><span class="n">markOpRecursivelyLegal</span><span class="o">&lt;</span><span class="n">MyOp</span><span class="o">&gt;</span><span class="p">();</span>
<span class="c1">/// Mark optionally with a callback to allow selective marking.</span>
<span class="n">target</span><span class="p">.</span><span class="n">markOpRecursivelyLegal</span><span class="o">&lt;</span><span class="n">MyOp</span><span class="p">,</span><span class="w"> </span><span class="n">MySecondOp</span><span class="o">&gt;</span><span class="p">([](</span><span class="n">Operation</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">});</span>
<span class="c1">/// Mark optionally with a callback to allow selective marking.</span>
<span class="n">target</span><span class="p">.</span><span class="n">markOpRecursivelyLegal</span><span class="o">&lt;</span><span class="n">MyOp</span><span class="o">&gt;</span><span class="p">([](</span><span class="n">MyOp</span><span class="w"> </span><span class="n">op</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">});</span>
</pre></div>
</div>
</section>
</section>
<section id="rewrite-pattern-specification">
<h2>Rewrite Pattern Specification<a class="headerlink" href="#rewrite-pattern-specification" title="此标题的永久链接">¶</a></h2>
<p>After the conversion target has been defined, a set of legalization patterns
must be provided to transform illegal operations into legal ones. The patterns
supplied here have the same structure and restrictions as those described in the
main <a class="reference internal" href="PatternRewriter.html"><span class="doc">Pattern</span></a> documentation. The patterns provided do not
need to generate operations that are directly legal on the target. The framework
will automatically build a graph of conversions to convert non-legal operations
into a set of legal ones.</p>
<p>As an example, say you define a target that supports one operation: <code class="docutils literal notranslate"><span class="pre">foo.add</span></code>.
When providing the following patterns: [<code class="docutils literal notranslate"><span class="pre">bar.add</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">baz.add</span></code>, <code class="docutils literal notranslate"><span class="pre">baz.add</span></code> -&gt;
<code class="docutils literal notranslate"><span class="pre">foo.add</span></code>], the framework will automatically detect that it can legalize
<code class="docutils literal notranslate"><span class="pre">bar.add</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">foo.add</span></code> even though a direct conversion does not exist. This
means that you don’t have to define a direct legalization pattern for <code class="docutils literal notranslate"><span class="pre">bar.add</span></code>
-&gt; <code class="docutils literal notranslate"><span class="pre">foo.add</span></code>.</p>
<section id="conversion-patterns">
<h3>Conversion Patterns<a class="headerlink" href="#conversion-patterns" title="此标题的永久链接">¶</a></h3>
<p>Along with the general <code class="docutils literal notranslate"><span class="pre">RewritePattern</span></code> classes, the conversion framework
provides a special type of rewrite pattern that can be used when a pattern
relies on interacting with constructs specific to the conversion process, the
<code class="docutils literal notranslate"><span class="pre">ConversionPattern</span></code>. For example, the conversion process does not necessarily
update operations in-place and instead creates a mapping of events such as
replacements and erasures, and only applies them when the entire conversion
process is successful. Certain classes of patterns rely on using the
updated/remapped operands of an operation, such as when the types of results
defined by an operation have changed. The general Rewrite Patterns can no longer
be used in these situations, as the types of the operands of the operation being
matched will not correspond with those expected by the user. This pattern
provides, as an additional argument to the <code class="docutils literal notranslate"><span class="pre">matchAndRewrite</span></code> and <code class="docutils literal notranslate"><span class="pre">rewrite</span></code>
methods, the list of operands that the operation should use after conversion. If
an operand was the result of a non-converted operation, for example if it was
already legal, the original operand is used. This means that the operands
provided always have a 1-1 non-null correspondence with the operands on the
operation. The original operands of the operation are still intact and may be
inspected as normal. These patterns also utilize a special <code class="docutils literal notranslate"><span class="pre">PatternRewriter</span></code>,
<code class="docutils literal notranslate"><span class="pre">ConversionPatternRewriter</span></code>, that provides special hooks for use with the
conversion infrastructure.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">MyConversionPattern</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">ConversionPattern</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">/// The `matchAndRewrite` hooks on ConversionPatterns take an additional</span>
<span class="w">  </span><span class="c1">/// `operands` parameter, containing the remapped operands of the original</span>
<span class="w">  </span><span class="c1">/// operation.</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="n">LogicalResult</span>
<span class="w">  </span><span class="nf">matchAndRewrite</span><span class="p">(</span><span class="n">Operation</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">Value</span><span class="o">&gt;</span><span class="w"> </span><span class="n">operands</span><span class="p">,</span>
<span class="w">                  </span><span class="n">ConversionPatternRewriter</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rewriter</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<section id="type-safety">
<h4>Type Safety<a class="headerlink" href="#type-safety" title="此标题的永久链接">¶</a></h4>
<p>The types of the remapped operands provided to a conversion pattern must be of a
type expected by the pattern. The expected types of a pattern are determined by
a provided <a class="reference external" href="#type-converter">TypeConverter</a>. If no type converter is provided,
the types of the remapped operands are expected to match the types of the
original operands. If a type converter is provided, the types of the remapped
operands are expected to be legal as determined by the converter. If the
remapped operand types are not of an expected type, and a materialization to the
expected type could not be performed, the pattern fails application before the
<code class="docutils literal notranslate"><span class="pre">matchAndRewrite</span></code> hook is invoked. This ensures that patterns do not have to
explicitly ensure type safety, or sanitize the types of the incoming remapped
operands. More information on type conversion is detailed in the
<a class="reference external" href="#type-conversion">dedicated section</a> below.</p>
</section>
</section>
</section>
<section id="type-conversion">
<h2>Type Conversion<a class="headerlink" href="#type-conversion" title="此标题的永久链接">¶</a></h2>
<p>It is sometimes necessary as part of a conversion to convert the set types of
being operated on. In these cases, a <code class="docutils literal notranslate"><span class="pre">TypeConverter</span></code> object may be defined that
details how types should be converted when interfacing with a pattern. A
<code class="docutils literal notranslate"><span class="pre">TypeConverter</span></code> may be used to convert the signatures of block arguments and
regions, to define the expected inputs types of the pattern, and to reconcile
type differences in general.</p>
<section id="type-converter">
<h3>Type Converter<a class="headerlink" href="#type-converter" title="此标题的永久链接">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">TypeConverter</span></code> contains several hooks for detailing how to convert types,
and how to materialize conversions between types in various situations. The two
main aspects of the <code class="docutils literal notranslate"><span class="pre">TypeConverter</span></code> are conversion and materialization.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">conversion</span></code> describes how a given illegal source <code class="docutils literal notranslate"><span class="pre">Type</span></code> should be converted
to N target types. If the source type is already “legal”, it should convert to
itself. Type conversions are specified via the <code class="docutils literal notranslate"><span class="pre">addConversion</span></code> method described
below.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">materialization</span></code> describes how a set of values should be converted to a
single value of a desired type. An important distinction with a <code class="docutils literal notranslate"><span class="pre">conversion</span></code> is
that a <code class="docutils literal notranslate"><span class="pre">materialization</span></code> can produce IR, whereas a <code class="docutils literal notranslate"><span class="pre">conversion</span></code> cannot. These
materializations are used by the conversion framework to ensure type safety
during the conversion process. There are several types of materializations
depending on the situation.</p>
<ul class="simple">
<li><p>Argument Materialization</p>
<ul>
<li><p>An argument materialization is used when converting the type of a block
argument during a <a class="reference external" href="#region-signature-conversion">signature conversion</a>.</p></li>
</ul>
</li>
<li><p>Source Materialization</p>
<ul>
<li><p>A source materialization converts from a value with a “legal” target
type, back to a specific source type. This is used when an operation is
“legal” during the conversion process, but contains a use of an illegal
type. This may happen during a conversion where some operations are
converted to those with different resultant types, but still retain
users of the original type system.</p></li>
<li><p>This materialization is used in the following situations:</p>
<ul>
<li><p>When a block argument has been converted to a different type, but
the original argument still has users that will remain live after
the conversion process has finished.</p></li>
<li><p>When the result type of an operation has been converted to a
different type, but the original result still has users that will
remain live after the conversion process is finished.</p></li>
</ul>
</li>
</ul>
</li>
<li><p>Target Materialization</p>
<ul>
<li><p>A target materialization converts from a value with an “illegal” source
type, to a value of a “legal” type. This is used when a pattern expects
the remapped operands to be of a certain set of types, but the original
input operands have not been converted. This may happen during a
conversion where some operations are converted to those with different
resultant types, but still retain uses of the original type system.</p></li>
<li><p>This materialization is used in the following situations:</p>
<ul>
<li><p>When the remapped operands of a
<a class="reference external" href="#conversion-patterns">conversion pattern</a> are not legal for the
type conversion provided by the pattern.</p></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>If a converted value is used by an operation that isn’t converted, it needs a
conversion back to the <code class="docutils literal notranslate"><span class="pre">source</span></code> type, hence source materialization; if an
unconverted value is used by an operation that is being converted, it needs
conversion to the <code class="docutils literal notranslate"><span class="pre">target</span></code> type, hence target materialization.</p>
<p>As noted above, the conversion process guarantees that the type contract of the
IR is preserved during the conversion. This means that the types of value uses
will not implicitly change during the conversion process. When the type of a
value definition, either block argument or operation result, is being changed,
the users of that definition must also be updated during the conversion process.
If they aren’t, a type conversion must be materialized to ensure that a value of
the expected type is still present within the IR. If a target materialization is
required, but cannot be performed, the pattern application fails. If a source
materialization is required, but cannot be performed, the entire conversion
process fails.</p>
<p>Several of the available hooks are detailed below:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">TypeConverter</span><span class="w"> </span><span class="p">{</span>
<span class="w"> </span><span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="c1">/// Register a conversion function. A conversion function defines how a given</span>
<span class="w">  </span><span class="c1">/// source type should be converted. A conversion function must be convertible</span>
<span class="w">  </span><span class="c1">/// to any of the following forms(where `T` is a class derived from `Type`:</span>
<span class="w">  </span><span class="c1">///   * Optional&lt;Type&gt;(T)</span>
<span class="w">  </span><span class="c1">///     - This form represents a 1-1 type conversion. It should return nullptr</span>
<span class="w">  </span><span class="c1">///       or `std::nullopt` to signify failure. If `std::nullopt` is returned, the</span>
<span class="w">  </span><span class="c1">///       converter is allowed to try another conversion function to perform</span>
<span class="w">  </span><span class="c1">///       the conversion.</span>
<span class="w">  </span><span class="c1">///   * Optional&lt;LogicalResult&gt;(T, SmallVectorImpl&lt;Type&gt; &amp;)</span>
<span class="w">  </span><span class="c1">///     - This form represents a 1-N type conversion. It should return</span>
<span class="w">  </span><span class="c1">///       `failure` or `std::nullopt` to signify a failed conversion. If the new</span>
<span class="w">  </span><span class="c1">///       set of types is empty, the type is removed and any usages of the</span>
<span class="w">  </span><span class="c1">///       existing value are expected to be removed during conversion. If</span>
<span class="w">  </span><span class="c1">///       `std::nullopt` is returned, the converter is allowed to try another</span>
<span class="w">  </span><span class="c1">///       conversion function to perform the conversion.</span>
<span class="w">  </span><span class="c1">///   * Optional&lt;LogicalResult&gt;(T, SmallVectorImpl&lt;Type&gt; &amp;, ArrayRef&lt;Type&gt;)</span>
<span class="w">  </span><span class="c1">///     - This form represents a 1-N type conversion supporting recursive</span>
<span class="w">  </span><span class="c1">///       types. The first two arguments and the return value are the same as</span>
<span class="w">  </span><span class="c1">///       for the regular 1-N form. The third argument is contains is the</span>
<span class="w">  </span><span class="c1">///       &quot;call stack&quot; of the recursive conversion: it contains the list of</span>
<span class="w">  </span><span class="c1">///       types currently being converted, with the current type being the</span>
<span class="w">  </span><span class="c1">///       last one. If it is present more than once in the list, the</span>
<span class="w">  </span><span class="c1">///       conversion concerns a recursive type.</span>
<span class="w">  </span><span class="c1">/// Note: When attempting to convert a type, e.g. via &#39;convertType&#39;, the</span>
<span class="w">  </span><span class="c1">///       mostly recently added conversions will be invoked first.</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">FnT</span><span class="p">,</span>
<span class="w">            </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">llvm</span><span class="o">::</span><span class="n">function_traits</span><span class="o">&lt;</span><span class="n">FnT</span><span class="o">&gt;::</span><span class="k">template</span><span class="w"> </span><span class="n">arg_t</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;&gt;</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">addConversion</span><span class="p">(</span><span class="n">FnT</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="n">callback</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">registerConversion</span><span class="p">(</span><span class="n">wrapCallback</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">FnT</span><span class="o">&gt;</span><span class="p">(</span><span class="n">callback</span><span class="p">)));</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">/// Register a materialization function, which must be convertible to the</span>
<span class="w">  </span><span class="c1">/// following form:</span>
<span class="w">  </span><span class="c1">///   `Optional&lt;Value&gt; (OpBuilder &amp;, T, ValueRange, Location)`,</span>
<span class="w">  </span><span class="c1">///   where `T` is any subclass of `Type`.</span>
<span class="w">  </span><span class="c1">/// This function is responsible for creating an operation, using the</span>
<span class="w">  </span><span class="c1">/// OpBuilder and Location provided, that &quot;converts&quot; a range of values into a</span>
<span class="w">  </span><span class="c1">/// single value of the given type `T`. It must return a Value of the</span>
<span class="w">  </span><span class="c1">/// converted type on success, an `std::nullopt` if it failed but other</span>
<span class="w">  </span><span class="c1">/// materialization can be attempted, and `nullptr` on unrecoverable failure.</span>
<span class="w">  </span><span class="c1">/// It will only be called for (sub)types of `T`.</span>
<span class="w">  </span><span class="c1">///</span>
<span class="w">  </span><span class="c1">/// This method registers a materialization that will be called when</span>
<span class="w">  </span><span class="c1">/// converting an illegal block argument type, to a legal type.</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">FnT</span><span class="p">,</span>
<span class="w">            </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">llvm</span><span class="o">::</span><span class="n">function_traits</span><span class="o">&lt;</span><span class="n">FnT</span><span class="o">&gt;::</span><span class="k">template</span><span class="w"> </span><span class="n">arg_t</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;&gt;</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">addArgumentMaterialization</span><span class="p">(</span><span class="n">FnT</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="n">callback</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">argumentMaterializations</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span>
<span class="w">        </span><span class="n">wrapMaterialization</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">FnT</span><span class="o">&gt;</span><span class="p">(</span><span class="n">callback</span><span class="p">)));</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">/// This method registers a materialization that will be called when</span>
<span class="w">  </span><span class="c1">/// converting a legal type to an illegal source type. This is used when</span>
<span class="w">  </span><span class="c1">/// conversions to an illegal type must persist beyond the main conversion.</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">FnT</span><span class="p">,</span>
<span class="w">            </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">llvm</span><span class="o">::</span><span class="n">function_traits</span><span class="o">&lt;</span><span class="n">FnT</span><span class="o">&gt;::</span><span class="k">template</span><span class="w"> </span><span class="n">arg_t</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;&gt;</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">addSourceMaterialization</span><span class="p">(</span><span class="n">FnT</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="n">callback</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">sourceMaterializations</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span>
<span class="w">        </span><span class="n">wrapMaterialization</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">FnT</span><span class="o">&gt;</span><span class="p">(</span><span class="n">callback</span><span class="p">)));</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">/// This method registers a materialization that will be called when</span>
<span class="w">  </span><span class="c1">/// converting type from an illegal, or source, type to a legal type.</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">FnT</span><span class="p">,</span>
<span class="w">            </span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">llvm</span><span class="o">::</span><span class="n">function_traits</span><span class="o">&lt;</span><span class="n">FnT</span><span class="o">&gt;::</span><span class="k">template</span><span class="w"> </span><span class="n">arg_t</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;&gt;</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">addTargetMaterialization</span><span class="p">(</span><span class="n">FnT</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="n">callback</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">targetMaterializations</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span>
<span class="w">        </span><span class="n">wrapMaterialization</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">FnT</span><span class="o">&gt;</span><span class="p">(</span><span class="n">callback</span><span class="p">)));</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="region-signature-conversion">
<h3>Region Signature Conversion<a class="headerlink" href="#region-signature-conversion" title="此标题的永久链接">¶</a></h3>
<p>From the perspective of type conversion, the types of block arguments are a bit
special. Throughout the conversion process, blocks may move between regions of
different operations. Given this, the conversion of the types for blocks must be
done explicitly via a conversion pattern. To convert the types of block
arguments within a Region, a custom hook on the <code class="docutils literal notranslate"><span class="pre">ConversionPatternRewriter</span></code> must
be invoked; <code class="docutils literal notranslate"><span class="pre">convertRegionTypes</span></code>. This hook uses a provided type converter to
apply type conversions to all blocks within a given region, and all blocks that
move into that region. As noted above, the conversions performed by this method
use the argument materialization hook on the <code class="docutils literal notranslate"><span class="pre">TypeConverter</span></code>. This hook also
takes an optional <code class="docutils literal notranslate"><span class="pre">TypeConverter::SignatureConversion</span></code> parameter that applies a
custom conversion to the entry block of the region. The types of the entry block
arguments are often tied semantically to details on the operation, e.g. func::FuncOp,
AffineForOp, etc. To convert the signature of just the region entry block, and
not any other blocks within the region, the <code class="docutils literal notranslate"><span class="pre">applySignatureConversion</span></code> hook may
be used instead. A signature conversion, <code class="docutils literal notranslate"><span class="pre">TypeConverter::SignatureConversion</span></code>,
can be built programmatically:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">SignatureConversion</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="c1">/// Remap an input of the original signature with a new set of types. The</span>
<span class="w">    </span><span class="c1">/// new types are appended to the new signature conversion.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">addInputs</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">origInputNo</span><span class="p">,</span><span class="w"> </span><span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="w"> </span><span class="n">types</span><span class="p">);</span>

<span class="w">    </span><span class="c1">/// Append new input types to the signature conversion, this should only be</span>
<span class="w">    </span><span class="c1">/// used if the new types are not intended to remap an existing input.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">addInputs</span><span class="p">(</span><span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span><span class="w"> </span><span class="n">types</span><span class="p">);</span>

<span class="w">    </span><span class="c1">/// Remap an input of the original signature with a range of types in the</span>
<span class="w">    </span><span class="c1">/// new signature.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">remapInput</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">origInputNo</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">newInputNo</span><span class="p">,</span>
<span class="w">                    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">newInputCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>

<span class="w">    </span><span class="c1">/// Remap an input of the original signature to another `replacement`</span>
<span class="w">    </span><span class="c1">/// value. This drops the original argument.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">remapInput</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="n">origInputNo</span><span class="p">,</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="n">replacement</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">TypeConverter</span></code> provides several default utilities for signature conversion
and legality checking:
<code class="docutils literal notranslate"><span class="pre">convertSignatureArgs</span></code>/<code class="docutils literal notranslate"><span class="pre">convertBlockSignature</span></code>/<code class="docutils literal notranslate"><span class="pre">isLegal(Region</span> <span class="pre">*|Type)</span></code>.</p>
</section>
</section>
<section id="debugging">
<h2>Debugging<a class="headerlink" href="#debugging" title="此标题的永久链接">¶</a></h2>
<p>To debug the execution of the dialect conversion framework,
<code class="docutils literal notranslate"><span class="pre">-debug-only=dialect-conversion</span></code> may be used. This command line flag activates
LLVM’s debug logging infrastructure solely for the conversion framework. The
output is formatted as a tree structure, mirroring the structure of the
conversion process. This output contains all of the actions performed by the
rewriter, how generated operations get legalized, and why they fail.</p>
<p>Example output is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//===-------------------------------------------===//</span>
<span class="n">Legalizing</span> <span class="n">operation</span> <span class="p">:</span> <span class="s1">&#39;func.return&#39;</span><span class="p">(</span><span class="mh">0x608000002e20</span><span class="p">)</span> <span class="p">{</span>
  <span class="s2">&quot;func.return&quot;</span><span class="p">()</span> <span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="p">()</span>

  <span class="o">*</span> <span class="n">Fold</span> <span class="p">{</span>
  <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">FAILURE</span> <span class="p">:</span> <span class="n">unable</span> <span class="n">to</span> <span class="n">fold</span>

  <span class="o">*</span> <span class="n">Pattern</span> <span class="p">:</span> <span class="s1">&#39;func.return -&gt; ()&#39;</span> <span class="p">{</span>
    <span class="o">**</span> <span class="n">Insert</span>  <span class="p">:</span> <span class="s1">&#39;spirv.Return&#39;</span><span class="p">(</span><span class="mh">0x6070000453e0</span><span class="p">)</span>
    <span class="o">**</span> <span class="n">Replace</span> <span class="p">:</span> <span class="s1">&#39;func.return&#39;</span><span class="p">(</span><span class="mh">0x608000002e20</span><span class="p">)</span>

    <span class="o">//===-------------------------------------------===//</span>
    <span class="n">Legalizing</span> <span class="n">operation</span> <span class="p">:</span> <span class="s1">&#39;spirv.Return&#39;</span><span class="p">(</span><span class="mh">0x6070000453e0</span><span class="p">)</span> <span class="p">{</span>
      <span class="s2">&quot;spirv.Return&quot;</span><span class="p">()</span> <span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="p">()</span>

    <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">SUCCESS</span> <span class="p">:</span> <span class="n">operation</span> <span class="n">marked</span> <span class="n">legal</span> <span class="n">by</span> <span class="n">the</span> <span class="n">target</span>
    <span class="o">//===-------------------------------------------===//</span>
  <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">SUCCESS</span> <span class="p">:</span> <span class="n">pattern</span> <span class="n">applied</span> <span class="n">successfully</span>
<span class="p">}</span> <span class="o">-&gt;</span> <span class="n">SUCCESS</span>
<span class="o">//===-------------------------------------------===//</span>
</pre></div>
</div>
<p>This output is describing the legalization of an <code class="docutils literal notranslate"><span class="pre">func.return</span></code> operation. We
first try to legalize by folding the operation, but that is unsuccessful for
<code class="docutils literal notranslate"><span class="pre">func.return</span></code>. From there, a pattern is applied that replaces the <code class="docutils literal notranslate"><span class="pre">func.return</span></code>
with a <code class="docutils literal notranslate"><span class="pre">spirv.Return</span></code>. The newly generated <code class="docutils literal notranslate"><span class="pre">spirv.Return</span></code> is then processed for
legalization, but is found to already legal as per the target.</p>
</section>
</section>


          </div>
          <div class="page-nav">
            <div class="inner"><ul class="page-nav">
</ul><div class="footer" role="contentinfo">
      &#169; 版权所有 2023, yaoyue123.
    <br>
    Created using <a href="http://sphinx-doc.org/">Sphinx</a> 6.1.3 with <a href="https://github.com/schettino72/sphinx_press_theme">Press Theme</a> 0.8.0.
</div>
            </div>
          </div>
      </page>
    </div></div>
    
    
  </body>
</html>