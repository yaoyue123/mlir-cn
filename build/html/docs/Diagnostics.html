<!DOCTYPE html>
<html  lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

      <title>Diagnostic Infrastructure</title>
    
          <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
          <link rel="stylesheet" href="../_static/theme.css " type="text/css" />
      
      <!-- sphinx script_files -->
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script src="../_static/translations.js"></script>

      
      <!-- bundled in js (rollup iife) -->
      <!-- <script src="../_static/theme-vendors.js"></script> -->
      <script src="../_static/theme.js" defer></script>
    
  <link rel="index" title="索引" href="../genindex.html" />
  <link rel="search" title="搜索" href="../search.html" /> 
  </head>

  <body>
    <div id="app">
    <div class="theme-container" :class="pageClasses"><navbar @toggle-sidebar="toggleSidebar">
  <router-link to="../index.html" class="home-link">
    
      <span class="site-name">MLIR 中文文档</span>
    
  </router-link>

  <div class="links">
    <navlinks class="can-hide">



    </navlinks>
  </div>
</navbar>

      
      <div class="sidebar-mask" @click="toggleSidebar(false)">
      </div>
        <sidebar @toggle-sidebar="toggleSidebar">
          
          <navlinks>
            



            
          </navlinks><div id="searchbox" class="searchbox" role="search">
  <div class="caption"><span class="caption-text">快速搜索</span>
    <div class="searchformwrapper">
      <form class="search" action="../search.html" method="get">
        <input type="text" name="q" />
        <input type="submit" value="搜索" />
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div><div class="sidebar-links" role="navigation" aria-label="main navigation">
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../index.html#mlir">欢迎使用 mlir 中文文档</a></span>
      </p>
      <ul class="">
        
          <li class="toctree-l1 ">
            
              <a href="../_index.html" class="reference internal ">开始使用MLIR</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/CreatingADialect.html" class="reference internal ">Creating a Dialect</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/DataFlowAnalysis.html" class="reference internal ">Writing DataFlow Analyses in MLIR</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/QuickstartRewrites.html" class="reference internal ">Quickstart tutorial to adding MLIR graph rewrite</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-1.html" class="reference internal ">第1章：Toy语言和AST（抽象语法树）</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-2.html" class="reference internal ">Chapter 2: Emitting Basic MLIR</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-3.html" class="reference internal ">Chapter 3: High-level Language-Specific Analysis and Transformation</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-4.html" class="reference internal ">Chapter 4: Enabling Generic Transformation with Interfaces</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-5.html" class="reference internal ">Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-6.html" class="reference internal ">Chapter 6: Lowering to LLVM and CodeGeneration</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-7.html" class="reference internal ">Chapter 7: Adding a Composite Type to Toy</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/_index.html" class="reference internal ">Toy 入门教程</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/UnderstandingTheIRStructure.html" class="reference internal ">Understanding the IR Structure</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/_index.html" class="reference internal ">Tutorials</a>
            

            
          </li>

        
      </ul>
    </div>
  
</div>
        </sidebar>

      <page>
          <div class="body-header" role="navigation" aria-label="navigation">
  
  <ul class="breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
    
    <li>Diagnostic Infrastructure</li>
  </ul>
  

  <ul class="page-nav">
</ul>
  
</div>
<hr>
          <div class="content" role="main" v-pre>
            
  <section id="diagnostic-infrastructure">
<h1>Diagnostic Infrastructure<a class="headerlink" href="#diagnostic-infrastructure" title="此标题的永久链接">¶</a></h1>
<p>[TOC]</p>
<p>This document presents an introduction to using and interfacing with MLIR’s
diagnostics infrastructure.</p>
<p>See <a class="reference internal" href="LangRef.html"><span class="doc">MLIR specification</span></a> for more information about MLIR, the
structure of the IR, operations, etc.</p>
<section id="source-locations">
<h2>Source Locations<a class="headerlink" href="#source-locations" title="此标题的永久链接">¶</a></h2>
<p>Source location information is extremely important for any compiler, because it
provides a baseline for debuggability and error-reporting. The
<a class="reference internal" href="Dialects/Builtin.html"><span class="doc">builtin dialect</span></a> provides several different location
attributes types depending on the situational need.</p>
</section>
<section id="diagnostic-engine">
<h2>Diagnostic Engine<a class="headerlink" href="#diagnostic-engine" title="此标题的永久链接">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">DiagnosticEngine</span></code> acts as the main interface for diagnostics in MLIR. It
manages the registration of diagnostic handlers, as well as the core API for
diagnostic emission. Handlers generally take the form of
<code class="docutils literal notranslate"><span class="pre">LogicalResult(Diagnostic</span> <span class="pre">&amp;)</span></code>. If the result is <code class="docutils literal notranslate"><span class="pre">success</span></code>, it signals that the
diagnostic has been fully processed and consumed. If <code class="docutils literal notranslate"><span class="pre">failure</span></code>, it signals that
the diagnostic should be propagated to any previously registered handlers. It
can be interfaced with via an <code class="docutils literal notranslate"><span class="pre">MLIRContext</span></code> instance.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">DiagnosticEngine</span><span class="o">&amp;</span><span class="w"> </span><span class="n">engine</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">getDiagEngine</span><span class="p">();</span>

<span class="c1">/// Handle the reported diagnostic.</span>
<span class="c1">// Return success to signal that the diagnostic has either been fully processed,</span>
<span class="c1">// or failure if the diagnostic should be propagated to the previous handlers.</span>
<span class="n">DiagnosticEngine</span><span class="o">::</span><span class="n">HandlerID</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">engine</span><span class="p">.</span><span class="n">registerHandler</span><span class="p">(</span>
<span class="w">    </span><span class="p">[](</span><span class="n">Diagnostic</span><span class="w"> </span><span class="o">&amp;</span><span class="n">diag</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">LogicalResult</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">should_propagate_diagnostic</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">failure</span><span class="p">(</span><span class="n">should_propagate_diagnostic</span><span class="p">);</span>
<span class="p">});</span>


<span class="c1">// We can also elide the return value completely, in which the engine assumes</span>
<span class="c1">// that all diagnostics are consumed(i.e. a success() result).</span>
<span class="n">DiagnosticEngine</span><span class="o">::</span><span class="n">HandlerID</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">engine</span><span class="p">.</span><span class="n">registerHandler</span><span class="p">([](</span><span class="n">Diagnostic</span><span class="w"> </span><span class="o">&amp;</span><span class="n">diag</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="p">;</span>
<span class="p">});</span>

<span class="c1">// Unregister this handler when we are done.</span>
<span class="n">engine</span><span class="p">.</span><span class="n">eraseHandler</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
</pre></div>
</div>
<section id="constructing-a-diagnostic">
<h3>Constructing a Diagnostic<a class="headerlink" href="#constructing-a-diagnostic" title="此标题的永久链接">¶</a></h3>
<p>As stated above, the <code class="docutils literal notranslate"><span class="pre">DiagnosticEngine</span></code> holds the core API for diagnostic
emission. A new diagnostic can be emitted with the engine via <code class="docutils literal notranslate"><span class="pre">emit</span></code>. This
method returns an <a class="reference external" href="#inflight-diagnostic">InFlightDiagnostic</a> that can be
modified further.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">InFlightDiagnostic</span><span class="w"> </span><span class="nf">emit</span><span class="p">(</span><span class="n">Location</span><span class="w"> </span><span class="n">loc</span><span class="p">,</span><span class="w"> </span><span class="n">DiagnosticSeverity</span><span class="w"> </span><span class="n">severity</span><span class="p">);</span>
</pre></div>
</div>
<p>Using the <code class="docutils literal notranslate"><span class="pre">DiagnosticEngine</span></code>, though, is generally not the preferred way to emit
diagnostics in MLIR. <a class="reference external" href="LangRef.md/#operations"><code class="docutils literal notranslate"><span class="pre">operation</span></code></a> provides utility
methods for emitting diagnostics:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// `emit` methods available in the mlir namespace.</span>
<span class="n">InFlightDiagnostic</span><span class="w"> </span><span class="n">emitError</span><span class="o">/</span><span class="n">Remark</span><span class="o">/</span><span class="n">Warning</span><span class="p">(</span><span class="n">Location</span><span class="p">);</span>

<span class="c1">// These methods use the location attached to the operation.</span>
<span class="n">InFlightDiagnostic</span><span class="w"> </span><span class="n">Operation</span><span class="o">::</span><span class="n">emitError</span><span class="o">/</span><span class="n">Remark</span><span class="o">/</span><span class="n">Warning</span><span class="p">();</span>

<span class="c1">// This method creates a diagnostic prefixed with &quot;&#39;op-name&#39; op &quot;.</span>
<span class="n">InFlightDiagnostic</span><span class="w"> </span><span class="nf">Operation::emitOpError</span><span class="p">();</span>
</pre></div>
</div>
</section>
</section>
<section id="diagnostic">
<h2>Diagnostic<a class="headerlink" href="#diagnostic" title="此标题的永久链接">¶</a></h2>
<p>A <code class="docutils literal notranslate"><span class="pre">Diagnostic</span></code> in MLIR contains all of the necessary information for reporting a
message to the user. A <code class="docutils literal notranslate"><span class="pre">Diagnostic</span></code> essentially boils down to three main
components:</p>
<ul class="simple">
<li><p><a class="reference external" href="#source-locations">Source Location</a></p></li>
<li><p>Severity Level</p>
<ul>
<li><p>Error, Note, Remark, Warning</p></li>
</ul>
</li>
<li><p>Diagnostic Arguments</p>
<ul>
<li><p>The diagnostic arguments are used when constructing the output message.</p></li>
</ul>
</li>
</ul>
<section id="appending-arguments">
<h3>Appending arguments<a class="headerlink" href="#appending-arguments" title="此标题的永久链接">¶</a></h3>
<p>One a diagnostic has been constructed, the user can start composing it. The
output message of a diagnostic is composed of a set of diagnostic arguments that
have been attached to it. New arguments can be attached to a diagnostic in a few
different ways:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// A few interesting things to use when composing a diagnostic.</span>
<span class="n">Attribute</span><span class="w"> </span><span class="n">fooAttr</span><span class="p">;</span>
<span class="n">Type</span><span class="w"> </span><span class="n">fooType</span><span class="p">;</span>
<span class="n">SmallVector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fooInts</span><span class="p">;</span>

<span class="c1">// Diagnostics can be composed via the streaming operators.</span>
<span class="n">op</span><span class="o">-&gt;</span><span class="n">emitError</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Compose an interesting error: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">fooAttr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">fooType</span>
<span class="w">                </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, (&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">fooInts</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;)&#39;</span><span class="p">;</span>

<span class="c1">// This could generate something like (FuncAttr:@foo, IntegerType:i32, {0,1,2}):</span>
<span class="s">&quot;Compose an interesting error: @foo, i32, (0, 1, 2)&quot;</span>
</pre></div>
</div>
<p>Operations attached to a diagnostic will be printed in generic form if the
severity level is <code class="docutils literal notranslate"><span class="pre">Error</span></code>, otherwise custom operation printers will be used.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// `anotherOp` will be printed in generic form,</span>
<span class="c1">// e.g. %3 = &quot;arith.addf&quot;(%arg4, %2) : (f32, f32) -&gt; f32</span>
<span class="n">op</span><span class="o">-&gt;</span><span class="n">emitError</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">anotherOp</span><span class="p">;</span>

<span class="c1">// `anotherOp` will be printed using the custom printer,</span>
<span class="c1">// e.g. %3 = arith.addf %arg4, %2 : f32</span>
<span class="n">op</span><span class="o">-&gt;</span><span class="n">emitRemark</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">anotherOp</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="attaching-notes">
<h3>Attaching notes<a class="headerlink" href="#attaching-notes" title="此标题的永久链接">¶</a></h3>
<p>Unlike many other compiler frameworks, notes in MLIR cannot be emitted directly.
They must be explicitly attached to another diagnostic non-note diagnostic. When
emitting a diagnostic, notes can be directly attached via <code class="docutils literal notranslate"><span class="pre">attachNote</span></code>. When
attaching a note, if the user does not provide an explicit source location the
note will inherit the location of the parent diagnostic.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Emit a note with an explicit source location.</span>
<span class="n">op</span><span class="o">-&gt;</span><span class="n">emitError</span><span class="p">(</span><span class="s">&quot;...&quot;</span><span class="p">).</span><span class="n">attachNote</span><span class="p">(</span><span class="n">noteLoc</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;...&quot;</span><span class="p">;</span>

<span class="c1">// Emit a note that inherits the parent location.</span>
<span class="n">op</span><span class="o">-&gt;</span><span class="n">emitError</span><span class="p">(</span><span class="s">&quot;...&quot;</span><span class="p">).</span><span class="n">attachNote</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;...&quot;</span><span class="p">;</span>
</pre></div>
</div>
</section>
</section>
<section id="inflight-diagnostic">
<h2>InFlight Diagnostic<a class="headerlink" href="#inflight-diagnostic" title="此标题的永久链接">¶</a></h2>
<p>Now that <a class="reference external" href="#diagnostic">Diagnostics</a> have been explained, we introduce the
<code class="docutils literal notranslate"><span class="pre">InFlightDiagnostic</span></code>, an RAII wrapper around a diagnostic that is set to be
reported. This allows for modifying a diagnostic while it is still in flight. If
it is not reported directly by the user it will automatically report when
destroyed.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
<span class="w">  </span><span class="n">InFlightDiagnostic</span><span class="w"> </span><span class="n">diag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">op</span><span class="o">-&gt;</span><span class="n">emitError</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;...&quot;</span><span class="p">;</span>
<span class="p">}</span><span class="w">  </span><span class="c1">// The diagnostic is automatically reported here.</span>
</pre></div>
</div>
</section>
<section id="diagnostic-configuration-options">
<h2>Diagnostic Configuration Options<a class="headerlink" href="#diagnostic-configuration-options" title="此标题的永久链接">¶</a></h2>
<p>Several options are provided to help control and enhance the behavior of
diagnostics. These options can be configured via the MLIRContext, and registered
to the command line with the <code class="docutils literal notranslate"><span class="pre">registerMLIRContextCLOptions</span></code> method. These
options are listed below:</p>
<section id="print-operation-on-diagnostic">
<h3>Print Operation On Diagnostic<a class="headerlink" href="#print-operation-on-diagnostic" title="此标题的永久链接">¶</a></h3>
<p>Command Line Flag: <code class="docutils literal notranslate"><span class="pre">-mlir-print-op-on-diagnostic</span></code></p>
<p>When a diagnostic is emitted on an operation, via <code class="docutils literal notranslate"><span class="pre">Operation::emitError/...</span></code>,
the textual form of that operation is printed and attached as a note to the
diagnostic. This option is useful for understanding the current form of an
operation that may be invalid, especially when debugging verifier failures. An
example output is shown below:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>test.mlir:3:3:<span class="w"> </span>error:<span class="w"> </span><span class="s1">&#39;module_terminator&#39;</span><span class="w"> </span>op<span class="w"> </span>expects<span class="w"> </span>parent<span class="w"> </span>op<span class="w"> </span><span class="s1">&#39;builtin.module&#39;</span>
<span class="w">  </span><span class="s2">&quot;module_terminator&quot;</span><span class="o">()</span><span class="w"> </span>:<span class="w"> </span><span class="o">()</span><span class="w"> </span>-&gt;<span class="w"> </span><span class="o">()</span>
<span class="w">  </span>^
test.mlir:3:3:<span class="w"> </span>note:<span class="w"> </span>see<span class="w"> </span>current<span class="w"> </span>operation:<span class="w"> </span><span class="s2">&quot;module_terminator&quot;</span><span class="o">()</span><span class="w"> </span>:<span class="w"> </span><span class="o">()</span><span class="w"> </span>-&gt;<span class="w"> </span><span class="o">()</span>
<span class="w">  </span><span class="s2">&quot;module_terminator&quot;</span><span class="o">()</span><span class="w"> </span>:<span class="w"> </span><span class="o">()</span><span class="w"> </span>-&gt;<span class="w"> </span><span class="o">()</span>
<span class="w">  </span>^
</pre></div>
</div>
</section>
<section id="print-stacktrace-on-diagnostic">
<h3>Print StackTrace On Diagnostic<a class="headerlink" href="#print-stacktrace-on-diagnostic" title="此标题的永久链接">¶</a></h3>
<p>Command Line Flag: <code class="docutils literal notranslate"><span class="pre">-mlir-print-stacktrace-on-diagnostic</span></code></p>
<p>When a diagnostic is emitted, attach the current stack trace as a note to the
diagnostic. This option is useful for understanding which part of the compiler
generated certain diagnostics. An example output is shown below:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>test.mlir:3:3:<span class="w"> </span>error:<span class="w"> </span><span class="s1">&#39;module_terminator&#39;</span><span class="w"> </span>op<span class="w"> </span>expects<span class="w"> </span>parent<span class="w"> </span>op<span class="w"> </span><span class="s1">&#39;builtin.module&#39;</span>
<span class="w">  </span><span class="s2">&quot;module_terminator&quot;</span><span class="o">()</span><span class="w"> </span>:<span class="w"> </span><span class="o">()</span><span class="w"> </span>-&gt;<span class="w"> </span><span class="o">()</span>
<span class="w">  </span>^
test.mlir:3:3:<span class="w"> </span>note:<span class="w"> </span>diagnostic<span class="w"> </span>emitted<span class="w"> </span>with<span class="w"> </span>trace:
<span class="w"> </span><span class="c1">#0 0x000055dd40543805 llvm::sys::PrintStackTrace(llvm::raw_ostream&amp;) llvm/lib/Support/Unix/Signals.inc:553:11</span>
<span class="w"> </span><span class="c1">#1 0x000055dd3f8ac162 emitDiag(mlir::Location, mlir::DiagnosticSeverity, llvm::Twine const&amp;) /lib/IR/Diagnostics.cpp:292:7</span>
<span class="w"> </span><span class="c1">#2 0x000055dd3f8abe8e mlir::emitError(mlir::Location, llvm::Twine const&amp;) /lib/IR/Diagnostics.cpp:304:10</span>
<span class="w"> </span><span class="c1">#3 0x000055dd3f998e87 mlir::Operation::emitError(llvm::Twine const&amp;) /lib/IR/Operation.cpp:324:29</span>
<span class="w"> </span><span class="c1">#4 0x000055dd3f99d21c mlir::Operation::emitOpError(llvm::Twine const&amp;) /lib/IR/Operation.cpp:652:10</span>
<span class="w"> </span><span class="c1">#5 0x000055dd3f96b01c mlir::OpTrait::HasParent&lt;mlir::ModuleOp&gt;::Impl&lt;mlir::ModuleTerminatorOp&gt;::verifyTrait(mlir::Operation*) /mlir/IR/OpDefinition.h:897:18</span>
<span class="w"> </span><span class="c1">#6 0x000055dd3f96ab38 mlir::Op&lt;mlir::ModuleTerminatorOp, mlir::OpTrait::ZeroOperands, mlir::OpTrait::ZeroResults, mlir::OpTrait::HasParent&lt;mlir::ModuleOp&gt;::Impl, mlir::OpTrait::IsTerminator&gt;::BaseVerifier&lt;mlir::OpTrait::HasParent&lt;mlir::ModuleOp&gt;::Impl&lt;mlir::ModuleTerminatorOp&gt;, mlir::OpTrait::IsTerminator&lt;mlir::ModuleTerminatorOp&gt; &gt;::verifyTrait(mlir::Operation*) /mlir/IR/OpDefinition.h:1052:29</span>
<span class="w"> </span><span class="c1">#  ...</span>
<span class="w">  </span><span class="s2">&quot;module_terminator&quot;</span><span class="o">()</span><span class="w"> </span>:<span class="w"> </span><span class="o">()</span><span class="w"> </span>-&gt;<span class="w"> </span><span class="o">()</span>
<span class="w">  </span>^
</pre></div>
</div>
</section>
</section>
<section id="common-diagnostic-handlers">
<h2>Common Diagnostic Handlers<a class="headerlink" href="#common-diagnostic-handlers" title="此标题的永久链接">¶</a></h2>
<p>To interface with the diagnostics infrastructure, users will need to register a
diagnostic handler with the <a class="reference external" href="#diagnostic-engine"><code class="docutils literal notranslate"><span class="pre">DiagnosticEngine</span></code></a>.
Recognizing the many users will want the same handler functionality, MLIR
provides several common diagnostic handlers for immediate use.</p>
<section id="scoped-diagnostic-handler">
<h3>Scoped Diagnostic Handler<a class="headerlink" href="#scoped-diagnostic-handler" title="此标题的永久链接">¶</a></h3>
<p>This diagnostic handler is a simple RAII class that registers and unregisters a
given diagnostic handler. This class can be either be used directly, or in
conjunction with a derived diagnostic handler.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Construct the handler directly.</span>
<span class="n">MLIRContext</span><span class="w"> </span><span class="n">context</span><span class="p">;</span>
<span class="n">ScopedDiagnosticHandler</span><span class="w"> </span><span class="nf">scopedHandler</span><span class="p">(</span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="p">[](</span><span class="n">Diagnostic</span><span class="w"> </span><span class="o">&amp;</span><span class="n">diag</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">});</span>

<span class="c1">// Use this handler in conjunction with another.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MyDerivedHandler</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">ScopedDiagnosticHandler</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">MyDerivedHandler</span><span class="p">(</span><span class="n">MLIRContext</span><span class="w"> </span><span class="o">*</span><span class="n">ctx</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ScopedDiagnosticHandler</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Set the handler that should be RAII managed.</span>
<span class="w">    </span><span class="n">setHandler</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">Diagnostic</span><span class="w"> </span><span class="n">diag</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="p">...</span>
<span class="w">    </span><span class="p">});</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="sourcemgr-diagnostic-handler">
<h3>SourceMgr Diagnostic Handler<a class="headerlink" href="#sourcemgr-diagnostic-handler" title="此标题的永久链接">¶</a></h3>
<p>This diagnostic handler is a wrapper around an llvm::SourceMgr instance. It
provides support for displaying diagnostic messages inline with a line of a
respective source file. This handler will also automatically load newly seen
source files into the SourceMgr when attempting to display the source line of a
diagnostic. Example usage of this handler can be seen in the <code class="docutils literal notranslate"><span class="pre">mlir-opt</span></code> tool.</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>mlir-opt<span class="w"> </span>foo.mlir

/tmp/test.mlir:6:24:<span class="w"> </span>error:<span class="w"> </span>expected<span class="w"> </span>non-function<span class="w"> </span><span class="nb">type</span>
func.func<span class="w"> </span>@foo<span class="o">()</span><span class="w"> </span>-&gt;<span class="w"> </span><span class="o">(</span>index,<span class="w"> </span>ind<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">                       </span>^
</pre></div>
</div>
<p>To use this handler in your tool, add the following:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">SourceMgr</span><span class="w"> </span><span class="n">sourceMgr</span><span class="p">;</span>
<span class="n">MLIRContext</span><span class="w"> </span><span class="n">context</span><span class="p">;</span>
<span class="n">SourceMgrDiagnosticHandler</span><span class="w"> </span><span class="nf">sourceMgrHandler</span><span class="p">(</span><span class="n">sourceMgr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">context</span><span class="p">);</span>
</pre></div>
</div>
<section id="filtering-locations">
<h4>Filtering Locations<a class="headerlink" href="#filtering-locations" title="此标题的永久链接">¶</a></h4>
<p>In some situations, a diagnostic may be emitted with a callsite location in a
very deep call stack in which many frames are unrelated to the user source code.
These situations often arise when the user source code is intertwined with that
of a large framework or library. The context of the diagnostic in these cases is
often obfuscated by the unrelated framework source locations. To help alleviate
this obfuscation, the <code class="docutils literal notranslate"><span class="pre">SourceMgrDiagnosticHandler</span></code> provides support for
filtering which locations are shown to the user. To enable filtering, a user
must simply provide a filter function to the <code class="docutils literal notranslate"><span class="pre">SourceMgrDiagnosticHandler</span></code> on
construction that indicates which locations should be shown. A quick example is
shown below:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Here we define the functor that controls which locations are shown to the</span>
<span class="c1">// user. This functor should return true when a location should be shown, and</span>
<span class="c1">// false otherwise. When filtering a container location, such as a NameLoc, this</span>
<span class="c1">// function should not recurse into the child location. Recursion into nested</span>
<span class="c1">// location is performed as necessary by the caller.</span>
<span class="k">auto</span><span class="w"> </span><span class="n">shouldShowFn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="n">Location</span><span class="w"> </span><span class="n">loc</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">FileLineColLoc</span><span class="w"> </span><span class="n">fileLoc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">loc</span><span class="p">.</span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">FileLineColLoc</span><span class="o">&gt;</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// We don&#39;t perform any filtering on non-file locations.</span>
<span class="w">  </span><span class="c1">// Reminder: The caller will recurse into any necessary child locations.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">fileLoc</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Don&#39;t show file locations that contain our framework code.</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="o">!</span><span class="n">fileLoc</span><span class="p">.</span><span class="n">getFilename</span><span class="p">().</span><span class="n">strref</span><span class="p">().</span><span class="n">contains</span><span class="p">(</span><span class="s">&quot;my/framework/source/&quot;</span><span class="p">);</span>
<span class="p">};</span>

<span class="n">SourceMgr</span><span class="w"> </span><span class="n">sourceMgr</span><span class="p">;</span>
<span class="n">MLIRContext</span><span class="w"> </span><span class="n">context</span><span class="p">;</span>
<span class="n">SourceMgrDiagnosticHandler</span><span class="w"> </span><span class="nf">sourceMgrHandler</span><span class="p">(</span><span class="n">sourceMgr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="n">shouldShowFn</span><span class="p">);</span>
</pre></div>
</div>
<p>Note: In the case where all locations are filtered out, the first location in
the stack will still be shown.</p>
</section>
</section>
<section id="sourcemgr-diagnostic-verifier-handler">
<h3>SourceMgr Diagnostic Verifier Handler<a class="headerlink" href="#sourcemgr-diagnostic-verifier-handler" title="此标题的永久链接">¶</a></h3>
<p>This handler is a wrapper around a llvm::SourceMgr that is used to verify that
certain diagnostics have been emitted to the context. To use this handler,
annotate your source file with expected diagnostics in the form of:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">expected-(error|note|remark|warning)(-re)?</span> <span class="pre">{{</span> <span class="pre">message</span> <span class="pre">}}</span></code></p></li>
</ul>
<p>The provided <code class="docutils literal notranslate"><span class="pre">message</span></code> is a string expected to be contained within the generated
diagnostic. The <code class="docutils literal notranslate"><span class="pre">-re</span></code> suffix may be used to enable regex matching within the
<code class="docutils literal notranslate"><span class="pre">message</span></code>. When present, the <code class="docutils literal notranslate"><span class="pre">message</span></code> may define regex match sequences within
<code class="docutils literal notranslate"><span class="pre">{{</span></code> <code class="docutils literal notranslate"><span class="pre">}}</span></code> blocks. The regular expression matcher supports Extended POSIX regular
expressions (ERE). A few examples are shown below:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>// Expect an error on the same line.
func.func @bad_branch() {
  cf.br ^missing  // expected-error {{reference to an undefined block}}
}

// Expect an error on an adjacent line.
func.func @foo(%a : f32) {
  // expected-error@+1 {{unknown comparison predicate &quot;foo&quot;}}
  %result = arith.cmpf &quot;foo&quot;, %a, %a : f32
  return
}

// Expect an error on the next line that does not contain a designator.
// expected-remark@below {{remark on function below}}
// expected-remark@below {{another remark on function below}}
func.func @bar(%a : f32)

// Expect an error on the previous line that does not contain a designator.
func.func @baz(%a : f32)
// expected-remark@above {{remark on function above}}
// expected-remark@above {{another remark on function above}}

// Expect an error mentioning the parent function, but use regex to avoid
// hardcoding the name.
func.func @foo() -&gt; i32 {
  // expected-error-re@+1 {{&#39;func.return&#39; op has 0 operands, but enclosing function (@{{.*}}) returns 1}}
  return
}
</pre></div>
</div>
<p>The handler will report an error if any unexpected diagnostics were seen, or if
any expected diagnostics weren’t.</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>mlir-opt<span class="w"> </span>foo.mlir

/tmp/test.mlir:6:24:<span class="w"> </span>error:<span class="w"> </span>unexpected<span class="w"> </span>error:<span class="w"> </span>expected<span class="w"> </span>non-function<span class="w"> </span><span class="nb">type</span>
func.func<span class="w"> </span>@foo<span class="o">()</span><span class="w"> </span>-&gt;<span class="w"> </span><span class="o">(</span>index,<span class="w"> </span>ind<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">                       </span>^

/tmp/test.mlir:15:4:<span class="w"> </span>error:<span class="w"> </span>expected<span class="w"> </span>remark<span class="w"> </span><span class="s2">&quot;expected some remark&quot;</span><span class="w"> </span>was<span class="w"> </span>not<span class="w"> </span>produced
//<span class="w"> </span>expected-remark<span class="w"> </span><span class="o">{{</span>expected<span class="w"> </span>some<span class="w"> </span>remark<span class="o">}}</span>
<span class="w">   </span>^~~~~~~~~~~~~~~~~~~~~~~~~~
</pre></div>
</div>
<p>Similarly to the <a class="reference external" href="#sourcemgr-diagnostic-handler">SourceMgr Diagnostic Handler</a>,
this handler can be added to any tool via the following:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">SourceMgr</span><span class="w"> </span><span class="n">sourceMgr</span><span class="p">;</span>
<span class="n">MLIRContext</span><span class="w"> </span><span class="n">context</span><span class="p">;</span>
<span class="n">SourceMgrDiagnosticVerifierHandler</span><span class="w"> </span><span class="nf">sourceMgrHandler</span><span class="p">(</span><span class="n">sourceMgr</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">context</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="parallel-diagnostic-handler">
<h3>Parallel Diagnostic Handler<a class="headerlink" href="#parallel-diagnostic-handler" title="此标题的永久链接">¶</a></h3>
<p>MLIR is designed from the ground up to be multi-threaded. One important to thing
to keep in mind when multi-threading is determinism. This means that the
behavior seen when operating on multiple threads is the same as when operating
on a single thread. For diagnostics, this means that the ordering of the
diagnostics is the same regardless of the amount of threads being operated on.
The ParallelDiagnosticHandler is introduced to solve this problem.</p>
<p>After creating a handler of this type, the only remaining step is to ensure that
each thread that will be emitting diagnostics to the handler sets a respective
‘orderID’. The orderID corresponds to the order in which diagnostics would be
emitted when executing synchronously. For example, if we were processing a list
of operations [a, b, c] on a single-thread. Diagnostics emitted while processing
operation ‘a’ would be emitted before those for ‘b’ or ‘c’. This corresponds 1-1
with the ‘orderID’. The thread that is processing ‘a’ should set the orderID to
‘0’; the thread processing ‘b’ should set it to ‘1’; and so on and so forth.
This provides a way for the handler to deterministically order the diagnostics
that it receives given the thread that it is receiving on.</p>
<p>A simple example is shown below:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MLIRContext</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="n">ParallelDiagnosticHandler</span><span class="w"> </span><span class="nf">handler</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>

<span class="c1">// Process a list of operations in parallel.</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Operation</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="n">opsToProcess</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="n">llvm</span><span class="o">::</span><span class="n">parallelFor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">opsToProcess</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Notify the handler that we are processing the i&#39;th operation.</span>
<span class="w">  </span><span class="n">handler</span><span class="p">.</span><span class="n">setOrderIDForThread</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">opsToProcess</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">  </span><span class="p">...</span>

<span class="w">  </span><span class="c1">// Notify the handler that we are finished processing diagnostics on this</span>
<span class="w">  </span><span class="c1">// thread.</span>
<span class="w">  </span><span class="n">handler</span><span class="p">.</span><span class="n">eraseOrderIDForThread</span><span class="p">();</span>
<span class="p">});</span>
</pre></div>
</div>
</section>
</section>
</section>


          </div>
          <div class="page-nav">
            <div class="inner"><ul class="page-nav">
</ul><div class="footer" role="contentinfo">
      &#169; 版权所有 2023, yaoyue123.
    <br>
    Created using <a href="http://sphinx-doc.org/">Sphinx</a> 6.1.3 with <a href="https://github.com/schettino72/sphinx_press_theme">Press Theme</a> 0.8.0.
</div>
            </div>
          </div>
      </page>
    </div></div>
    
    
  </body>
</html>