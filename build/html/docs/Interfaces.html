<!DOCTYPE html>
<html  lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

      <title>Interfaces</title>
    
          <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
          <link rel="stylesheet" href="../_static/theme.css " type="text/css" />
      
      <!-- sphinx script_files -->
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script src="../_static/translations.js"></script>

      
      <!-- bundled in js (rollup iife) -->
      <!-- <script src="../_static/theme-vendors.js"></script> -->
      <script src="../_static/theme.js" defer></script>
    
  <link rel="index" title="索引" href="../genindex.html" />
  <link rel="search" title="搜索" href="../search.html" /> 
  </head>

  <body>
    <div id="app">
    <div class="theme-container" :class="pageClasses"><navbar @toggle-sidebar="toggleSidebar">
  <router-link to="../index.html" class="home-link">
    
      <span class="site-name">MLIR 中文文档</span>
    
  </router-link>

  <div class="links">
    <navlinks class="can-hide">



    </navlinks>
  </div>
</navbar>

      
      <div class="sidebar-mask" @click="toggleSidebar(false)">
      </div>
        <sidebar @toggle-sidebar="toggleSidebar">
          
          <navlinks>
            



            
          </navlinks><div id="searchbox" class="searchbox" role="search">
  <div class="caption"><span class="caption-text">快速搜索</span>
    <div class="searchformwrapper">
      <form class="search" action="../search.html" method="get">
        <input type="text" name="q" />
        <input type="submit" value="搜索" />
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div><div class="sidebar-links" role="navigation" aria-label="main navigation">
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../index.html#mlir">欢迎使用 mlir 中文文档</a></span>
      </p>
      <ul class="">
        
          <li class="toctree-l1 ">
            
              <a href="../_index.html" class="reference internal ">开始使用</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/CreatingADialect.html" class="reference internal ">Creating a Dialect</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/DataFlowAnalysis.html" class="reference internal ">Writing DataFlow Analyses in MLIR</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/QuickstartRewrites.html" class="reference internal ">Quickstart tutorial to adding MLIR graph rewrite</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-1.html" class="reference internal ">Chapter 1: Toy Language and AST</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-2.html" class="reference internal ">Chapter 2: Emitting Basic MLIR</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-3.html" class="reference internal ">Chapter 3: High-level Language-Specific Analysis and Transformation</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-4.html" class="reference internal ">Chapter 4: Enabling Generic Transformation with Interfaces</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-5.html" class="reference internal ">Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-6.html" class="reference internal ">Chapter 6: Lowering to LLVM and CodeGeneration</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-7.html" class="reference internal ">Chapter 7: Adding a Composite Type to Toy</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/_index.html" class="reference internal ">Toy Tutorial</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/UnderstandingTheIRStructure.html" class="reference internal ">Understanding the IR Structure</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/_index.html" class="reference internal ">Tutorials</a>
            

            
          </li>

        
      </ul>
    </div>
  
</div>
        </sidebar>

      <page>
          <div class="body-header" role="navigation" aria-label="navigation">
  
  <ul class="breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
    
    <li>Interfaces</li>
  </ul>
  

  <ul class="page-nav">
</ul>
  
</div>
<hr>
          <div class="content" role="main" v-pre>
            
  <section id="interfaces">
<h1>Interfaces<a class="headerlink" href="#interfaces" title="此标题的永久链接">¶</a></h1>
<p>MLIR is a generic and extensible framework, representing different dialects with
their own attributes, operations, types, and so on. MLIR Dialects can express
operations with a wide variety of semantics and different levels of abstraction.
The downside to this is that MLIR transformations and analyses need to be able
to account for the semantics of every operation, or be overly conservative.
Without care, this can result in code with special-cases for each supported
operation type. To combat this, MLIR provides a concept of <code class="docutils literal notranslate"><span class="pre">interfaces</span></code>.</p>
<p>[TOC]</p>
<section id="motivation">
<h2>Motivation<a class="headerlink" href="#motivation" title="此标题的永久链接">¶</a></h2>
<p>Interfaces provide a generic way of interacting with the IR. The goal is to be
able to express transformations/analyses in terms of these interfaces without
encoding specific knowledge about the exact operation or dialect involved. This
makes the compiler more easily extensible by allowing the addition of new
dialects and operations in a decoupled way with respect to the implementation of
transformations/analyses.</p>
<section id="dialect-interfaces">
<h3>Dialect Interfaces<a class="headerlink" href="#dialect-interfaces" title="此标题的永久链接">¶</a></h3>
<p>Dialect interfaces are generally useful for transformation passes or analyses
that want to operate generically on a set of attributes/operations/types, which
may be defined in different dialects. These interfaces generally involve wide
coverage over an entire dialect and are only used for a handful of analyses or
transformations. In these cases, registering the interface directly on each
operation is overly complex and cumbersome. The interface is not core to the
operation, just to the specific transformation. An example of where this type of
interface would be used is inlining. Inlining generally queries high-level
information about the operations within a dialect, like cost modeling and
legality, that often is not specific to one operation.</p>
<p>A dialect interface can be defined by inheriting from the
<a class="reference external" href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">CRTP</a> base
class <code class="docutils literal notranslate"><span class="pre">DialectInterfaceBase::Base&lt;&gt;</span></code>. This class provides the necessary
utilities for registering an interface with a dialect so that it can be
referenced later. Once the interface has been defined, dialects can override it
using dialect-specific information. The interfaces defined by a dialect are
registered via <code class="docutils literal notranslate"><span class="pre">addInterfaces&lt;&gt;</span></code>, a similar mechanism to Attributes, Operations,
Types, etc.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// Define a base inlining interface class to allow for dialects to opt-in to</span>
<span class="c1">/// the inliner.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">DialectInlinerInterface</span><span class="w"> </span><span class="o">:</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="n">DialectInterface</span><span class="o">::</span><span class="n">Base</span><span class="o">&lt;</span><span class="n">DialectInlinerInterface</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="c1">/// Returns true if the given region &#39;src&#39; can be inlined into the region</span>
<span class="w">  </span><span class="c1">/// &#39;dest&#39; that is attached to an operation registered to the current dialect.</span>
<span class="w">  </span><span class="c1">/// &#39;valueMapping&#39; contains any remapped values from within the &#39;src&#39; region.</span>
<span class="w">  </span><span class="c1">/// This can be used to examine what values will replace entry arguments into</span>
<span class="w">  </span><span class="c1">/// the &#39;src&#39; region, for example.</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">isLegalToInline</span><span class="p">(</span><span class="n">Region</span><span class="w"> </span><span class="o">*</span><span class="n">dest</span><span class="p">,</span><span class="w"> </span><span class="n">Region</span><span class="w"> </span><span class="o">*</span><span class="n">src</span><span class="p">,</span>
<span class="w">                               </span><span class="n">IRMapping</span><span class="w"> </span><span class="o">&amp;</span><span class="n">valueMapping</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">/// Override the inliner interface to add support for the AffineDialect to</span>
<span class="c1">/// enable inlining affine operations.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">AffineInlinerInterface</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">DialectInlinerInterface</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">/// Affine structures have specific inlining constraints.</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">isLegalToInline</span><span class="p">(</span><span class="n">Region</span><span class="w"> </span><span class="o">*</span><span class="n">dest</span><span class="p">,</span><span class="w"> </span><span class="n">Region</span><span class="w"> </span><span class="o">*</span><span class="n">src</span><span class="p">,</span>
<span class="w">                       </span><span class="n">IRMapping</span><span class="w"> </span><span class="o">&amp;</span><span class="n">valueMapping</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">final</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">/// Register the interface with the dialect.</span>
<span class="n">AffineDialect</span><span class="o">::</span><span class="n">AffineDialect</span><span class="p">(</span><span class="n">MLIRContext</span><span class="w"> </span><span class="o">*</span><span class="n">context</span><span class="p">)</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">addInterfaces</span><span class="o">&lt;</span><span class="n">AffineInlinerInterface</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Once registered, these interfaces can be queried from the dialect by an analysis
or transformation without the need to determine the specific dialect subclass:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Dialect</span><span class="w"> </span><span class="o">*</span><span class="n">dialect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">DialectInlinerInterface</span><span class="w"> </span><span class="o">*</span><span class="n">interface</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">DialectInlinerInterface</span><span class="o">&gt;</span><span class="p">(</span><span class="n">dialect</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// The dialect has provided an implementation of this interface.</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<section id="dialectinterfacecollection">
<h4>DialectInterfaceCollection<a class="headerlink" href="#dialectinterfacecollection" title="此标题的永久链接">¶</a></h4>
<p>An additional utility is provided via <code class="docutils literal notranslate"><span class="pre">DialectInterfaceCollection</span></code>. This class
allows collecting all of the dialects that have registered a given interface
within an instance of the <code class="docutils literal notranslate"><span class="pre">MLIRContext</span></code>. This can be useful to hide and optimize
the lookup of a registered dialect interface.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">InlinerInterface</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span>
<span class="w">    </span><span class="n">DialectInterfaceCollection</span><span class="o">&lt;</span><span class="n">DialectInlinerInterface</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">/// The hooks for this class mirror the hooks for the DialectInlinerInterface,</span>
<span class="w">  </span><span class="c1">/// with default implementations that call the hook on the interface for a</span>
<span class="w">  </span><span class="c1">/// given dialect.</span>
<span class="w">  </span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">isLegalToInline</span><span class="p">(</span><span class="n">Region</span><span class="w"> </span><span class="o">*</span><span class="n">dest</span><span class="p">,</span><span class="w"> </span><span class="n">Region</span><span class="w"> </span><span class="o">*</span><span class="n">src</span><span class="p">,</span>
<span class="w">                               </span><span class="n">IRMapping</span><span class="w"> </span><span class="o">&amp;</span><span class="n">valueMapping</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="o">*</span><span class="n">handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getInterfaceFor</span><span class="p">(</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">getContainingOp</span><span class="p">());</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">handler</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">handler</span><span class="o">-&gt;</span><span class="n">isLegalToInline</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span><span class="w"> </span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="n">valueMapping</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>

<span class="n">MLIRContext</span><span class="w"> </span><span class="o">*</span><span class="n">ctx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="n">InlinerInterface</span><span class="w"> </span><span class="nf">interface</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">interface</span><span class="p">.</span><span class="n">isLegalToInline</span><span class="p">(...))</span>
<span class="w">   </span><span class="p">...</span>
</pre></div>
</div>
</section>
</section>
<section id="attribute-operation-type-interfaces">
<h3>Attribute/Operation/Type Interfaces<a class="headerlink" href="#attribute-operation-type-interfaces" title="此标题的永久链接">¶</a></h3>
<p>Attribute/Operation/Type interfaces, as the names suggest, are those registered
at the level of a specific attribute/operation/type. These interfaces provide
access to derived objects by providing a virtual interface that must be
implemented. As an example, many analyses and transformations want to reason
about the side effects of an operation to improve performance and correctness.
The side effects of an operation are generally tied to the semantics of a
specific operation, for example an <code class="docutils literal notranslate"><span class="pre">affine.load</span></code> operation has a <code class="docutils literal notranslate"><span class="pre">read</span></code> effect
(as the name may suggest).</p>
<p>These interfaces are defined by overriding the
<a class="reference external" href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">CRTP</a> class
for the specific IR entity; <code class="docutils literal notranslate"><span class="pre">AttrInterface</span></code>, <code class="docutils literal notranslate"><span class="pre">OpInterface</span></code>, or <code class="docutils literal notranslate"><span class="pre">TypeInterface</span></code>
respectively. These classes take, as a template parameter, a <code class="docutils literal notranslate"><span class="pre">Traits</span></code> class that
defines a <code class="docutils literal notranslate"><span class="pre">Concept</span></code> and a <code class="docutils literal notranslate"><span class="pre">Model</span></code> class. These classes provide an implementation
of concept-based polymorphism, where the <code class="docutils literal notranslate"><span class="pre">Concept</span></code> defines a set of virtual
methods that are overridden by the <code class="docutils literal notranslate"><span class="pre">Model</span></code> that is templated on the concrete
entity type. It is important to note that these classes should be pure, and
should not contain non-static data members or other mutable data. To attach an
interface to an object, the base interface classes provide a
<a class="reference internal" href="Traits.html"><span class="doc">Trait</span></a> class that can be appended to the trait list of that
object.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">ExampleOpInterfaceTraits</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">/// Define a base concept class that specifies the virtual interface to be</span>
<span class="w">  </span><span class="c1">/// implemented.</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">Concept</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">Concept</span><span class="p">();</span>

<span class="w">    </span><span class="c1">/// This is an example of a non-static hook to an operation.</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="nf">exampleInterfaceHook</span><span class="p">(</span><span class="n">Operation</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="c1">/// This is an example of a static hook to an operation. A static hook does</span>
<span class="w">    </span><span class="c1">/// not require a concrete instance of the operation. The implementation is</span>
<span class="w">    </span><span class="c1">/// a virtual hook, the same as the non-static case, because the</span>
<span class="w">    </span><span class="c1">/// implementation of the hook itself still requires indirection.</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="nf">exampleStaticInterfaceHook</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="p">};</span>

<span class="w">  </span><span class="c1">/// Define a model class that specializes a concept on a given operation type.</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ConcreteOp</span><span class="o">&gt;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">Model</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Concept</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">/// Override the method to dispatch on the concrete operation.</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="nf">exampleInterfaceHook</span><span class="p">(</span><span class="n">Operation</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">final</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">ConcreteOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">op</span><span class="p">).</span><span class="n">exampleInterfaceHook</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">/// Override the static method to dispatch to the concrete operation type.</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="nf">exampleStaticInterfaceHook</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">final</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">ConcreteOp</span><span class="o">::</span><span class="n">exampleStaticInterfaceHook</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">};</span>
<span class="p">};</span>

<span class="c1">/// Define the main interface class that analyses and transformations will</span>
<span class="c1">/// interface with.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ExampleOpInterface</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">OpInterface</span><span class="o">&lt;</span><span class="n">ExampleOpInterface</span><span class="p">,</span>
<span class="w">                                              </span><span class="n">ExampleOpInterfaceTraits</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="c1">/// Inherit the base class constructor to support LLVM-style casting.</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">OpInterface</span><span class="o">&lt;</span><span class="n">ExampleOpInterface</span><span class="p">,</span><span class="w"> </span><span class="n">ExampleOpInterfaceTraits</span><span class="o">&gt;::</span><span class="n">OpInterface</span><span class="p">;</span>

<span class="w">  </span><span class="c1">/// The interface dispatches to &#39;getImpl()&#39;, a method provided by the base</span>
<span class="w">  </span><span class="c1">/// `OpInterface` class that returns an instance of the concept.</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="nf">exampleInterfaceHook</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">getImpl</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">exampleInterfaceHook</span><span class="p">(</span><span class="n">getOperation</span><span class="p">());</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="nf">exampleStaticInterfaceHook</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">getImpl</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">exampleStaticInterfaceHook</span><span class="p">(</span><span class="n">getOperation</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">());</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Once the interface has been defined, it is registered to an operation by adding
the provided trait <code class="docutils literal notranslate"><span class="pre">ExampleOpInterface::Trait</span></code> as described earlier. Using this
interface is just like using any other derived operation type, i.e. casting:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// When defining the operation, the interface is registered via the nested</span>
<span class="c1">/// &#39;Trait&#39; class provided by the &#39;OpInterface&lt;&gt;&#39; base class.</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MyOp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Op</span><span class="o">&lt;</span><span class="n">MyOp</span><span class="p">,</span><span class="w"> </span><span class="n">ExampleOpInterface</span><span class="o">::</span><span class="n">Trait</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">  </span><span class="c1">/// The definition of the interface method on the derived operation.</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">exampleInterfaceHook</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">...;</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">exampleStaticInterfaceHook</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="p">...;</span><span class="w"> </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">/// Later, we can query if a specific operation(like &#39;MyOp&#39;) overrides the given</span>
<span class="c1">/// interface.</span>
<span class="n">Operation</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ExampleOpInterface</span><span class="w"> </span><span class="n">example</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">ExampleOpInterface</span><span class="o">&gt;</span><span class="p">(</span><span class="n">op</span><span class="p">))</span>
<span class="w">  </span><span class="n">llvm</span><span class="o">::</span><span class="n">errs</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;hook returned = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">example</span><span class="p">.</span><span class="n">exampleInterfaceHook</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</pre></div>
</div>
<section id="external-models-for-attribute-operation-and-type-interfaces">
<h4>External Models for Attribute, Operation and Type Interfaces<a class="headerlink" href="#external-models-for-attribute-operation-and-type-interfaces" title="此标题的永久链接">¶</a></h4>
<p>It may be desirable to provide an interface implementation for an IR object
without modifying the definition of said object. Notably, this allows to
implement interfaces for attributes, operations and types outside of the dialect
that defines them, for example, to provide interfaces for built-in types.</p>
<p>This is achieved by extending the concept-based polymorphism model with two more
classes derived from <code class="docutils literal notranslate"><span class="pre">Concept</span></code> as follows.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">ExampleTypeInterfaceTraits</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">Concept</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="nf">exampleInterfaceHook</span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="nf">exampleStaticInterfaceHook</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="p">};</span>

<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ConcreteType</span><span class="o">&gt;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">Model</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Concept</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/*...*/</span><span class="w"> </span><span class="p">};</span>

<span class="w">  </span><span class="c1">/// Unlike `Model`, `FallbackModel` passes the type object through to the</span>
<span class="w">  </span><span class="c1">/// hook, making it accessible in the method body even if the method is not</span>
<span class="w">  </span><span class="c1">/// defined in the class itself and thus has no `this` access. ODS</span>
<span class="w">  </span><span class="c1">/// automatically generates this class for all interfaces.</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ConcreteType</span><span class="o">&gt;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">FallbackModel</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Concept</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="nf">exampleInterfaceHook</span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">getImpl</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">exampleInterfaceHook</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="nf">exampleStaticInterfaceHook</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">ConcreteType</span><span class="o">::</span><span class="n">exampleStaticInterfaceHook</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">};</span>

<span class="w">  </span><span class="c1">/// `ExternalModel` provides a place for default implementations of interface</span>
<span class="w">  </span><span class="c1">/// methods by explicitly separating the model class, which implements the</span>
<span class="w">  </span><span class="c1">/// interface, from the type class, for which the interface is being</span>
<span class="w">  </span><span class="c1">/// implemented. Default implementations can be then defined generically</span>
<span class="w">  </span><span class="c1">/// making use of `cast&lt;ConcreteType&gt;`. If `ConcreteType` does not provide</span>
<span class="w">  </span><span class="c1">/// the APIs required by the default implementation, custom implementations</span>
<span class="w">  </span><span class="c1">/// may use `FallbackModel` directly to override the default implementation.</span>
<span class="w">  </span><span class="c1">/// Being located in a class template, it never gets instantiated and does not</span>
<span class="w">  </span><span class="c1">/// lead to compilation errors. ODS automatically generates this class and</span>
<span class="w">  </span><span class="c1">/// places default method implementations in it.</span>
<span class="w">  </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">ConcreteModel</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">ConcreteType</span><span class="o">&gt;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">ExternalModel</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">FallbackModel</span><span class="o">&lt;</span><span class="n">ConcreteModel</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="nf">exampleInterfaceHook</span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// Default implementation can be provided here.</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">type</span><span class="p">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">ConcreteType</span><span class="o">&gt;</span><span class="p">().</span><span class="n">callSomeTypeSpecificMethod</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">};</span>
<span class="p">};</span>
</pre></div>
</div>
<p>External models can be provided for attribute, operation and type interfaces by
deriving either <code class="docutils literal notranslate"><span class="pre">FallbackModel</span></code> or <code class="docutils literal notranslate"><span class="pre">ExternalModel</span></code> and by registering the model
class with the relevant class in a given context. Other contexts will not see
the interface unless registered.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// External interface implementation for a concrete class. This does not</span>
<span class="c1">/// require modifying the definition of the type class itself.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">ExternalModelExample</span>
<span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">ExampleTypeInterface</span><span class="o">::</span><span class="n">ExternalModel</span><span class="o">&lt;</span><span class="n">ExternalModelExample</span><span class="p">,</span>
<span class="w">                                                 </span><span class="n">IntegerType</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="nf">exampleStaticInterfaceHook</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Implementation is provided here.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">IntegerType</span><span class="o">::</span><span class="n">someStaticMethod</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// No need to define `exampleInterfaceHook` that has a default implementation</span>
<span class="w">  </span><span class="c1">// in `ExternalModel`. But it can be overridden if desired.</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">MLIRContext</span><span class="w"> </span><span class="n">context</span><span class="p">;</span>
<span class="w">  </span><span class="cm">/* ... */</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Attach the interface model to the type in the given context before</span>
<span class="w">  </span><span class="c1">// using it. The dialect containing the type is expected to have been loaded</span>
<span class="w">  </span><span class="c1">// at this point.</span>
<span class="w">  </span><span class="n">IntegerType</span><span class="o">::</span><span class="n">attachInterface</span><span class="o">&lt;</span><span class="n">ExternalModelExample</span><span class="o">&gt;</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note: It is strongly encouraged to only use this mechanism if you “own” the
interface being externally applied. This prevents a situation where neither the
owner of the dialect containing the object nor the owner of the interface are
aware of an interface implementation, which can lead to duplicate or
diverging implementations.</p>
</section>
<section id="dialect-fallback-for-opinterface">
<h4>Dialect Fallback for OpInterface<a class="headerlink" href="#dialect-fallback-for-opinterface" title="此标题的永久链接">¶</a></h4>
<p>Some dialects have an open ecosystem and don’t register all of the possible
operations. In such cases it is still possible to provide support for
implementing an <code class="docutils literal notranslate"><span class="pre">OpInterface</span></code> for these operation. When an operation isn’t
registered or does not provide an implementation for an interface, the query
will fallback to the dialect itself.</p>
<p>A second model is used for such cases and automatically generated when using ODS
(see below) with the name <code class="docutils literal notranslate"><span class="pre">FallbackModel</span></code>. This model can be implemented for a
particular dialect:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// This is the implementation of a dialect fallback for `ExampleOpInterface`.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">FallbackExampleOpInterface</span>
<span class="w">    </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">ExampleOpInterface</span><span class="o">::</span><span class="n">FallbackModel</span><span class="o">&lt;</span>
<span class="w">          </span><span class="n">FallbackExampleOpInterface</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">classof</span><span class="p">(</span><span class="n">Operation</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="nf">exampleInterfaceHook</span><span class="p">(</span><span class="n">Operation</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="nf">exampleStaticInterfaceHook</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>A dialect can then instantiate this implementation and returns it on specific
operations by overriding the <code class="docutils literal notranslate"><span class="pre">getRegisteredInterfaceForOp</span></code> method :</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">TestDialect::getRegisteredInterfaceForOp</span><span class="p">(</span><span class="n">TypeID</span><span class="w"> </span><span class="n">typeID</span><span class="p">,</span>
<span class="w">                                               </span><span class="n">StringAttr</span><span class="w"> </span><span class="n">opName</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">typeID</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">TypeID</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">ExampleOpInterface</span><span class="o">&gt;</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isSupported</span><span class="p">(</span><span class="n">opName</span><span class="p">))</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">fallbackExampleOpInterface</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="utilizing-the-ods-framework">
<h4>Utilizing the ODS Framework<a class="headerlink" href="#utilizing-the-ods-framework" title="此标题的永久链接">¶</a></h4>
<p>Note: Before reading this section, the reader should have some familiarity with
the concepts described in the
<a class="reference internal" href="DefiningDialects/Operations.html"><span class="doc">Operation Definition Specification</span></a> documentation.</p>
<p>As detailed above, <a class="reference external" href="#attributeoperationtype-interfaces">Interfaces</a> allow for
attributes, operations, and types to expose method calls without requiring that
the caller know the specific derived type. The downside to this infrastructure,
is that it requires a bit of boiler plate to connect all of the pieces together.
MLIR provides a mechanism with which to defines interfaces declaratively in ODS,
and have the C++ definitions auto-generated.</p>
<p>As an example, using the ODS framework would allow for defining the example
interface above as:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def ExampleOpInterface : OpInterface&lt;&quot;ExampleOpInterface&quot;&gt; {
  let description = [{
    This is an example interface definition.
  }];

  let methods = [
    InterfaceMethod&lt;
      &quot;This is an example of a non-static hook to an operation.&quot;,
      &quot;unsigned&quot;, &quot;exampleInterfaceHook&quot;
    &gt;,
    StaticInterfaceMethod&lt;
      &quot;This is an example of a static hook to an operation.&quot;,
      &quot;unsigned&quot;, &quot;exampleStaticInterfaceHook&quot;
    &gt;,
  ];
}
</pre></div>
</div>
<p>Providing a definition of the <code class="docutils literal notranslate"><span class="pre">AttrInterface</span></code>, <code class="docutils literal notranslate"><span class="pre">OpInterface</span></code>, or <code class="docutils literal notranslate"><span class="pre">TypeInterface</span></code>
class will auto-generate the C++ classes for the interface. Interfaces are
comprised of the following components:</p>
<ul class="simple">
<li><p>C++ Class Name (Provided via template parameter)</p>
<ul>
<li><p>The name of the C++ interface class.</p></li>
</ul>
</li>
<li><p>Interface Base Classes</p>
<ul>
<li><p>A set of interfaces that the interface class should derived from. See
<a class="reference external" href="#interface-inheritance">Interface Inheritance</a> below for more details.</p></li>
</ul>
</li>
<li><p>Description (<code class="docutils literal notranslate"><span class="pre">description</span></code>)</p>
<ul>
<li><p>A string description of the interface, its invariants, example usages,
etc.</p></li>
</ul>
</li>
<li><p>C++ Namespace (<code class="docutils literal notranslate"><span class="pre">cppNamespace</span></code>)</p>
<ul>
<li><p>The C++ namespace that the interface class should be generated in.</p></li>
</ul>
</li>
<li><p>Methods (<code class="docutils literal notranslate"><span class="pre">methods</span></code>)</p>
<ul>
<li><p>The list of interface hook methods that are defined by the IR object.</p></li>
<li><p>The structure of these methods is defined below.</p></li>
</ul>
</li>
<li><p>Extra Class Declarations (Optional: <code class="docutils literal notranslate"><span class="pre">extraClassDeclaration</span></code>)</p>
<ul>
<li><p>Additional C++ code that is generated in the declaration of the
interface class. This allows for defining methods and more on the user
facing interface class, that do not need to hook into the IR entity.
These declarations are <em>not</em> implicitly visible in default
implementations of interface methods, but static declarations may be
accessed with full name qualification.</p></li>
</ul>
</li>
<li><p>Extra Shared Class Declarations (Optional: <code class="docutils literal notranslate"><span class="pre">extraSharedClassDeclaration</span></code>)</p>
<ul>
<li><p>Additional C++ code that is injected into the declarations of both the
interface and the trait class. This allows for defining methods and more
that are exposed on both the interface and the trait class, e.g. to inject
utilities on both the interface and the derived entity implementing the
interface (e.g. attribute, operation, etc.).</p></li>
<li><p>In non-static methods, <code class="docutils literal notranslate"><span class="pre">$_attr</span></code>/<code class="docutils literal notranslate"><span class="pre">$_op</span></code>/<code class="docutils literal notranslate"><span class="pre">$_type</span></code>
(depending on the type of interface) may be used to refer to an
instance of the IR entity. In the interface declaration, the type of
the instance is the interface class. In the trait declaration, the
type of the instance is the concrete entity class
(e.g. <code class="docutils literal notranslate"><span class="pre">IntegerAttr</span></code>, <code class="docutils literal notranslate"><span class="pre">FuncOp</span></code>, etc.).</p></li>
</ul>
</li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">OpInterface</span></code> classes may additionally contain the following:</p>
<ul class="simple">
<li><p>Verifier (<code class="docutils literal notranslate"><span class="pre">verify</span></code>)</p>
<ul>
<li><p>A C++ code block containing additional verification applied to the
operation that the interface is attached to.</p></li>
<li><p>The structure of this code block corresponds 1-1 with the structure of a
<a class="reference internal" href="Traits.html"><span class="doc">Trait::verifyTrait</span></a> method.</p></li>
</ul>
</li>
</ul>
<section id="interface-methods">
<h5>Interface Methods<a class="headerlink" href="#interface-methods" title="此标题的永久链接">¶</a></h5>
<p>There are two types of methods that can be used with an interface,
<code class="docutils literal notranslate"><span class="pre">InterfaceMethod</span></code> and <code class="docutils literal notranslate"><span class="pre">StaticInterfaceMethod</span></code>. They are both comprised of the
same core components, with the distinction that <code class="docutils literal notranslate"><span class="pre">StaticInterfaceMethod</span></code> models a
static method on the derived IR object.</p>
<p>Interface methods are comprised of the following components:</p>
<ul class="simple">
<li><p>Description</p>
<ul>
<li><p>A string description of this method, its invariants, example usages,
etc.</p></li>
</ul>
</li>
<li><p>ReturnType</p>
<ul>
<li><p>A string corresponding to the C++ return type of the method.</p></li>
</ul>
</li>
<li><p>MethodName</p>
<ul>
<li><p>A string corresponding to the C++ name of the method.</p></li>
</ul>
</li>
<li><p>Arguments (Optional)</p>
<ul>
<li><p>A dag of strings that correspond to a C++ type and variable name
respectively.</p></li>
</ul>
</li>
<li><p>MethodBody (Optional)</p>
<ul>
<li><p>An optional explicit implementation of the interface method.</p></li>
<li><p>This implementation is placed within the method defined on the <code class="docutils literal notranslate"><span class="pre">Model</span></code>
traits class, and is not defined by the <code class="docutils literal notranslate"><span class="pre">Trait</span></code> class that is attached
to the IR entity. More concretely, this body is only visible by the
interface class and does not affect the derived IR entity.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ConcreteAttr</span></code>/<code class="docutils literal notranslate"><span class="pre">ConcreteOp</span></code>/<code class="docutils literal notranslate"><span class="pre">ConcreteType</span></code> is an implicitly defined
<code class="docutils literal notranslate"><span class="pre">typename</span></code> that can be used to refer to the type of the derived IR
entity currently being operated on.</p></li>
<li><p>In non-static methods, <code class="docutils literal notranslate"><span class="pre">$_op</span></code> and <code class="docutils literal notranslate"><span class="pre">$_self</span></code> may be used to refer to an
instance of the derived IR entity.</p></li>
</ul>
</li>
<li><p>DefaultImplementation (Optional)</p>
<ul>
<li><p>An optional explicit default implementation of the interface method.</p></li>
<li><p>This implementation is placed within the <code class="docutils literal notranslate"><span class="pre">Trait</span></code> class that is attached
to the IR entity, and does not directly affect any of the interface
classes. As such, this method has the same characteristics as any other
<a class="reference internal" href="Traits.html"><span class="doc">Trait</span></a> method.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ConcreteAttr</span></code>/<code class="docutils literal notranslate"><span class="pre">ConcreteOp</span></code>/<code class="docutils literal notranslate"><span class="pre">ConcreteType</span></code> is an implicitly defined
<code class="docutils literal notranslate"><span class="pre">typename</span></code> that can be used to refer to the type of the derived IR
entity currently being operated on.</p></li>
<li><p>This may refer to static fields of the interface class using the
qualified name, e.g., <code class="docutils literal notranslate"><span class="pre">TestOpInterface::staticMethod()</span></code>.</p></li>
</ul>
</li>
</ul>
<p>ODS also allows for generating declarations for the <code class="docutils literal notranslate"><span class="pre">InterfaceMethod</span></code>s of an
operation if the operation specifies the interface with
<code class="docutils literal notranslate"><span class="pre">DeclareOpInterfaceMethods</span></code> (see an example below).</p>
<p>Examples:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def MyInterface : OpInterface&lt;&quot;MyInterface&quot;&gt; {
  let description = [{
    This is the description of the interface. It provides concrete information
    on the semantics of the interface, and how it may be used by the compiler.
  }];

  let methods = [
    InterfaceMethod&lt;[{
      This method represents a simple non-static interface method with no
      inputs, and a void return type. This method is required to be implemented
      by all operations implementing this interface. This method roughly
      correlates to the following on an operation implementing this interface:

      ```c++
      class ConcreteOp ... {
      public:
        void nonStaticMethod();
      };
      ```
    }], &quot;void&quot;, &quot;nonStaticMethod&quot;
    &gt;,

    InterfaceMethod&lt;[{
      This method represents a non-static interface method with a non-void
      return value, as well as an `unsigned` input named `i`. This method is
      required to be implemented by all operations implementing this interface.
      This method roughly correlates to the following on an operation
      implementing this interface:

      ```c++
      class ConcreteOp ... {
      public:
        Value nonStaticMethod(unsigned i);
      };
      ```
    }], &quot;Value&quot;, &quot;nonStaticMethodWithParams&quot;, (ins &quot;unsigned&quot;:$i)
    &gt;,

    StaticInterfaceMethod&lt;[{
      This method represents a static interface method with no inputs, and a
      void return type. This method is required to be implemented by all
      operations implementing this interface. This method roughly correlates
      to the following on an operation implementing this interface:

      ```c++
      class ConcreteOp ... {
      public:
        static void staticMethod();
      };
      ```
    }], &quot;void&quot;, &quot;staticMethod&quot;
    &gt;,

    StaticInterfaceMethod&lt;[{
      This method corresponds to a static interface method that has an explicit
      implementation of the method body. Given that the method body has been
      explicitly implemented, this method should not be defined by the operation
      implementing this method. This method merely takes advantage of properties
      already available on the operation, in this case its `build` methods. This
      method roughly correlates to the following on the interface `Model` class:

      ```c++
      struct InterfaceTraits {
        /// ... The `Concept` class is elided here ...

        template &lt;typename ConcreteOp&gt;
        struct Model : public Concept {
          Operation *create(OpBuilder &amp;builder, Location loc) const override {
            return builder.create&lt;ConcreteOp&gt;(loc);
          }
        }
      };
      ```

      Note above how no modification is required for operations implementing an
      interface with this method.
    }],
      &quot;Operation *&quot;, &quot;create&quot;, (ins &quot;OpBuilder &amp;&quot;:$builder, &quot;Location&quot;:$loc),
      /*methodBody=*/[{
        return builder.create&lt;ConcreteOp&gt;(loc);
    }]&gt;,

    InterfaceMethod&lt;[{
      This method represents a non-static method that has an explicit
      implementation of the method body. Given that the method body has been
      explicitly implemented, this method should not be defined by the operation
      implementing this method. This method merely takes advantage of properties
      already available on the operation, in this case its `build` methods. This
      method roughly correlates to the following on the interface `Model` class:

      ```c++
      struct InterfaceTraits {
        /// ... The `Concept` class is elided here ...

        template &lt;typename ConcreteOp&gt;
        struct Model : public Concept {
          Operation *create(Operation *opaqueOp, OpBuilder &amp;builder,
                            Location loc) const override {
            ConcreteOp op = cast&lt;ConcreteOp&gt;(opaqueOp);
            return op.getNumInputs() + op.getNumOutputs();
          }
        }
      };
      ```

      Note above how no modification is required for operations implementing an
      interface with this method.
    }],
      &quot;unsigned&quot;, &quot;getNumInputsAndOutputs&quot;, (ins), /*methodBody=*/[{
        return $_op.getNumInputs() + $_op.getNumOutputs();
    }]&gt;,

    InterfaceMethod&lt;[{
      This method represents a non-static method that has a default
      implementation of the method body. This means that the implementation
      defined here will be placed in the trait class that is attached to every
      operation that implements this interface. This has no effect on the
      generated `Concept` and `Model` class. This method roughly correlates to
      the following on the interface `Trait` class:

      ```c++
      template &lt;typename ConcreteOp&gt;
      class MyTrait : public OpTrait::TraitBase&lt;ConcreteType, MyTrait&gt; {
      public:
        bool isSafeToTransform() {
          ConcreteOp op = cast&lt;ConcreteOp&gt;(this-&gt;getOperation());
          return op.getNumInputs() + op.getNumOutputs();
        }
      };
      ```

      As detailed in [Traits](Traits.md), given that each operation implementing
      this interface will also add the interface trait, the methods on this
      interface are inherited by the derived operation. This allows for
      injecting a default implementation of this method into each operation that
      implements this interface, without changing the interface class itself. If
      an operation wants to override this default implementation, it merely
      needs to implement the method and the derived implementation will be
      picked up transparently by the interface class.

      ```c++
      class ConcreteOp ... {
      public:
        bool isSafeToTransform() {
          // Here we can override the default implementation of the hook
          // provided by the trait.
        }
      };
      ```
    }],
      &quot;bool&quot;, &quot;isSafeToTransform&quot;, (ins), /*methodBody=*/[{}],
      /*defaultImplementation=*/[{
    }]&gt;,
  ];
}

// Operation interfaces can optionally be wrapped inside
// `DeclareOpInterfaceMethods`. This would result in autogenerating declarations
// for members `foo`, `bar` and `fooStatic`. Methods with bodies are not
// declared inside the op declaration but instead handled by the op interface
// trait directly.
def OpWithInferTypeInterfaceOp : Op&lt;...
    [DeclareOpInterfaceMethods&lt;MyInterface&gt;]&gt; { ... }

// Methods that have a default implementation do not have declarations
// generated. If an operation wishes to override the default behavior, it can
// explicitly specify the method that it wishes to override. This will force
// the generation of a declaration for those methods.
def OpWithOverrideInferTypeInterfaceOp : Op&lt;...
    [DeclareOpInterfaceMethods&lt;MyInterface, [&quot;getNumWithDefault&quot;]&gt;]&gt; { ... }
</pre></div>
</div>
</section>
<section id="interface-inheritance">
<h5>Interface Inheritance<a class="headerlink" href="#interface-inheritance" title="此标题的永久链接">¶</a></h5>
<p>Interfaces also support a limited form of inheritance, which allows for
building upon pre-existing interfaces in a way similar to that of classes in
programming languages like C++. This more easily allows for building modular
interfaces, without suffering from the pain of lots of explicit casting. To
enable inheritance, an interface simply needs to provide the desired set of
base classes in its definition. For example:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def MyBaseInterface : OpInterface&lt;&quot;MyBaseInterface&quot;&gt; {
  ...
}

def MyInterface : OpInterface&lt;&quot;MyInterface&quot;, [MyBaseInterface]&gt; {
  ...
}
</pre></div>
</div>
<p>This will result in <code class="docutils literal notranslate"><span class="pre">MyInterface</span></code> inheriting various components from
<code class="docutils literal notranslate"><span class="pre">MyBaseInterface</span></code>, namely its interface methods and extra class declarations.
Given that these inherited components are comprised of opaque C++ blobs, we
cannot properly sandbox the names. As such, it’s important to ensure that inherited
components do not create name overlaps, as these will result in errors during
interface generation.</p>
<p><code class="docutils literal notranslate"><span class="pre">MyInterface</span></code> will also implicitly inherit any base classes defined on
<code class="docutils literal notranslate"><span class="pre">MyBaseInterface</span></code> as well. It’s important to note, however, that there is only
ever one instance of each interface for a given attribute, operation, or type.
Inherited interface methods simplify forward to base interface implementation.
This produces a simpler system overall, and also removes any potential problems
surrounding “diamond inheritance”. The interfaces on an attribute/op/type can be
thought of as comprising a set, with each interface (including base interfaces)
uniqued within this set and referenced elsewhere as necessary.</p>
<p>When adding an interface with inheritance to an attribute, operation, or type,
all of the base interfaces are also implicitly added as well. The user may still
manually specify the base interfaces if they desire, such as for use with the
<code class="docutils literal notranslate"><span class="pre">Declare&lt;Attr|Op|Type&gt;InterfaceMethods</span></code> helper classes.</p>
<p>If our interface were to be specified as:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def MyBaseInterface : OpInterface&lt;&quot;MyBaseInterface&quot;&gt; {
  ...
}

def MyOtherBaseInterface : OpInterface&lt;MyOtherBaseInterface, [MyBaseInterface]&gt; {
  ...
}

def MyInterface : OpInterface&lt;&quot;MyInterface&quot;, [MyBaseInterface, MyOtherBaseInterface]&gt; {
  ...
}
</pre></div>
</div>
<p>An operation with <code class="docutils literal notranslate"><span class="pre">MyInterface</span></code> attached, would have the following interfaces added:</p>
<ul class="simple">
<li><p>MyBaseInterface, MyOtherBaseInterface, MyInterface</p></li>
</ul>
<p>The methods from <code class="docutils literal notranslate"><span class="pre">MyBaseInterface</span></code> in both <code class="docutils literal notranslate"><span class="pre">MyInterface</span></code> and <code class="docutils literal notranslate"><span class="pre">MyOtherBaseInterface</span></code> would
forward to a single unique implementation for the operation.</p>
</section>
<section id="generation">
<h5>Generation<a class="headerlink" href="#generation" title="此标题的永久链接">¶</a></h5>
<p>Once the interfaces have been defined, the C++ header and source files can be
generated using the <code class="docutils literal notranslate"><span class="pre">--gen-&lt;attr|op|type&gt;-interface-decls</span></code> and
<code class="docutils literal notranslate"><span class="pre">--gen-&lt;attr|op|type&gt;-interface-defs</span></code> options with mlir-tblgen. Note that when
generating interfaces, mlir-tblgen will only generate interfaces defined in
the top-level input <code class="docutils literal notranslate"><span class="pre">.td</span></code> file. This means that any interfaces that are
defined within include files will not be considered for generation.</p>
<p>Note: Existing operation interfaces defined in C++ can be accessed in the ODS
framework via the <code class="docutils literal notranslate"><span class="pre">OpInterfaceTrait</span></code> class.</p>
</section>
</section>
<section id="operation-interface-list">
<h4>Operation Interface List<a class="headerlink" href="#operation-interface-list" title="此标题的永久链接">¶</a></h4>
<p>MLIR includes standard interfaces providing functionality that is likely to be
common across many different operations. Below is a list of some key interfaces
that may be used directly by any dialect. The format of the header for each
interface section goes as follows:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">Interface</span> <span class="pre">class</span> <span class="pre">name</span></code></p>
<ul>
<li><p>(<code class="docutils literal notranslate"><span class="pre">C++</span> <span class="pre">class</span></code> – <code class="docutils literal notranslate"><span class="pre">ODS</span> <span class="pre">class</span></code>(if applicable))</p></li>
</ul>
</li>
</ul>
<section id="callinterfaces">
<h5>CallInterfaces<a class="headerlink" href="#callinterfaces" title="此标题的永久链接">¶</a></h5>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">CallOpInterface</span></code> - Used to represent operations like ‘call’</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">CallInterfaceCallable</span> <span class="pre">getCallableForCallee()</span></code></p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">CallableOpInterface</span></code> - Used to represent the target callee of call.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">Region</span> <span class="pre">*</span> <span class="pre">getCallableRegion()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ArrayRef&lt;Type&gt;</span> <span class="pre">getCallableResults()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ArrayAttr</span> <span class="pre">getCallableArgAttrs()</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ArrayAttr</span> <span class="pre">getCallableResAttrs()</span></code></p></li>
</ul>
</li>
</ul>
</section>
<section id="regionkindinterfaces">
<h5>RegionKindInterfaces<a class="headerlink" href="#regionkindinterfaces" title="此标题的永久链接">¶</a></h5>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">RegionKindInterface</span></code> - Used to describe the abstract semantics of regions.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">RegionKind</span> <span class="pre">getRegionKind(unsigned</span> <span class="pre">index)</span></code> - Return the kind of the
region with the given index inside this operation.</p>
<ul>
<li><p>RegionKind::Graph - represents a graph region without control flow
semantics</p></li>
<li><p>RegionKind::SSACFG - represents an
<a class="reference external" href="LangRef.md/#control-flow-and-ssacfg-regions">SSA-style control flow</a> region
with basic blocks and reachability</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">hasSSADominance(unsigned</span> <span class="pre">index)</span></code> - Return true if the region with the
given index inside this operation requires dominance.</p></li>
</ul>
</li>
</ul>
</section>
<section id="symbolinterfaces">
<h5>SymbolInterfaces<a class="headerlink" href="#symbolinterfaces" title="此标题的永久链接">¶</a></h5>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">SymbolOpInterface</span></code> - Used to represent
<a class="reference external" href="SymbolsAndSymbolTables.md/#symbol"><code class="docutils literal notranslate"><span class="pre">Symbol</span></code></a> operations which reside
immediately within a region that defines a
<a class="reference external" href="SymbolsAndSymbolTables.md/#symbol-table"><code class="docutils literal notranslate"><span class="pre">SymbolTable</span></code></a>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SymbolUserOpInterface</span></code> - Used to represent operations that reference
<a class="reference external" href="SymbolsAndSymbolTables.md/#symbol"><code class="docutils literal notranslate"><span class="pre">Symbol</span></code></a> operations. This provides the
ability to perform safe and efficient verification of symbol uses, as well
as additional functionality.</p></li>
</ul>
</section>
</section>
</section>
</section>
</section>


          </div>
          <div class="page-nav">
            <div class="inner"><ul class="page-nav">
</ul><div class="footer" role="contentinfo">
      &#169; 版权所有 2023, yaoyue123.
    <br>
    Created using <a href="http://sphinx-doc.org/">Sphinx</a> 6.1.3 with <a href="https://github.com/schettino72/sphinx_press_theme">Press Theme</a> 0.8.0.
</div>
            </div>
          </div>
      </page>
    </div></div>
    
    
  </body>
</html>