<!DOCTYPE html>
<html  lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

      <title>Table-driven Declarative Rewrite Rule (DRR)</title>
    
          <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
          <link rel="stylesheet" href="../_static/theme.css " type="text/css" />
      
      <!-- sphinx script_files -->
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script src="../_static/translations.js"></script>

      
      <!-- bundled in js (rollup iife) -->
      <!-- <script src="../_static/theme-vendors.js"></script> -->
      <script src="../_static/theme.js" defer></script>
    
  <link rel="index" title="索引" href="../genindex.html" />
  <link rel="search" title="搜索" href="../search.html" /> 
  </head>

  <body>
    <div id="app">
    <div class="theme-container" :class="pageClasses"><navbar @toggle-sidebar="toggleSidebar">
  <router-link to="../index.html" class="home-link">
    
      <span class="site-name">MLIR 中文文档</span>
    
  </router-link>

  <div class="links">
    <navlinks class="can-hide">



    </navlinks>
  </div>
</navbar>

      
      <div class="sidebar-mask" @click="toggleSidebar(false)">
      </div>
        <sidebar @toggle-sidebar="toggleSidebar">
          
          <navlinks>
            



            
          </navlinks><div id="searchbox" class="searchbox" role="search">
  <div class="caption"><span class="caption-text">快速搜索</span>
    <div class="searchformwrapper">
      <form class="search" action="../search.html" method="get">
        <input type="text" name="q" />
        <input type="submit" value="搜索" />
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div><div class="sidebar-links" role="navigation" aria-label="main navigation">
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../index.html#mlir">欢迎使用 mlir 中文文档</a></span>
      </p>
      <ul class="">
        
          <li class="toctree-l1 ">
            
              <a href="../_index.html" class="reference internal ">开始使用</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/CreatingADialect.html" class="reference internal ">Creating a Dialect</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/DataFlowAnalysis.html" class="reference internal ">Writing DataFlow Analyses in MLIR</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/QuickstartRewrites.html" class="reference internal ">Quickstart tutorial to adding MLIR graph rewrite</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-1.html" class="reference internal ">Chapter 1: Toy Language and AST</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-2.html" class="reference internal ">Chapter 2: Emitting Basic MLIR</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-3.html" class="reference internal ">Chapter 3: High-level Language-Specific Analysis and Transformation</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-4.html" class="reference internal ">Chapter 4: Enabling Generic Transformation with Interfaces</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-5.html" class="reference internal ">Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-6.html" class="reference internal ">Chapter 6: Lowering to LLVM and CodeGeneration</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-7.html" class="reference internal ">Chapter 7: Adding a Composite Type to Toy</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/_index.html" class="reference internal ">Toy Tutorial</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/UnderstandingTheIRStructure.html" class="reference internal ">Understanding the IR Structure</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/_index.html" class="reference internal ">Tutorials</a>
            

            
          </li>

        
      </ul>
    </div>
  
</div>
        </sidebar>

      <page>
          <div class="body-header" role="navigation" aria-label="navigation">
  
  <ul class="breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
    
    <li>Table-driven Declarative Rewrite Rule (DRR)</li>
  </ul>
  

  <ul class="page-nav">
</ul>
  
</div>
<hr>
          <div class="content" role="main" v-pre>
            
  <section id="table-driven-declarative-rewrite-rule-drr">
<h1>Table-driven Declarative Rewrite Rule (DRR)<a class="headerlink" href="#table-driven-declarative-rewrite-rule-drr" title="此标题的永久链接">¶</a></h1>
<p>In addition to subclassing the <code class="docutils literal notranslate"><span class="pre">mlir::RewritePattern</span></code> C++ class, MLIR also
supports defining rewrite rules in a declarative manner. Similar to
<a class="reference internal" href="DefiningDialects/Operations.html"><span class="doc">Op Definition Specification</span></a> (ODS), this is achieved via
<a class="reference external" href="https://llvm.org/docs/TableGen/index.html">TableGen</a>, which is a language to maintain records of domain-specific
information. The rewrite rules are specified concisely in a TableGen record,
which will be expanded into an equivalent <code class="docutils literal notranslate"><span class="pre">mlir::RewritePattern</span></code> subclass at
compiler build time.</p>
<p>This manual explains in detail all of the available mechanisms for defining
rewrite rules in such a declarative manner. It aims to be a specification
instead of a tutorial. Please refer to
<a class="reference internal" href="Tutorials/QuickstartRewrites.html"><span class="doc">Quickstart tutorial to adding MLIR graph rewrite</span></a>
for the latter.</p>
<p>Given that declarative rewrite rules depend on op definition specification, this
manual assumes knowledge of the <a class="reference internal" href="DefiningDialects/Operations.html"><span class="doc">ODS</span></a> doc.</p>
<p>[TOC]</p>
<section id="benefits">
<h2>Benefits<a class="headerlink" href="#benefits" title="此标题的永久链接">¶</a></h2>
<p>Compared to the hand-written C++ classes, this declarative approach has several
benefits, including but not limited to:</p>
<ul class="simple">
<li><p><strong>Being declarative</strong>: The pattern creator just needs to state the rewrite
pattern declaratively, without worrying about the concrete C++ methods to
call.</p></li>
<li><p><strong>Removing boilerplate and showing the very essence of the rewrite</strong>:
<code class="docutils literal notranslate"><span class="pre">mlir::RewritePattern</span></code> is already good at hiding boilerplate for defining a
rewrite rule. But we still need to write the class and function structures
required by the C++ programming language, inspect ops for matching, and call
op <code class="docutils literal notranslate"><span class="pre">build()</span></code> methods for constructing. These statements are typically quite
simple and similar, so they can be further condensed with auto-generation.
Because we reduce the boilerplate to the bare minimum, the declarative
rewrite rule will just contain the very essence of the rewrite. This makes
it very easy to understand the pattern.</p></li>
</ul>
</section>
<section id="strengths-and-limitations">
<h2>Strengths and Limitations<a class="headerlink" href="#strengths-and-limitations" title="此标题的永久链接">¶</a></h2>
<p>The declarative rewrite rule is <strong>operation-based</strong>: it describes a rule to
match against a directed acyclic graph (DAG) of operations and generate DAGs of
operations. This gives DRR both its strengths and limitations: it is good at
expressing op to op conversions, but not that well suited for, say, converting
an op into a loop nest.</p>
<p>Per the current implementation, DRR does not have good support for the following
features:</p>
<ul class="simple">
<li><p>Matching and generating ops with regions.</p></li>
<li><p>Matching and generating ops with block arguments.</p></li>
<li><p>Matching multi-result ops in nested patterns.</p></li>
<li><p>Matching and generating variadic operand/result ops in nested patterns.</p></li>
<li><p>Packing and unpacking variadic operands/results during generation.</p></li>
<li><p><a class="reference external" href="#nativecodecall-transforming-the-generated-op"><code class="docutils literal notranslate"><span class="pre">NativeCodeCall</span></code></a> returning
more than one results.</p></li>
</ul>
</section>
<section id="rule-definition">
<h2>Rule Definition<a class="headerlink" href="#rule-definition" title="此标题的永久链接">¶</a></h2>
<p>The core construct for defining a rewrite rule is defined in
<a class="reference external" href="https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/IR/OpBase.td"><code class="docutils literal notranslate"><span class="pre">OpBase.td</span></code></a> as</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>class Pattern&lt;
    dag sourcePattern, list&lt;dag&gt; resultPatterns,
    list&lt;dag&gt; additionalConstraints = [],
    dag benefitsAdded = (addBenefit 0)&gt;;
</pre></div>
</div>
<p>A declarative rewrite rule contains two main components:</p>
<ul class="simple">
<li><p>A <em>source pattern</em>, which is used for matching a DAG of operations.</p></li>
<li><p>One or more <em>result patterns</em>, which are used for generating DAGs of
operations to replace the matched DAG of operations.</p></li>
</ul>
<p>We allow multiple result patterns to support
<a class="reference external" href="#supporting-multi-result-ops">multi-result ops</a> and
<a class="reference external" href="#supporting-auxiliary-ops">auxiliary ops</a>, but frequently we just want to
convert one DAG of operations to another DAG of operations. There is a handy
wrapper of <code class="docutils literal notranslate"><span class="pre">Pattern</span></code>, <code class="docutils literal notranslate"><span class="pre">Pat</span></code>, which takes a single result pattern:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>class Pat&lt;
    dag sourcePattern, dag resultPattern,
    list&lt;dag&gt; additionalConstraints = [],
    dag benefitsAdded = (addBenefit 0)&gt; :
  Pattern&lt;sourcePattern, [resultPattern], additionalConstraints, benefitAdded&gt;;
</pre></div>
</div>
<p>Each pattern is specified as a TableGen <code class="docutils literal notranslate"><span class="pre">dag</span></code> object with the syntax of
<code class="docutils literal notranslate"><span class="pre">(operator</span> <span class="pre">arg0,</span> <span class="pre">arg1,</span> <span class="pre">...)</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">operator</span></code> is typically an MLIR op, but it can also be other
<a class="reference external" href="#rewrite-directives">directives</a>. <code class="docutils literal notranslate"><span class="pre">argN</span></code> is for matching (if used in source
pattern) or generating (if used in result pattern) the <code class="docutils literal notranslate"><span class="pre">N</span></code>-th argument for
<code class="docutils literal notranslate"><span class="pre">operator</span></code>. If the <code class="docutils literal notranslate"><span class="pre">operator</span></code> is some MLIR operation, it means the <code class="docutils literal notranslate"><span class="pre">N</span></code>-th
argument as specified in the <code class="docutils literal notranslate"><span class="pre">arguments</span></code> list of the op’s definition. Therefore,
we say op argument specification in pattern is <strong>position-based</strong>: the position
where they appear matters.</p>
<p><code class="docutils literal notranslate"><span class="pre">argN</span></code> can be a <code class="docutils literal notranslate"><span class="pre">dag</span></code> object itself, thus we can have nested <code class="docutils literal notranslate"><span class="pre">dag</span></code> tree to model
the def-use relationship between ops.</p>
<section id="source-pattern">
<h3>Source pattern<a class="headerlink" href="#source-pattern" title="此标题的永久链接">¶</a></h3>
<p>The source pattern is for matching a DAG of operations. Arguments in the <code class="docutils literal notranslate"><span class="pre">dag</span></code>
object are intended to <strong>capture</strong> the op arguments. They can also be used to
<strong>further limit</strong> the match criteria. The capturing is done by specifying a
symbol starting with the <code class="docutils literal notranslate"><span class="pre">$</span></code> sign, while further constraints are introduced by
specifying a <code class="docutils literal notranslate"><span class="pre">TypeConstraint</span></code> (for an operand) or a <code class="docutils literal notranslate"><span class="pre">AttrConstraint</span></code> (for an
attribute).</p>
<section id="binding-op-arguments-and-limiting-the-match">
<h4>Binding op arguments and limiting the match<a class="headerlink" href="#binding-op-arguments-and-limiting-the-match" title="此标题的永久链接">¶</a></h4>
<p>For example,</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def AOp : Op&lt;&quot;a_op&quot;&gt; {
    let arguments = (ins
      AnyType:$a_input,
      AnyAttr:$a_attr
    );

    let results = (outs
      AnyType:$a_output
    );
}

def : Pat&lt;(AOp $input, F32Attr:$attr), ...&gt;;
</pre></div>
</div>
<p>In the above, we are matching an <code class="docutils literal notranslate"><span class="pre">AOp</span></code> whose <code class="docutils literal notranslate"><span class="pre">$input</span></code> can be anything valid as
defined by the op and whose <code class="docutils literal notranslate"><span class="pre">$attr</span></code> must be a float attribute. If the match
succeeds, we bind the <code class="docutils literal notranslate"><span class="pre">$input</span></code> symbol to the op’s only input (<code class="docutils literal notranslate"><span class="pre">$a_input</span></code>) and
<code class="docutils literal notranslate"><span class="pre">$attr</span></code> to the only attribute (<code class="docutils literal notranslate"><span class="pre">$a_attr</span></code>); we can reference them using <code class="docutils literal notranslate"><span class="pre">$input</span></code>
and <code class="docutils literal notranslate"><span class="pre">$attr</span></code> in result patterns and additional constraints.</p>
<p>The pattern is position-based: the symbol names used for capturing here do not
need to match with the op definition as shown in the above example. As another
example, the pattern can be written as <code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">:</span> <span class="pre">Pat&lt;(AOp</span> <span class="pre">$a,</span> <span class="pre">F32Attr:$b),</span> <span class="pre">...&gt;;</span></code>
and use <code class="docutils literal notranslate"><span class="pre">$a</span></code> and <code class="docutils literal notranslate"><span class="pre">$b</span></code> to refer to the captured input and attribute. But using
the ODS name directly in the pattern is also allowed. Operands in the source
pattern can have the same name. This bounds one operand to the name while
verifying the rest are all equal.</p>
<p>Also note that we only need to add <code class="docutils literal notranslate"><span class="pre">TypeConstraint</span></code> or <code class="docutils literal notranslate"><span class="pre">AttributeConstraint</span></code>
when we need to further limit the match criteria. If all valid cases to the op
are acceptable, then we can leave the constraint unspecified.</p>
<p><code class="docutils literal notranslate"><span class="pre">$_</span></code> is a special symbol to mean ignore capturing an argument. For example,
<code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">:</span> <span class="pre">Pat&lt;(AOp</span> <span class="pre">$_,</span> <span class="pre">$b),</span> <span class="pre">...&gt;</span></code> means only <code class="docutils literal notranslate"><span class="pre">$b</span></code> is interesting to capture and
will be referenced later in result patterns. It’s still possible to place
additional constraints even if the symbol is not to be captured; for such case,
you can simply use just the <code class="docutils literal notranslate"><span class="pre">TypeConstraint</span></code> or <code class="docutils literal notranslate"><span class="pre">AttributeConstraint</span></code> without a
bound symbol, for example, <code class="docutils literal notranslate"><span class="pre">def</span> <span class="pre">:</span> <span class="pre">Pat&lt;(AOp</span> <span class="pre">$a,</span> <span class="pre">F32Attr),</span> <span class="pre">...&gt;</span></code>.</p>
</section>
<section id="matching-dag-of-operations">
<h4>Matching DAG of operations<a class="headerlink" href="#matching-dag-of-operations" title="此标题的永久链接">¶</a></h4>
<p>To match a DAG of ops, use nested <code class="docutils literal notranslate"><span class="pre">dag</span></code> objects:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>
def BOp : Op&lt;&quot;b_op&quot;&gt; {
    let arguments = (ins);

    let results = (outs
      AnyType:$b_output
    );
}


def : Pat&lt;(AOp (BOp), $attr), ...&gt;;
</pre></div>
</div>
<p>The above pattern matches an <code class="docutils literal notranslate"><span class="pre">AOp</span></code> whose only operand is generated by a <code class="docutils literal notranslate"><span class="pre">BOp</span></code>,
that is, the following MLIR code:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>%0 = &quot;b_op&quot;() : () -&gt; (...)
%1 = &quot;a_op&quot;(%0) {attr: ...} : () -&gt; (...)
</pre></div>
</div>
</section>
<section id="binding-op-results">
<h4>Binding op results<a class="headerlink" href="#binding-op-results" title="此标题的永久链接">¶</a></h4>
<p>To bind a symbol to the results of a matched op for later reference, attach the
symbol to the op itself:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def : Pat&lt;(AOp (BOp:$b_result), $attr), ...&gt;;
</pre></div>
</div>
<p>The above will bind <code class="docutils literal notranslate"><span class="pre">$b_result</span></code> to the matched <code class="docutils literal notranslate"><span class="pre">BOp</span></code>’s result. (There are more
details regarding multi-result ops, which is covered
<a class="reference external" href="#supporting-multi-result-ops">later</a>.)</p>
</section>
</section>
<section id="result-pattern">
<h3>Result pattern<a class="headerlink" href="#result-pattern" title="此标题的永久链接">¶</a></h3>
<p>The result pattern is for generating a DAG of operations. Arguments in the <code class="docutils literal notranslate"><span class="pre">dag</span></code>
object are intended to <strong>reference</strong> values captured in the source pattern and
potentially <strong>apply transformations</strong>.</p>
<section id="referencing-bound-symbols">
<h4>Referencing bound symbols<a class="headerlink" href="#referencing-bound-symbols" title="此标题的永久链接">¶</a></h4>
<p>For example,</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def COp : Op&lt;&quot;c_op&quot;&gt; {
    let arguments = (ins
      AnyType:$c_input,
      AnyAttr:$c_attr
    );

    let results = (outs
      AnyType:$c_output
    );
}

def : Pat&lt;(AOp $input, $attr), (COp $input, $attr)&gt;;
</pre></div>
</div>
<p>In the above, <code class="docutils literal notranslate"><span class="pre">AOp</span></code>’s only operand and attribute are bound to <code class="docutils literal notranslate"><span class="pre">$input</span></code> and
<code class="docutils literal notranslate"><span class="pre">$attr</span></code>, respectively. We then reference them in the result pattern for
generating the <code class="docutils literal notranslate"><span class="pre">COp</span></code> by passing them in as arguments to <code class="docutils literal notranslate"><span class="pre">COp</span></code>’s <code class="docutils literal notranslate"><span class="pre">build()</span></code>
method.</p>
<p>We can also reference symbols bound to matched op’s results:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def : Pat&lt;(AOp (BOp:$b_result) $attr), (COp $b_result $attr)&gt;;
</pre></div>
</div>
<p>In the above, we are using <code class="docutils literal notranslate"><span class="pre">BOp</span></code>’s result for building <code class="docutils literal notranslate"><span class="pre">COp</span></code>.</p>
</section>
<section id="building-operations">
<h4>Building operations<a class="headerlink" href="#building-operations" title="此标题的永久链接">¶</a></h4>
<p>Given that <code class="docutils literal notranslate"><span class="pre">COp</span></code> was specified with table-driven op definition, there will be
several <code class="docutils literal notranslate"><span class="pre">build()</span></code> methods generated for it. One of them has aggregated
parameters for result types, operands, and attributes in the signature: <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">COp::build(...,</span> <span class="pre">ArrayRef&lt;Type&gt;</span> <span class="pre">resultTypes,</span> <span class="pre">Array&lt;Value&gt;</span> <span class="pre">operands,</span> <span class="pre">ArrayRef&lt;NamedAttribute&gt;</span> <span class="pre">attr)</span></code>. The pattern in the above calls this <code class="docutils literal notranslate"><span class="pre">build()</span></code>
method for constructing the <code class="docutils literal notranslate"><span class="pre">COp</span></code>.</p>
<p>In general, arguments in the result pattern will be passed directly to the
<code class="docutils literal notranslate"><span class="pre">build()</span></code> method to leverage the auto-generated <code class="docutils literal notranslate"><span class="pre">build()</span></code> method, list them in
the pattern by following the exact same order as the ODS <code class="docutils literal notranslate"><span class="pre">arguments</span></code> definition.
Otherwise, a custom <code class="docutils literal notranslate"><span class="pre">build()</span></code> method that matches the argument list is required.</p>
<p>Right now all ODS-generated <code class="docutils literal notranslate"><span class="pre">build()</span></code> methods require specifying the result
type(s), unless the op has known traits like <code class="docutils literal notranslate"><span class="pre">SameOperandsAndResultType</span></code> that we
can use to auto-generate a <code class="docutils literal notranslate"><span class="pre">build()</span></code> method with result type deduction. When
generating an op to replace the result of the matched root op, we can use the
matched root op’s result type when calling the ODS-generated builder. Otherwise
(e.g., generating an <a class="reference external" href="#supporting-auxiliary-ops">auxiliary op</a> or generating an
op with a nested result pattern), DRR will not be able to deduce the result
type(s). The pattern author will need to define a custom builder that has result
type deduction ability via <code class="docutils literal notranslate"><span class="pre">OpBuilder</span></code> in ODS. For example, in the following
pattern</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def : Pat&lt;(AOp $input, $attr), (COp (AOp $input, $attr) $attr)&gt;;
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">AOp</span></code> is generated via a nested result pattern; DRR won’t be able to deduce the
result type for it. A custom builder for <code class="docutils literal notranslate"><span class="pre">AOp</span></code> should be defined and it should
deduce the result type by itself. The builder should have the separate parameter
for each operand and attribute and deduce the result type internally by itself.
For example, for the above <code class="docutils literal notranslate"><span class="pre">AOp</span></code>, a possible builder is:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">AOp::build</span><span class="p">(</span><span class="n">OpBuilder</span><span class="w"> </span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span><span class="w"> </span><span class="n">OperationState</span><span class="w"> </span><span class="o">&amp;</span><span class="n">state</span><span class="p">,</span>
<span class="w">                </span><span class="n">Value</span><span class="w"> </span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">Attribute</span><span class="w"> </span><span class="n">attr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">state</span><span class="p">.</span><span class="n">addOperands</span><span class="p">({</span><span class="n">input</span><span class="p">});</span>
<span class="w">  </span><span class="n">state</span><span class="p">.</span><span class="n">addAttribute</span><span class="p">(</span><span class="s">&quot;a_attr&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">attr</span><span class="p">);</span>
<span class="w">  </span><span class="n">Type</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span><span class="w"> </span><span class="c1">// Deduce result type here</span>
<span class="w">  </span><span class="n">state</span><span class="p">.</span><span class="n">addTypes</span><span class="p">({</span><span class="n">type</span><span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Failing to define such a builder will result in an error at C++ compilation time
saying the call to <code class="docutils literal notranslate"><span class="pre">AOp::build()</span></code> cannot be resolved because of the number of
parameters mismatch.</p>
</section>
<section id="generating-dag-of-operations">
<h4>Generating DAG of operations<a class="headerlink" href="#generating-dag-of-operations" title="此标题的永久链接">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">dag</span></code> objects can be nested to generate a DAG of operations:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def : Pat&lt;(AOp $input, $attr), (COp (BOp), $attr)&gt;;
</pre></div>
</div>
<p>In the above, we generate a <code class="docutils literal notranslate"><span class="pre">BOp</span></code>, and then use its result to generate the <code class="docutils literal notranslate"><span class="pre">COp</span></code>
to replace the matched <code class="docutils literal notranslate"><span class="pre">AOp</span></code>.</p>
</section>
<section id="id1">
<h4>Binding op results<a class="headerlink" href="#id1" title="此标题的永久链接">¶</a></h4>
<p>In the result pattern, we can bind to the result(s) of a newly built op by
attaching symbols to the op. (But we <strong>cannot</strong> bind to op arguments given that
they are referencing previously bound symbols.) This is useful for reusing newly
created results where suitable. For example,</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def DOp : Op&lt;&quot;d_op&quot;&gt; {
    let arguments = (ins
      AnyType:$d_input1,
      AnyType:$d_input2,
    );

    let results = (outs
      AnyType:$d_output
    );
}

def : Pat&lt;(AOp $input, $ignored_attr), (DOp (BOp:$b_result) $b_result)&gt;;
</pre></div>
</div>
<p>In this pattern, an <code class="docutils literal notranslate"><span class="pre">AOp</span></code> is matched and replaced with a <code class="docutils literal notranslate"><span class="pre">DOp</span></code> whose two
operands are from the result of a single <code class="docutils literal notranslate"><span class="pre">BOp</span></code>. This is only possible by binding
the result of the <code class="docutils literal notranslate"><span class="pre">BOp</span></code> to a name and reuse it for the second operand of the
<code class="docutils literal notranslate"><span class="pre">DOp</span></code></p>
</section>
<section id="nativecodecall-transforming-the-generated-op">
<h4><code class="docutils literal notranslate"><span class="pre">NativeCodeCall</span></code>: transforming the generated op<a class="headerlink" href="#nativecodecall-transforming-the-generated-op" title="此标题的永久链接">¶</a></h4>
<p>Sometimes the captured arguments are not exactly what we want so they cannot be
directly fed in as arguments to build the new op. For such cases, we can apply
transformations on the arguments by calling into C++ helper functions. This is
achieved by <code class="docutils literal notranslate"><span class="pre">NativeCodeCall</span></code>.</p>
<p>For example, if we want to capture some op’s attributes and group them as an
array attribute to construct a new op:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>
def TwoAttrOp : Op&lt;&quot;two_attr_op&quot;&gt; {
    let arguments = (ins
      AnyAttr:$op_attr1,
      AnyAttr:$op_attr2
    );

    let results = (outs
      AnyType:$op_output
    );
}

def OneAttrOp : Op&lt;&quot;one_attr_op&quot;&gt; {
    let arguments = (ins
      ArrayAttr:$op_attr
    );

    let results = (outs
      AnyType:$op_output
    );
}
</pre></div>
</div>
<p>We can write a C++ helper function:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ArrayAttr</span><span class="w"> </span><span class="nf">createArrayAttr</span><span class="p">(</span><span class="n">Builder</span><span class="w"> </span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span><span class="w"> </span><span class="n">Attribute</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">Attribute</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="n">getArrayAttr</span><span class="p">({</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
<p>And then write the pattern as:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def createArrayAttr : NativeCodeCall&lt;&quot;createArrayAttr($_builder, $0, $1)&quot;&gt;;

def : Pat&lt;(TwoAttrOp $attr1, $attr2),
          (OneAttrOp (createArrayAttr $attr1, $attr2))&gt;;
</pre></div>
</div>
<p>And make sure the generated C++ code from the above pattern has access to the
definition of the C++ helper function.</p>
<p>In the above example, we are using a string to specialize the <code class="docutils literal notranslate"><span class="pre">NativeCodeCall</span></code>
template. The string can be an arbitrary C++ expression that evaluates into some
C++ object expected at the <code class="docutils literal notranslate"><span class="pre">NativeCodeCall</span></code> site (here it would be expecting an
array attribute). Typically the string should be a function call.</p>
<section id="nativecodecall-placeholders">
<h5><code class="docutils literal notranslate"><span class="pre">NativeCodeCall</span></code> placeholders<a class="headerlink" href="#nativecodecall-placeholders" title="此标题的永久链接">¶</a></h5>
<p>In <code class="docutils literal notranslate"><span class="pre">NativeCodeCall</span></code>, we can use placeholders like <code class="docutils literal notranslate"><span class="pre">$_builder</span></code>, <code class="docutils literal notranslate"><span class="pre">$N</span></code> and <code class="docutils literal notranslate"><span class="pre">$N...</span></code>.
The former is called <em>special placeholder</em>, while the latter is called
<em>positional placeholder</em> and <em>positional range placeholder</em>.</p>
<p><code class="docutils literal notranslate"><span class="pre">NativeCodeCall</span></code> right now only supports three special placeholders:
<code class="docutils literal notranslate"><span class="pre">$_builder</span></code>, <code class="docutils literal notranslate"><span class="pre">$_loc</span></code>, and <code class="docutils literal notranslate"><span class="pre">$_self</span></code>:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">$_builder</span></code> will be replaced by the current <code class="docutils literal notranslate"><span class="pre">mlir::PatternRewriter</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">$_loc</span></code> will be replaced by the fused location or custom location (as
determined by location directive).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">$_self</span></code> will be replaced by the defining operation in a source pattern.</p></li>
</ul>
<p>We have seen how <code class="docutils literal notranslate"><span class="pre">$_builder</span></code> can be used in the above; it allows us to pass a
<code class="docutils literal notranslate"><span class="pre">mlir::Builder</span></code> (<code class="docutils literal notranslate"><span class="pre">mlir::PatternRewriter</span></code> is a subclass of <code class="docutils literal notranslate"><span class="pre">mlir::OpBuilder</span></code>,
which is a subclass of <code class="docutils literal notranslate"><span class="pre">mlir::Builder</span></code>) to the C++ helper function to use the
handy methods on <code class="docutils literal notranslate"><span class="pre">mlir::Builder</span></code>.</p>
<p>Here’s an example how we should use <code class="docutils literal notranslate"><span class="pre">$_self</span></code> in source pattern,</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>
def : Pat&lt;(OneAttrOp (NativeCodeCall&lt;&quot;Foo($_self, &amp;$0)&quot;&gt; I32Attr:$val)),
          (TwoAttrOp $val, $val)&gt;;
</pre></div>
</div>
<p>In the above, <code class="docutils literal notranslate"><span class="pre">$_self</span></code> is substituted by the defining operation of the first
operand of OneAttrOp. Note that we don’t support binding name to
<code class="docutils literal notranslate"><span class="pre">NativeCodeCall</span></code> in the source pattern. To carry some return values from a
helper function, put the names (constraint is optional) in the parameter list
and they will be bound to the variables with corresponding type. Then these names
must be either passed by reference or pointer to the variable used as argument
so that the matched value can be returned. In the same example, <code class="docutils literal notranslate"><span class="pre">$val</span></code> will be
bound to a variable with <code class="docutils literal notranslate"><span class="pre">Attribute</span></code> type (as <code class="docutils literal notranslate"><span class="pre">I32Attr</span></code>) and the type of the
second argument in <code class="docutils literal notranslate"><span class="pre">Foo()</span></code> could be <code class="docutils literal notranslate"><span class="pre">Attribute&amp;</span></code> or <code class="docutils literal notranslate"><span class="pre">Attribute*</span></code>. Names with
attribute constraints will be captured as <code class="docutils literal notranslate"><span class="pre">Attribute</span></code>s while everything else
will be treated as <code class="docutils literal notranslate"><span class="pre">Value</span></code>s.</p>
<p>Positional placeholders will be substituted by the <code class="docutils literal notranslate"><span class="pre">dag</span></code> object parameters at
the <code class="docutils literal notranslate"><span class="pre">NativeCodeCall</span></code> use site. For example, if we define <code class="docutils literal notranslate"><span class="pre">SomeCall</span> <span class="pre">:</span> <span class="pre">NativeCodeCall&lt;&quot;someFn($1,</span> <span class="pre">$2,</span> <span class="pre">$0)&quot;&gt;</span></code> and use it like <code class="docutils literal notranslate"><span class="pre">(SomeCall</span> <span class="pre">$in0,</span> <span class="pre">$in1,</span> <span class="pre">$in2)</span></code>, then this will be translated into C++ call <code class="docutils literal notranslate"><span class="pre">someFn($in1,</span> <span class="pre">$in2,</span> <span class="pre">$in0)</span></code>.</p>
<p>Positional range placeholders will be substituted by multiple <code class="docutils literal notranslate"><span class="pre">dag</span></code> object
parameters at the <code class="docutils literal notranslate"><span class="pre">NativeCodeCall</span></code> use site. For example, if we define
<code class="docutils literal notranslate"><span class="pre">SomeCall</span> <span class="pre">:</span> <span class="pre">NativeCodeCall&lt;&quot;someFn($1...)&quot;&gt;</span></code> and use it like <code class="docutils literal notranslate"><span class="pre">(SomeCall</span> <span class="pre">$in0,</span> <span class="pre">$in1,</span> <span class="pre">$in2)</span></code>, then this will be translated into C++ call <code class="docutils literal notranslate"><span class="pre">someFn($in1,</span> <span class="pre">$in2)</span></code>.</p>
</section>
<section id="nativecodecall-binding-multi-results">
<h5><code class="docutils literal notranslate"><span class="pre">NativeCodeCall</span></code> binding multi-results<a class="headerlink" href="#nativecodecall-binding-multi-results" title="此标题的永久链接">¶</a></h5>
<p>To bind multi-results and access the N-th result with <code class="docutils literal notranslate"><span class="pre">$&lt;name&gt;__N</span></code>, specify the
number of return values in the template. Note that only <code class="docutils literal notranslate"><span class="pre">Value</span></code> type is
supported for multiple results binding. For example,</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>
def PackAttrs : NativeCodeCall&lt;&quot;packAttrs($0, $1)&quot;, 2&gt;;
def : Pattern&lt;(TwoResultOp $attr1, $attr2),
              [(OneResultOp (PackAttr:$res__0, $attr1, $attr2)),
               (OneResultOp $res__1)]&gt;;
</pre></div>
</div>
<p>Use <code class="docutils literal notranslate"><span class="pre">NativeCodeCallVoid</span></code> for cases with no return value.</p>
<p>The correct number of returned value specified in NativeCodeCall is important.
It will be used to verify the consistency of the number of return values.
Additionally, <code class="docutils literal notranslate"><span class="pre">mlir-tblgen</span></code> will try to capture the return values of
<code class="docutils literal notranslate"><span class="pre">NativeCodeCall</span></code> in the generated code so that it will trigger a later
compilation error if a <code class="docutils literal notranslate"><span class="pre">NativeCodeCall</span></code> that doesn’t return any result isn’t
labeled with 0 returns.</p>
</section>
<section id="customizing-entire-op-building">
<h5>Customizing entire op building<a class="headerlink" href="#customizing-entire-op-building" title="此标题的永久链接">¶</a></h5>
<p><code class="docutils literal notranslate"><span class="pre">NativeCodeCall</span></code> is not only limited to transforming arguments for building an
op; it can be also used to specify how to build an op entirely. An example:</p>
<p>If we have a C++ function for building an op:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Operation</span><span class="w"> </span><span class="o">*</span><span class="nf">createMyOp</span><span class="p">(</span><span class="n">OpBuilder</span><span class="w"> </span><span class="n">builder</span><span class="p">,</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="n">input</span><span class="p">,</span><span class="w"> </span><span class="n">Attribute</span><span class="w"> </span><span class="n">attr</span><span class="p">);</span>
</pre></div>
</div>
<p>We can wrap it up and invoke it like:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def createMyOp : NativeCodeCall&lt;&quot;createMyOp($_builder, $0, $1)&quot;&gt;;

def : Pat&lt;(... $input, $attr), (createMyOp $input, $attr)&gt;;
</pre></div>
</div>
</section>
</section>
</section>
<section id="supporting-auxiliary-ops">
<h3>Supporting auxiliary ops<a class="headerlink" href="#supporting-auxiliary-ops" title="此标题的永久链接">¶</a></h3>
<p>A declarative rewrite rule supports multiple result patterns. One of the
purposes is to allow generating <em>auxiliary ops</em>. Auxiliary ops are operations
used for building the replacement ops; but they are not directly used for
replacement themselves.</p>
<p>For the case of uni-result ops, if there are multiple result patterns, only the
value generated from the last result pattern will be used to replace the matched
root op’s result; all other result patterns will be considered as generating
auxiliary ops.</p>
<p>Normally we want to specify ops as nested <code class="docutils literal notranslate"><span class="pre">dag</span></code> objects if their def-use
relationship can be expressed in the way that an op’s result can feed as the
argument to consuming op. But that is not always possible. For example, if we
want to allocate memory and store some computation (in pseudocode):</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>%dst = arith.addi %lhs, %rhs
</pre></div>
</div>
<p>into</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>%shape = shape %lhs
%mem = memref.alloc %shape
%sum = arith.addi %lhs, %rhs
memref.store %mem, %sum
%dst = memref.load %mem
</pre></div>
</div>
<p>We cannot fit in with just one result pattern given <code class="docutils literal notranslate"><span class="pre">store</span></code> does not return a
value. Instead we can use multiple result patterns:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def : Pattern&lt;(AddIOp $lhs, $rhs),
              [(StoreOp (AllocOp:$mem (ShapeOp $lhs)), (AddIOp $lhs, $rhs)),
               (LoadOp $mem)];
</pre></div>
</div>
<p>In the above we use the first result pattern to generate the first four ops, and
use the last pattern to generate the last op, which is used to replace the
matched op.</p>
</section>
<section id="supporting-multi-result-ops">
<h3>Supporting multi-result ops<a class="headerlink" href="#supporting-multi-result-ops" title="此标题的永久链接">¶</a></h3>
<p>Multi-result ops bring extra complexity to declarative rewrite rules. We use
TableGen <code class="docutils literal notranslate"><span class="pre">dag</span></code> objects to represent ops in patterns; there is no native way to
indicate that an op generates multiple results. The approach adopted is based on
<strong>naming convention</strong>: a <code class="docutils literal notranslate"><span class="pre">__N</span></code> suffix is added to a symbol to indicate the
<code class="docutils literal notranslate"><span class="pre">N</span></code>-th result.</p>
<section id="n-suffix">
<h4><code class="docutils literal notranslate"><span class="pre">__N</span></code> suffix<a class="headerlink" href="#n-suffix" title="此标题的永久链接">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">__N</span></code> suffix is specifying the <code class="docutils literal notranslate"><span class="pre">N</span></code>-th result as a whole (which can be
<a class="reference external" href="#supporting-variadic-ops">variadic</a>). For example, we can bind a symbol to some
multi-result op and reference a specific result later:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def ThreeResultOp : Op&lt;&quot;three_result_op&quot;&gt; {
    let arguments = (ins ...);

    let results = (outs
      AnyTensor:$output1,
      AnyTensor:$output2,
      AnyTensor:$output3
    );
}

def : Pattern&lt;(ThreeResultOp:$results ...),
              [(... $results__0), ..., (... $results__2), ...]&gt;;
</pre></div>
</div>
<p>In the above pattern we bind <code class="docutils literal notranslate"><span class="pre">$results</span></code> to all the results generated by
<code class="docutils literal notranslate"><span class="pre">ThreeResultOp</span></code> and references its <code class="docutils literal notranslate"><span class="pre">$output1</span></code> and <code class="docutils literal notranslate"><span class="pre">$output3</span></code> later in the result
patterns.</p>
<p>We can also bind a symbol and reference one of its specific result at the same
time, which is typically useful when generating multi-result ops:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>// TwoResultOp has similar definition as ThreeResultOp, but only has two
// results.

def : Pattern&lt;(TwoResultOp ...),
              [(ThreeResultOp:$results__2, ...),
               (replaceWithValue $results__0)]&gt;;
</pre></div>
</div>
<p>In the above, we created a <code class="docutils literal notranslate"><span class="pre">ThreeResultOp</span></code> and bind <code class="docutils literal notranslate"><span class="pre">results</span></code> to its results,
and uses its last result (<code class="docutils literal notranslate"><span class="pre">$output3</span></code>) and first result (<code class="docutils literal notranslate"><span class="pre">$output1</span></code>) to replace
the <code class="docutils literal notranslate"><span class="pre">TwoResultOp</span></code>’s two results, respectively.</p>
</section>
<section id="replacing-multi-result-ops">
<h4>Replacing multi-result ops<a class="headerlink" href="#replacing-multi-result-ops" title="此标题的永久链接">¶</a></h4>
<p>The above example also shows how to replace a matched multi-result op.</p>
<p>To replace an <code class="docutils literal notranslate"><span class="pre">N</span></code>-result op, the result patterns must generate at least <code class="docutils literal notranslate"><span class="pre">N</span></code>
declared values (see <a class="reference external" href="#declared-vs-actual-value">Declared vs. actual value</a> for
definition). If there are more than <code class="docutils literal notranslate"><span class="pre">N</span></code> declared values generated, only the last
<code class="docutils literal notranslate"><span class="pre">N</span></code> declared values will be used to replace the matched op. Note that because of
the existence of multi-result op, one result pattern <strong>may</strong> generate multiple
declared values. So it means we do not necessarily need <code class="docutils literal notranslate"><span class="pre">N</span></code> result patterns to
replace an <code class="docutils literal notranslate"><span class="pre">N</span></code>-result op. For example, to replace an op with three results, you
can have</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>// ThreeResultOp/TwoResultOp/OneResultOp generates three/two/one result(s),
// respectively.

// Replace each result with a result generated from an individual op.
def : Pattern&lt;(ThreeResultOp ...),
              [(OneResultOp ...), (OneResultOp ...), (OneResultOp ...)]&gt;;

// Replace the first two results with two results generated from the same op.
def : Pattern&lt;(ThreeResultOp ...),
              [(TwoResultOp ...), (OneResultOp ...)]&gt;;

// Replace all three results with three results generated from the same op.
def : Pat&lt;(ThreeResultOp ...), (ThreeResultOp ...)&gt;;

def : Pattern&lt;(ThreeResultOp ...),
              [(AuxiliaryOp ...), (ThreeResultOp ...)]&gt;;
</pre></div>
</div>
<p>But using a single op to serve as both auxiliary op and replacement op is
forbidden, i.e., the following is not allowed because that the first
<code class="docutils literal notranslate"><span class="pre">TwoResultOp</span></code> generates two results but only the second result is used for
replacing the matched op’s result:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def : Pattern&lt;(ThreeResultOp ...),
              [(TwoResultOp ...), (TwoResultOp ...)]&gt;;
</pre></div>
</div>
</section>
</section>
<section id="supporting-variadic-ops">
<h3>Supporting variadic ops<a class="headerlink" href="#supporting-variadic-ops" title="此标题的永久链接">¶</a></h3>
<section id="declared-vs-actual-value">
<h4>Declared vs. actual value<a class="headerlink" href="#declared-vs-actual-value" title="此标题的永久链接">¶</a></h4>
<p>Before going into details on variadic op support, we need to define a few terms
regarding an op’s values.</p>
<ul class="simple">
<li><p><em>Value</em>: either an operand or a result</p></li>
<li><p><em>Declared operand/result/value</em>: an operand/result/value statically declared
in ODS of the op</p></li>
<li><p><em>Actual operand/result/value</em>: an operand/result/value of an op instance at
runtime</p></li>
</ul>
<p>The above terms are needed because ops can have multiple results, and some of
the results can also be variadic. For example,</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def MultiVariadicOp : Op&lt;&quot;multi_variadic_op&quot;&gt; {
    let arguments = (ins
      AnyTensor:$input1,
      Variadic&lt;AnyTensor&gt;:$input2,
      AnyTensor:$input3
    );

    let results = (outs
      AnyTensor:$output1,
      Variadic&lt;AnyTensor&gt;:$output2,
      AnyTensor:$output3
    );
}
</pre></div>
</div>
<p>We say the above op has 3 declared operands and 3 declared results. But at
runtime, an instance can have 3 values corresponding to <code class="docutils literal notranslate"><span class="pre">$input2</span></code> and 2 values
correspond to <code class="docutils literal notranslate"><span class="pre">$output2</span></code>; we say it has 5 actual operands and 4 actual results.
A variadic operand/result is a considered as a declared value that can
correspond to multiple actual values.</p>
<p>[TODO]</p>
</section>
</section>
<section id="supplying-additional-constraints">
<h3>Supplying additional constraints<a class="headerlink" href="#supplying-additional-constraints" title="此标题的永久链接">¶</a></h3>
<p>Constraints can be placed on op arguments when matching. But sometimes we need
to also place constraints on the matched op’s results or sometimes need to limit
the matching with some constraints that cover both the arguments and the
results. The third parameter to <code class="docutils literal notranslate"><span class="pre">Pattern</span></code> (and <code class="docutils literal notranslate"><span class="pre">Pat</span></code>) is for this purpose.</p>
<p>For example, we can write</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def HasNoUseOf: Constraint&lt;CPred&lt;&quot;$_self.use_empty()&quot;&gt;, &quot;has no use&quot;&gt;;

def HasSameElementType : Constraint&lt;
    CPred&lt;&quot;$0.cast&lt;ShapedType&gt;().getElementType() == &quot;
          &quot;$1.cast&lt;ShapedType&gt;().getElementType()&quot;&gt;,
    &quot;has same element type&quot;&gt;;

def : Pattern&lt;(TwoResultOp:$results $input),
              [(...), (...)],
              [(F32Tensor:$results__0), (HasNoUseOf:$results__1),
               (HasSameElementShape $results__0, $input)]&gt;;
</pre></div>
</div>
<p>You can</p>
<ul class="simple">
<li><p>Use normal <code class="docutils literal notranslate"><span class="pre">TypeConstraint</span></code>s on previous bound symbols (the first result of
<code class="docutils literal notranslate"><span class="pre">TwoResultOp</span></code> must be a float tensor);</p></li>
<li><p>Define new <code class="docutils literal notranslate"><span class="pre">Constraint</span></code> for previous bound symbols (the second result of
<code class="docutils literal notranslate"><span class="pre">TwoResultOp</span></code> must has no use);</p></li>
<li><p>Apply constraints on multiple bound symbols (<code class="docutils literal notranslate"><span class="pre">$input</span></code> and <code class="docutils literal notranslate"><span class="pre">TwoResultOp</span></code>’s
first result must have the same element type).</p></li>
</ul>
</section>
<section id="adjusting-benefits">
<h3>Adjusting benefits<a class="headerlink" href="#adjusting-benefits" title="此标题的永久链接">¶</a></h3>
<p>The benefit of a <code class="docutils literal notranslate"><span class="pre">Pattern</span></code> is an integer value indicating the benefit of
matching the pattern. It determines the priorities of patterns inside the
pattern rewrite driver. A pattern with a higher benefit is applied before one
with a lower benefit.</p>
<p>In DRR, a rule is set to have a benefit of the number of ops in the source
pattern. This is based on the heuristics and assumptions that:</p>
<ul class="simple">
<li><p>Larger matches are more beneficial than smaller ones.</p></li>
<li><p>If a smaller one is applied first the larger one may not apply anymore.</p></li>
</ul>
<p>The fourth parameter to <code class="docutils literal notranslate"><span class="pre">Pattern</span></code> (and <code class="docutils literal notranslate"><span class="pre">Pat</span></code>) allows to manually tweak a
pattern’s benefit. Just supply <code class="docutils literal notranslate"><span class="pre">(addBenefit</span> <span class="pre">N)</span></code> to add <code class="docutils literal notranslate"><span class="pre">N</span></code> to the benefit value.</p>
</section>
</section>
<section id="rewrite-directives">
<h2>Rewrite directives<a class="headerlink" href="#rewrite-directives" title="此标题的永久链接">¶</a></h2>
<section id="location">
<h3><code class="docutils literal notranslate"><span class="pre">location</span></code><a class="headerlink" href="#location" title="此标题的永久链接">¶</a></h3>
<p>By default the C++ pattern expanded from a DRR pattern uses the fused location
of all source ops as the location for all generated ops. This is not always the
best location mapping relationship. For such cases, DRR provides the <code class="docutils literal notranslate"><span class="pre">location</span></code>
directive to provide finer control.</p>
<p><code class="docutils literal notranslate"><span class="pre">location</span></code> is of the following syntax:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>(location $symbol0, $symbol1, ...)
</pre></div>
</div>
<p>where all <code class="docutils literal notranslate"><span class="pre">$symbol</span></code> should be bound previously in the pattern and one optional
string may be specified as an attribute. The following locations are created:</p>
<ul class="simple">
<li><p>If only 1 symbol is specified then that symbol’s location is used,</p></li>
<li><p>If multiple are specified then a fused location is created;</p></li>
<li><p>If no symbol is specified then string must be specified and a NamedLoc is
created instead;</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">location</span></code> must be used as a trailing argument to an op creation. For example,</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def : Pat&lt;(LocSrc1Op:$src1 (LocSrc2Op:$src2 ...),
          (LocDst1Op (LocDst2Op ..., (location $src2)), (location &quot;outer&quot;))&gt;;
</pre></div>
</div>
<p>In the above pattern, the generated <code class="docutils literal notranslate"><span class="pre">LocDst2Op</span></code> will use the matched location of
<code class="docutils literal notranslate"><span class="pre">LocSrc2Op</span></code> while the root <code class="docutils literal notranslate"><span class="pre">LocDst1Op</span></code> node will used the named location
<code class="docutils literal notranslate"><span class="pre">outer</span></code>.</p>
</section>
<section id="replacewithvalue">
<h3><code class="docutils literal notranslate"><span class="pre">replaceWithValue</span></code><a class="headerlink" href="#replacewithvalue" title="此标题的永久链接">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">replaceWithValue</span></code> directive is used to eliminate a matched op by replacing
all of its uses with a captured value. It is of the following syntax:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>(replaceWithValue $symbol)
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">$symbol</span></code> should be a symbol bound previously in the pattern.</p>
<p>For example,</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def : Pat&lt;(Foo $input), (replaceWithValue $input)&gt;;
</pre></div>
</div>
<p>The above pattern removes the <code class="docutils literal notranslate"><span class="pre">Foo</span></code> and replaces all uses of <code class="docutils literal notranslate"><span class="pre">Foo</span></code> with
<code class="docutils literal notranslate"><span class="pre">$input</span></code>.</p>
</section>
<section id="returntype">
<h3><code class="docutils literal notranslate"><span class="pre">returnType</span></code><a class="headerlink" href="#returntype" title="此标题的永久链接">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">returnType</span></code> directive allows patterns to directly specify return types for
replacement ops that lack return type inference with op traits or user-defined
builders with return type deduction.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">returnType</span></code> directive must be used as a trailing argument to a node
describing a replacement op. The directive comes in three forms:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">(returnType</span> <span class="pre">$value)</span></code>: copy the type of the operand or result bound to
<code class="docutils literal notranslate"><span class="pre">value</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(returnType</span> <span class="pre">&quot;$_builder.getI32Type()&quot;)</span></code>: a string literal embedding C++. The
embedded snippet is expected to return a <code class="docutils literal notranslate"><span class="pre">Type</span></code> or a <code class="docutils literal notranslate"><span class="pre">TypeRange</span></code>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(returnType</span> <span class="pre">(NativeCodeCall&lt;&quot;myFunc($0)&quot;&gt;</span> <span class="pre">$value))</span></code>: a DAG node with a
native code call that can be passed any bound variables arguments.</p></li>
</ul>
<p>Specify multiple return types with a mix of any of the above. Example:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def : Pat&lt;(SourceOp $arg0, $arg1),
          (OpA $arg0, (TwoResultOp:$res__1 $arg1,
                         (returnType $arg1, &quot;$_builder.getI64Type()&quot;)))&gt;;
</pre></div>
</div>
<p>Explicitly-specified return types will take precedence over return types
inferred from op traits or user-defined builders. The return types of values
replacing root op results cannot be overridden.</p>
</section>
<section id="either">
<h3><code class="docutils literal notranslate"><span class="pre">either</span></code><a class="headerlink" href="#either" title="此标题的永久链接">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">either</span></code> directive is used to specify the operands may be matched in either
order.</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def : Pat&lt;(TwoArgOp (either $firstArg, (AnOp $secondArg))),
          (...)&gt;;
</pre></div>
</div>
<p>The above pattern will accept either <code class="docutils literal notranslate"><span class="pre">&quot;test.TwoArgOp&quot;(%I32Arg,</span> <span class="pre">%AnOpArg)</span></code> and
<code class="docutils literal notranslate"><span class="pre">&quot;test.TwoArgOp&quot;(%AnOpArg,</span> <span class="pre">%I32Arg)</span></code>.</p>
<p>Only operand is supported with <code class="docutils literal notranslate"><span class="pre">either</span></code> and note that an operation with
<code class="docutils literal notranslate"><span class="pre">Commutative</span></code> trait doesn’t imply that it’ll have the same behavior than
<code class="docutils literal notranslate"><span class="pre">either</span></code> while pattern matching.</p>
</section>
</section>
<section id="debugging-tips">
<h2>Debugging Tips<a class="headerlink" href="#debugging-tips" title="此标题的永久链接">¶</a></h2>
<section id="run-mlir-tblgen-to-see-the-generated-content">
<h3>Run <code class="docutils literal notranslate"><span class="pre">mlir-tblgen</span></code> to see the generated content<a class="headerlink" href="#run-mlir-tblgen-to-see-the-generated-content" title="此标题的永久链接">¶</a></h3>
<p>TableGen syntax sometimes can be obscure; reading the generated content can be a
very helpful way to understand and debug issues. To build <code class="docutils literal notranslate"><span class="pre">mlir-tblgen</span></code>, run
<code class="docutils literal notranslate"><span class="pre">cmake</span> <span class="pre">--build</span> <span class="pre">.</span> <span class="pre">--target</span> <span class="pre">mlir-tblgen</span></code> in your build directory and find the
<code class="docutils literal notranslate"><span class="pre">mlir-tblgen</span></code> binary in the <code class="docutils literal notranslate"><span class="pre">bin/</span></code> subdirectory. All the supported generators
can be found via <code class="docutils literal notranslate"><span class="pre">mlir-tblgen</span> <span class="pre">--help</span></code>.</p>
<p>To see the generated code, invoke <code class="docutils literal notranslate"><span class="pre">mlir-tblgen</span></code> with a specific generator by
providing include paths via <code class="docutils literal notranslate"><span class="pre">-I</span></code>. For example,</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span><span class="c1"># To see all the C++ pattern rewrite classes</span>
mlir-tblgen<span class="w"> </span>--gen-rewriters<span class="w"> </span>-I<span class="w"> </span>/path/to/mlir/include<span class="w"> </span>/path/to/input/td/file
</pre></div>
</div>
</section>
<section id="compilation-error-no-matching-member-function-for-call-to-build">
<h3>Compilation error: no matching member function for call to ‘build’<a class="headerlink" href="#compilation-error-no-matching-member-function-for-call-to-build" title="此标题的永久链接">¶</a></h3>
<p>This is because DRR is failing to call a <code class="docutils literal notranslate"><span class="pre">build()</span></code> method with result type
deduction ability. See <a class="reference external" href="#building-operations">building operations</a> for more
details.</p>
</section>
</section>
</section>


          </div>
          <div class="page-nav">
            <div class="inner"><ul class="page-nav">
</ul><div class="footer" role="contentinfo">
      &#169; 版权所有 2023, yaoyue123.
    <br>
    Created using <a href="http://sphinx-doc.org/">Sphinx</a> 6.1.3 with <a href="https://github.com/schettino72/sphinx_press_theme">Press Theme</a> 0.8.0.
</div>
            </div>
          </div>
      </page>
    </div></div>
    
    
  </body>
</html>