<!DOCTYPE html>
<html  lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1"><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

      <title>Pass Infrastructure</title>
    
          <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
          <link rel="stylesheet" href="../_static/theme.css " type="text/css" />
      
      <!-- sphinx script_files -->
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script src="../_static/translations.js"></script>

      
      <!-- bundled in js (rollup iife) -->
      <!-- <script src="../_static/theme-vendors.js"></script> -->
      <script src="../_static/theme.js" defer></script>
    
  <link rel="index" title="索引" href="../genindex.html" />
  <link rel="search" title="搜索" href="../search.html" /> 
  </head>

  <body>
    <div id="app">
    <div class="theme-container" :class="pageClasses"><navbar @toggle-sidebar="toggleSidebar">
  <router-link to="../index.html" class="home-link">
    
      <span class="site-name">MLIR 中文文档</span>
    
  </router-link>

  <div class="links">
    <navlinks class="can-hide">



    </navlinks>
  </div>
</navbar>

      
      <div class="sidebar-mask" @click="toggleSidebar(false)">
      </div>
        <sidebar @toggle-sidebar="toggleSidebar">
          
          <navlinks>
            



            
          </navlinks><div id="searchbox" class="searchbox" role="search">
  <div class="caption"><span class="caption-text">快速搜索</span>
    <div class="searchformwrapper">
      <form class="search" action="../search.html" method="get">
        <input type="text" name="q" />
        <input type="submit" value="搜索" />
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div><div class="sidebar-links" role="navigation" aria-label="main navigation">
  
    <div class="sidebar-group">
      <p class="caption">
        <span class="caption-text"><a href="../index.html#mlir">欢迎使用 mlir 中文文档</a></span>
      </p>
      <ul class="">
        
          <li class="toctree-l1 ">
            
              <a href="../_index.html" class="reference internal ">开始使用</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/CreatingADialect.html" class="reference internal ">Creating a Dialect</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/DataFlowAnalysis.html" class="reference internal ">Writing DataFlow Analyses in MLIR</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/QuickstartRewrites.html" class="reference internal ">Quickstart tutorial to adding MLIR graph rewrite</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-1.html" class="reference internal ">Chapter 1: Toy Language and AST</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-2.html" class="reference internal ">Chapter 2: Emitting Basic MLIR</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-3.html" class="reference internal ">Chapter 3: High-level Language-Specific Analysis and Transformation</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-4.html" class="reference internal ">Chapter 4: Enabling Generic Transformation with Interfaces</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-5.html" class="reference internal ">Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-6.html" class="reference internal ">Chapter 6: Lowering to LLVM and CodeGeneration</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/Ch-7.html" class="reference internal ">Chapter 7: Adding a Composite Type to Toy</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/Toy/_index.html" class="reference internal ">Toy Tutorial</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/UnderstandingTheIRStructure.html" class="reference internal ">Understanding the IR Structure</a>
            

            
          </li>

        
          <li class="toctree-l1 ">
            
              <a href="Tutorials/_index.html" class="reference internal ">Tutorials</a>
            

            
          </li>

        
      </ul>
    </div>
  
</div>
        </sidebar>

      <page>
          <div class="body-header" role="navigation" aria-label="navigation">
  
  <ul class="breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
    
    <li>Pass Infrastructure</li>
  </ul>
  

  <ul class="page-nav">
</ul>
  
</div>
<hr>
          <div class="content" role="main" v-pre>
            
  <section id="pass-infrastructure">
<h1>Pass Infrastructure<a class="headerlink" href="#pass-infrastructure" title="此标题的永久链接">¶</a></h1>
<p>[TOC]</p>
<p>Passes represent the basic infrastructure for transformation and optimization.
This document provides an overview of the pass infrastructure in MLIR and how to
use it.</p>
<p>See <a class="reference internal" href="LangRef.html"><span class="doc">MLIR specification</span></a> for more information about MLIR and its
core aspects, such as the IR structure and operations.</p>
<p>See <a class="reference internal" href="Tutorials/QuickstartRewrites.html"><span class="doc">MLIR Rewrites</span></a> for a quick start on graph
rewriting in MLIR. If a transformation involves pattern matching operation DAGs,
this is a great place to start.</p>
<section id="operation-pass">
<h2>Operation Pass<a class="headerlink" href="#operation-pass" title="此标题的永久链接">¶</a></h2>
<p>In MLIR, the main unit of abstraction and transformation is an
<a class="reference external" href="LangRef.md/#operations">operation</a>. As such, the pass manager is designed to
work on instances of operations at different levels of nesting. The structure of
the <a class="reference external" href="#pass-manager">pass manager</a>, and the concept of nesting, is detailed
further below. All passes in MLIR derive from <code class="docutils literal notranslate"><span class="pre">OperationPass</span></code> and adhere to the
following restrictions; any noncompliance will lead to problematic behavior in
multithreaded and other advanced scenarios:</p>
<ul class="simple">
<li><p>Must not modify any state referenced or relied upon outside the current
operation being operated on. This includes adding or removing operations
from the parent block, changing the attributes(depending on the contract
of the current operation)/operands/results/successors of the current operation.</p></li>
<li><p>Must not modify the state of another operation not nested within the current
operation being operated on.</p>
<ul>
<li><p>Other threads may be operating on these operations simultaneously.</p></li>
</ul>
</li>
<li><p>Must not inspect the state of sibling operations.</p>
<ul>
<li><p>Other threads may be modifying these operations in parallel.</p></li>
<li><p>Inspecting the state of ancestor/parent operations is permitted.</p></li>
</ul>
</li>
<li><p>Must not maintain mutable pass state across invocations of <code class="docutils literal notranslate"><span class="pre">runOnOperation</span></code>.
A pass may be run on many different operations with no guarantee of
execution order.</p>
<ul>
<li><p>When multithreading, a specific pass instance may not even execute on
all operations within the IR. As such, a pass should not rely on running
on all operations.</p></li>
</ul>
</li>
<li><p>Must not maintain any global mutable state, e.g. static variables within the
source file. All mutable state should be maintained by an instance of the
pass.</p></li>
<li><p>Must be copy-constructible</p>
<ul>
<li><p>Multiple instances of the pass may be created by the pass manager to
process operations in parallel.</p></li>
</ul>
</li>
</ul>
<section id="op-agnostic-operation-passes">
<h3>Op-Agnostic Operation Passes<a class="headerlink" href="#op-agnostic-operation-passes" title="此标题的永久链接">¶</a></h3>
<p>By default, an operation pass is <code class="docutils literal notranslate"><span class="pre">op-agnostic</span></code>, meaning that it operates on the
operation type of the pass manager that it is added to. This means a pass may operate
on many different types of operations. Agnostic passes should be written such that
they do not make assumptions on the operation they run on. Examples of this type of pass are
<a class="reference external" href="Pass.md/-canonicalize-canonicalize-operations">Canonicalization</a>
<a class="reference external" href="Passes.md/#-cse-eliminate-common-sub-expressions">Common Sub-Expression Elimination</a>.</p>
<p>To create an agnostic operation pass, a derived class must adhere to the following:</p>
<ul class="simple">
<li><p>Inherit from the CRTP class <code class="docutils literal notranslate"><span class="pre">OperationPass</span></code>.</p></li>
<li><p>Override the virtual <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">runOnOperation()</span></code> method.</p></li>
</ul>
<p>A simple pass may look like:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// Here we utilize the CRTP `PassWrapper` utility class to provide some</span>
<span class="c1">/// necessary utility hooks. This is only necessary for passes defined directly</span>
<span class="c1">/// in C++. Passes defined declaratively use a cleaner mechanism for providing</span>
<span class="c1">/// these utilities.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">MyOperationPass</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">PassWrapper</span><span class="o">&lt;</span><span class="n">MyOperationPass</span><span class="p">,</span><span class="w"> </span><span class="n">OperationPass</span><span class="o">&lt;&gt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">runOnOperation</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Get the current operation being operated on.</span>
<span class="w">    </span><span class="n">Operation</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getOperation</span><span class="p">();</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="filtered-operation-pass">
<h3>Filtered Operation Pass<a class="headerlink" href="#filtered-operation-pass" title="此标题的永久链接">¶</a></h3>
<p>If a pass needs to constrain its execution to specific types or classes of operations,
additional filtering may be applied on top. This transforms a once <code class="docutils literal notranslate"><span class="pre">agnostic</span></code> pass into
one more specific to a certain context. There are various ways in which to filter the
execution of a pass, and different contexts in which filtering may apply:</p>
</section>
<section id="operation-pass-static-schedule-filtering">
<h3>Operation Pass: Static Schedule Filtering<a class="headerlink" href="#operation-pass-static-schedule-filtering" title="此标题的永久链接">¶</a></h3>
<p>Static filtering allows for applying additional constraints on the operation types a
pass may be scheduled on. This type of filtering generally allows for building more
constrained passes that can only be scheduled on operations that satisfy the necessary
constraints. For example, this allows for specifying passes that only run on operations
of a certain, those that provide a certain interface, trait, or some other constraint that
applies to all instances of that operation type. Below is an example of a pass that only
permits scheduling on operations that implement <code class="docutils literal notranslate"><span class="pre">FunctionOpInterface</span></code>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">MyFunctionPass</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">/// This method is used to provide additional static filtering, and returns if the</span>
<span class="w">  </span><span class="c1">/// pass may be scheduled on the given operation type.</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="nf">canScheduleOn</span><span class="p">(</span><span class="n">RegisteredOperationName</span><span class="w"> </span><span class="n">opInfo</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">opInfo</span><span class="p">.</span><span class="n">hasInterface</span><span class="o">&lt;</span><span class="n">FunctionOpInterface</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">runOnOperation</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Here we can freely cast to FunctionOpInterface, because our `canScheduleOn` ensures</span>
<span class="w">    </span><span class="c1">// that our pass is only executed on operations implementing that interface.</span>
<span class="w">    </span><span class="n">FunctionOpInterface</span><span class="w"> </span><span class="n">op</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cast</span><span class="o">&lt;</span><span class="n">FunctionOpInterface</span><span class="o">&gt;</span><span class="p">(</span><span class="n">getOperation</span><span class="p">());</span><span class="w"> </span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>When a pass with static filtering is added to an <a class="reference external" href="#oppassmanager"><code class="docutils literal notranslate"><span class="pre">op-specific</span></code> pass manager</a>,
it asserts that the operation type of the pass manager satisfies the static constraints of the
pass. When added to an <a class="reference external" href="#oppassmanager"><code class="docutils literal notranslate"><span class="pre">op-agnostic</span></code> pass manager</a>, that pass manager, and all
passes contained within, inherits the static constraints of the pass. For example, if the pass
filters on <code class="docutils literal notranslate"><span class="pre">FunctionOpInterface</span></code>, as in the <code class="docutils literal notranslate"><span class="pre">MyFunctionPass</span></code> example above, only operations that
implement <code class="docutils literal notranslate"><span class="pre">FunctionOpInterface</span></code> will be considered when executing <strong>any</strong> passes within the pass
manager. This invariant is important to keep in mind, as each pass added to an <code class="docutils literal notranslate"><span class="pre">op-agnostic</span></code> pass
manager further constrains the operations that may be scheduled on it. Consider the following example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>func.func @foo() {
  // ...
  return
}

module @someModule {
  // ...
}
</pre></div>
</div>
<p>If we were to apply the op-agnostic pipeline, <code class="docutils literal notranslate"><span class="pre">any(cse,my-function-pass)</span></code>, to the above MLIR snippet
it would only run on the <code class="docutils literal notranslate"><span class="pre">foo</span></code> function operation. This is because the <code class="docutils literal notranslate"><span class="pre">my-function-pass</span></code> has a
static filtering constraint to only schedule on operations implementing <code class="docutils literal notranslate"><span class="pre">FunctionOpInterface</span></code>. Remember
that this constraint is inherited by the entire pass manager, so we never consider <code class="docutils literal notranslate"><span class="pre">someModule</span></code> for
any of the passes, including <code class="docutils literal notranslate"><span class="pre">cse</span></code> which normally can be scheduled on any operation.</p>
<section id="operation-pass-static-filtering-by-op-type">
<h4>Operation Pass: Static Filtering By Op Type<a class="headerlink" href="#operation-pass-static-filtering-by-op-type" title="此标题的永久链接">¶</a></h4>
<p>In the above section, we detailed a general mechanism for statically filtering the types of operations
that a pass may be scheduled on. Sugar is provided on top of that mechanism to simplify the definition
of passes that are restricted to scheduling on a single operation type. In these cases, a pass simply
needs to provide the type of operation to the <code class="docutils literal notranslate"><span class="pre">OperationPass</span></code> base class. This will automatically
instill filtering on that operation type:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// Here we utilize the CRTP `PassWrapper` utility class to provide some</span>
<span class="c1">/// necessary utility hooks. This is only necessary for passes defined directly</span>
<span class="c1">/// in C++. Passes defined declaratively use a cleaner mechanism for providing</span>
<span class="c1">/// these utilities.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">MyFunctionPass</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">PassWrapper</span><span class="o">&lt;</span><span class="n">MyOperationPass</span><span class="p">,</span><span class="w"> </span><span class="n">OperationPass</span><span class="o">&lt;</span><span class="n">func</span><span class="o">::</span><span class="n">FuncOp</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">runOnOperation</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Get the current operation being operated on.</span>
<span class="w">    </span><span class="n">func</span><span class="o">::</span><span class="n">FuncOp</span><span class="w"> </span><span class="n">op</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getOperation</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="operation-pass-static-filtering-by-interface">
<h4>Operation Pass: Static Filtering By Interface<a class="headerlink" href="#operation-pass-static-filtering-by-interface" title="此标题的永久链接">¶</a></h4>
<p>In the above section, we detailed a general mechanism for statically filtering the types of operations
that a pass may be scheduled on. Sugar is provided on top of that mechanism to simplify the definition
of passes that are restricted to scheduling on a specific operation interface. In these cases, a pass
simply needs to inherit from the <code class="docutils literal notranslate"><span class="pre">InterfacePass</span></code> base class. This class is similar to <code class="docutils literal notranslate"><span class="pre">OperationPass</span></code>,
but expects the type of interface to operate on. This will automatically instill filtering on that
interface type:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// Here we utilize the CRTP `PassWrapper` utility class to provide some</span>
<span class="c1">/// necessary utility hooks. This is only necessary for passes defined directly</span>
<span class="c1">/// in C++. Passes defined declaratively use a cleaner mechanism for providing</span>
<span class="c1">/// these utilities.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">MyFunctionPass</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">PassWrapper</span><span class="o">&lt;</span><span class="n">MyOperationPass</span><span class="p">,</span><span class="w"> </span><span class="n">InterfacePass</span><span class="o">&lt;</span><span class="n">FunctionOpInterface</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">runOnOperation</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Get the current operation being operated on.</span>
<span class="w">    </span><span class="n">FunctionOpInterface</span><span class="w"> </span><span class="n">op</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getOperation</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
</section>
<section id="dependent-dialects">
<h3>Dependent Dialects<a class="headerlink" href="#dependent-dialects" title="此标题的永久链接">¶</a></h3>
<p>Dialects must be loaded in the MLIRContext before entities from these dialects
(operations, types, attributes, …) can be created. Dialects must also be
loaded before starting the execution of a multi-threaded pass pipeline. To this
end, a pass that may create an entity from a dialect that isn’t guaranteed to
already be loaded must express this by overriding the <code class="docutils literal notranslate"><span class="pre">getDependentDialects()</span></code>
method and declare this list of Dialects explicitly.
See also the <code class="docutils literal notranslate"><span class="pre">dependentDialects</span></code> field in the
<a class="reference external" href="#tablegen-specification">TableGen Specification</a>.</p>
</section>
<section id="initialization">
<h3>Initialization<a class="headerlink" href="#initialization" title="此标题的永久链接">¶</a></h3>
<p>In certain situations, a Pass may contain state that is constructed dynamically,
but is potentially expensive to recompute in successive runs of the Pass. One
such example is when using <a class="reference external" href="Dialects/PDLOps"><code class="docutils literal notranslate"><span class="pre">PDL</span></code>-based</a>
<a class="reference internal" href="PatternRewriter.html"><span class="doc">patterns</span></a>, which are compiled into a bytecode during
runtime. In these situations, a pass may override the following hook to
initialize this heavy state:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">LogicalResult</span> <span class="pre">initialize(MLIRContext</span> <span class="pre">*context)</span></code></p></li>
</ul>
<p>This hook is executed once per run of a full pass pipeline, meaning that it does
not have access to the state available during a <code class="docutils literal notranslate"><span class="pre">runOnOperation</span></code> call. More
concretely, all necessary accesses to an <code class="docutils literal notranslate"><span class="pre">MLIRContext</span></code> should be driven via the
provided <code class="docutils literal notranslate"><span class="pre">context</span></code> parameter, and methods that utilize “per-run” state such as
<code class="docutils literal notranslate"><span class="pre">getContext</span></code>/<code class="docutils literal notranslate"><span class="pre">getOperation</span></code>/<code class="docutils literal notranslate"><span class="pre">getAnalysis</span></code>/etc. must not be used.
In case of an error during initialization, the pass is expected to emit an error
diagnostic and return a <code class="docutils literal notranslate"><span class="pre">failure()</span></code> which will abort the pass pipeline execution.</p>
</section>
</section>
<section id="analysis-management">
<h2>Analysis Management<a class="headerlink" href="#analysis-management" title="此标题的永久链接">¶</a></h2>
<p>An important concept, along with transformation passes, are analyses. These are
conceptually similar to transformation passes, except that they compute
information on a specific operation without modifying it. In MLIR, analyses are
not passes but free-standing classes that are computed lazily on-demand and
cached to avoid unnecessary recomputation. An analysis in MLIR must adhere to
the following:</p>
<ul class="simple">
<li><p>Provide a valid constructor taking either an <code class="docutils literal notranslate"><span class="pre">Operation*</span></code> or <code class="docutils literal notranslate"><span class="pre">Operation*</span></code>
and <code class="docutils literal notranslate"><span class="pre">AnalysisManager</span> <span class="pre">&amp;</span></code>.</p>
<ul>
<li><p>The provided <code class="docutils literal notranslate"><span class="pre">AnalysisManager</span> <span class="pre">&amp;</span></code> should be used to query any necessary
analysis dependencies.</p></li>
</ul>
</li>
<li><p>Must not modify the given operation.</p></li>
</ul>
<p>An analysis may provide additional hooks to control various behavior:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">isInvalidated(const</span> <span class="pre">AnalysisManager::PreservedAnalyses</span> <span class="pre">&amp;)</span></code></p></li>
</ul>
<p>Given a preserved analysis set, the analysis returns true if it should truly be
invalidated. This allows for more fine-tuned invalidation in cases where an
analysis wasn’t explicitly marked preserved, but may be preserved (or
invalidated) based upon other properties such as analyses sets. If the analysis
uses any other analysis as a dependency, it must also check if the dependency
was invalidated.</p>
<section id="querying-analyses">
<h3>Querying Analyses<a class="headerlink" href="#querying-analyses" title="此标题的永久链接">¶</a></h3>
<p>The base <code class="docutils literal notranslate"><span class="pre">OperationPass</span></code> class provides utilities for querying and preserving
analyses for the current operation being processed.</p>
<ul class="simple">
<li><p>OperationPass automatically provides the following utilities for querying
analyses:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">getAnalysis&lt;&gt;</span></code></p>
<ul>
<li><p>Get an analysis for the current operation, constructing it if
necessary.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">getCachedAnalysis&lt;&gt;</span></code></p>
<ul>
<li><p>Get an analysis for the current operation, if it already exists.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">getCachedParentAnalysis&lt;&gt;</span></code></p>
<ul>
<li><p>Get an analysis for a given parent operation, if it exists.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">getCachedChildAnalysis&lt;&gt;</span></code></p>
<ul>
<li><p>Get an analysis for a given child operation, if it exists.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">getChildAnalysis&lt;&gt;</span></code></p>
<ul>
<li><p>Get an analysis for a given child operation, constructing it if
necessary.</p></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Using the example passes defined above, let’s see some examples:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">/// An interesting analysis.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">MyOperationAnalysis</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Compute this analysis with the provided operation.</span>
<span class="w">  </span><span class="n">MyOperationAnalysis</span><span class="p">(</span><span class="n">Operation</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">MyOperationAnalysisWithDependency</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">MyOperationAnalysisWithDependency</span><span class="p">(</span><span class="n">Operation</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="n">AnalysisManager</span><span class="w"> </span><span class="o">&amp;</span><span class="n">am</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Request other analysis as dependency</span>
<span class="w">    </span><span class="n">MyOperationAnalysis</span><span class="w"> </span><span class="o">&amp;</span><span class="n">otherAnalysis</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">am</span><span class="p">.</span><span class="n">getAnalysis</span><span class="o">&lt;</span><span class="n">MyOperationAnalysis</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">isInvalidated</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">AnalysisManager</span><span class="o">::</span><span class="n">PreservedAnalyses</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pa</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Check if analysis or its dependency were invalidated</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">!</span><span class="n">pa</span><span class="p">.</span><span class="n">isPreserved</span><span class="o">&lt;</span><span class="n">MyOperationAnalysisWithDependency</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="o">||</span>
<span class="w">           </span><span class="o">!</span><span class="n">pa</span><span class="p">.</span><span class="n">isPreserved</span><span class="o">&lt;</span><span class="n">MyOperationAnalysis</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">MyOperationPass::runOnOperation</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Query MyOperationAnalysis for the current operation.</span>
<span class="w">  </span><span class="n">MyOperationAnalysis</span><span class="w"> </span><span class="o">&amp;</span><span class="n">myAnalysis</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getAnalysis</span><span class="o">&lt;</span><span class="n">MyOperationAnalysis</span><span class="o">&gt;</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// Query a cached instance of MyOperationAnalysis for the current operation.</span>
<span class="w">  </span><span class="c1">// It will not be computed if it doesn&#39;t exist.</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">optionalAnalysis</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getCachedAnalysis</span><span class="o">&lt;</span><span class="n">MyOperationAnalysis</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">optionalAnalysis</span><span class="p">)</span>
<span class="w">    </span><span class="p">...</span>

<span class="w">  </span><span class="c1">// Query a cached instance of MyOperationAnalysis for the parent operation of</span>
<span class="w">  </span><span class="c1">// the current operation. It will not be computed if it doesn&#39;t exist.</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">optionalAnalysis</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getCachedParentAnalysis</span><span class="o">&lt;</span><span class="n">MyOperationAnalysis</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">optionalAnalysis</span><span class="p">)</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="preserving-analyses">
<h3>Preserving Analyses<a class="headerlink" href="#preserving-analyses" title="此标题的永久链接">¶</a></h3>
<p>Analyses that are constructed after being queried by a pass are cached to avoid
unnecessary computation if they are requested again later. To avoid stale
analyses, all analyses are assumed to be invalidated by a pass. To avoid
invalidation, a pass must specifically mark analyses that are known to be
preserved.</p>
<ul class="simple">
<li><p>All Pass classes automatically provide the following utilities for
preserving analyses:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">markAllAnalysesPreserved</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">markAnalysesPreserved&lt;&gt;</span></code></p></li>
</ul>
</li>
</ul>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">MyOperationPass::runOnOperation</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Mark all analyses as preserved. This is useful if a pass can guarantee</span>
<span class="w">  </span><span class="c1">// that no transformation was performed.</span>
<span class="w">  </span><span class="n">markAllAnalysesPreserved</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// Mark specific analyses as preserved. This is used if some transformation</span>
<span class="w">  </span><span class="c1">// was performed, but some analyses were either unaffected or explicitly</span>
<span class="w">  </span><span class="c1">// preserved.</span>
<span class="w">  </span><span class="n">markAnalysesPreserved</span><span class="o">&lt;</span><span class="n">MyAnalysis</span><span class="p">,</span><span class="w"> </span><span class="n">MyAnalyses</span><span class="p">...</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
<section id="pass-failure">
<h2>Pass Failure<a class="headerlink" href="#pass-failure" title="此标题的永久链接">¶</a></h2>
<p>Passes in MLIR are allowed to gracefully fail. This may happen if some invariant
of the pass was broken, potentially leaving the IR in some invalid state. If
such a situation occurs, the pass can directly signal a failure to the pass
manager via the <code class="docutils literal notranslate"><span class="pre">signalPassFailure</span></code> method. If a pass signaled a failure when
executing, no other passes in the pipeline will execute and the top-level call
to <code class="docutils literal notranslate"><span class="pre">PassManager::run</span></code> will return <code class="docutils literal notranslate"><span class="pre">failure</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">MyOperationPass::runOnOperation</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Signal failure on a broken invariant.</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">some_broken_invariant</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">signalPassFailure</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="pass-manager">
<h2>Pass Manager<a class="headerlink" href="#pass-manager" title="此标题的永久链接">¶</a></h2>
<p>The above sections introduced the different types of passes and their
invariants. This section introduces the concept of a PassManager, and how it can
be used to configure and schedule a pass pipeline. There are two main classes
related to pass management, the <code class="docutils literal notranslate"><span class="pre">PassManager</span></code> and the <code class="docutils literal notranslate"><span class="pre">OpPassManager</span></code>. The
<code class="docutils literal notranslate"><span class="pre">PassManager</span></code> class acts as the top-level entry point, and contains various
configurations used for the entire pass pipeline. The <code class="docutils literal notranslate"><span class="pre">OpPassManager</span></code> class is
used to schedule passes to run at a specific level of nesting. The top-level
<code class="docutils literal notranslate"><span class="pre">PassManager</span></code> also functions as an <code class="docutils literal notranslate"><span class="pre">OpPassManager</span></code>.</p>
<section id="oppassmanager">
<h3>OpPassManager<a class="headerlink" href="#oppassmanager" title="此标题的永久链接">¶</a></h3>
<p>An <code class="docutils literal notranslate"><span class="pre">OpPassManager</span></code> is essentially a collection of passes anchored to execute on
operations at a given level of nesting. A pass manager may be <code class="docutils literal notranslate"><span class="pre">op-specific</span></code>
(anchored on a specific operation type), or <code class="docutils literal notranslate"><span class="pre">op-agnostic</span></code> (not restricted to any
specific operation, and executed on any viable operation type). Operation types that
anchor pass managers must adhere to the following requirement:</p>
<ul class="simple">
<li><p>Must be registered and marked
<a class="reference external" href="Traits.md/#isolatedfromabove"><code class="docutils literal notranslate"><span class="pre">IsolatedFromAbove</span></code></a>.</p>
<ul>
<li><p>Passes are expected not to modify operations at or above the current
operation being processed. If the operation is not isolated, it may
inadvertently modify or traverse the SSA use-list of an operation it is
not supposed to.</p></li>
</ul>
</li>
</ul>
<p>Passes can be added to a pass manager via <code class="docutils literal notranslate"><span class="pre">addPass</span></code>.</p>
<p>An <code class="docutils literal notranslate"><span class="pre">OpPassManager</span></code> is generally created by explicitly nesting a pipeline within
another existing <code class="docutils literal notranslate"><span class="pre">OpPassManager</span></code> via the <code class="docutils literal notranslate"><span class="pre">nest&lt;OpT&gt;</span></code> or <code class="docutils literal notranslate"><span class="pre">nestAny</span></code> methods. The
former method takes the operation type that the nested pass manager will operate on.
The latter method nests an <code class="docutils literal notranslate"><span class="pre">op-agnostic</span></code> pass manager, that may run on any viable
operation type. Nesting in this sense, corresponds to the
<a class="reference internal" href="Tutorials/UnderstandingTheIRStructure.html"><span class="doc">structural</span></a> nesting within
<a class="reference external" href="LangRef.md/#regions">Regions</a> of the IR.</p>
<p>For example, the following <code class="docutils literal notranslate"><span class="pre">.mlir</span></code>:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>module {
  spirv.module &quot;Logical&quot; &quot;GLSL450&quot; {
    func @foo() {
      ...
    }
  }
}
</pre></div>
</div>
<p>Has the nesting structure of:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>`builtin.module`
  `spirv.module`
    `spirv.func`
</pre></div>
</div>
<p>Below is an example of constructing a pipeline that operates on the above
structure:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Create a top-level `PassManager` class.</span>
<span class="k">auto</span><span class="w"> </span><span class="n">pm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PassManager</span><span class="o">::</span><span class="n">on</span><span class="o">&lt;</span><span class="n">ModuleOp</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

<span class="c1">// Add a pass on the top-level module operation.</span>
<span class="n">pm</span><span class="p">.</span><span class="n">addPass</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">MyModulePass</span><span class="o">&gt;</span><span class="p">());</span>

<span class="c1">// Nest a pass manager that operates on `spirv.module` operations nested</span>
<span class="c1">// directly under the top-level module.</span>
<span class="n">OpPassManager</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nestedModulePM</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pm</span><span class="p">.</span><span class="n">nest</span><span class="o">&lt;</span><span class="n">spirv</span><span class="o">::</span><span class="n">ModuleOp</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">nestedModulePM</span><span class="p">.</span><span class="n">addPass</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">MySPIRVModulePass</span><span class="o">&gt;</span><span class="p">());</span>

<span class="c1">// Nest a pass manager that operates on functions within the nested SPIRV</span>
<span class="c1">// module.</span>
<span class="n">OpPassManager</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nestedFunctionPM</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nestedModulePM</span><span class="p">.</span><span class="n">nest</span><span class="o">&lt;</span><span class="n">func</span><span class="o">::</span><span class="n">FuncOp</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">nestedFunctionPM</span><span class="p">.</span><span class="n">addPass</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">MyFunctionPass</span><span class="o">&gt;</span><span class="p">());</span>

<span class="c1">// Nest an op-agnostic pass manager. This will operate on any viable</span>
<span class="c1">// operation, e.g. func.func, spirv.func, spirv.module, builtin.module, etc.</span>
<span class="n">OpPassManager</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nestedAnyPM</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nestedModulePM</span><span class="p">.</span><span class="n">nestAny</span><span class="p">();</span>
<span class="n">nestedAnyPM</span><span class="p">.</span><span class="n">addPass</span><span class="p">(</span><span class="n">createCanonicalizePass</span><span class="p">());</span>
<span class="n">nestedAnyPM</span><span class="p">.</span><span class="n">addPass</span><span class="p">(</span><span class="n">createCSEPass</span><span class="p">());</span>

<span class="c1">// Run the pass manager on the top-level module.</span>
<span class="n">ModuleOp</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">failed</span><span class="p">(</span><span class="n">pm</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">m</span><span class="p">)))</span>
<span class="w">    </span><span class="p">...</span><span class="w"> </span><span class="c1">// One of the passes signaled a failure.</span>
</pre></div>
</div>
<p>The above pass manager contains the following pipeline structure:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">OpPassManager</span><span class="o">&lt;</span><span class="n">ModuleOp</span><span class="o">&gt;</span>
  <span class="n">MyModulePass</span>
  <span class="n">OpPassManager</span><span class="o">&lt;</span><span class="n">spirv</span><span class="p">::</span><span class="n">ModuleOp</span><span class="o">&gt;</span>
    <span class="n">MySPIRVModulePass</span>
    <span class="n">OpPassManager</span><span class="o">&lt;</span><span class="n">func</span><span class="p">::</span><span class="n">FuncOp</span><span class="o">&gt;</span>
      <span class="n">MyFunctionPass</span>
    <span class="n">OpPassManager</span><span class="o">&lt;&gt;</span>
      <span class="n">Canonicalizer</span>
      <span class="n">CSE</span>
</pre></div>
</div>
<p>These pipelines are then run over a single operation at a time. This means that,
for example, given a series of consecutive passes on func::FuncOp, it will execute all
on the first function, then all on the second function, etc. until the entire
program has been run through the passes. This provides several benefits:</p>
<ul class="simple">
<li><p>This improves the cache behavior of the compiler, because it is only
touching a single function at a time, instead of traversing the entire
program.</p></li>
<li><p>This improves multi-threading performance by reducing the number of jobs
that need to be scheduled, as well as increasing the efficiency of each job.
An entire function pipeline can be run on each function asynchronously.</p></li>
</ul>
</section>
</section>
<section id="dynamic-pass-pipelines">
<h2>Dynamic Pass Pipelines<a class="headerlink" href="#dynamic-pass-pipelines" title="此标题的永久链接">¶</a></h2>
<p>In some situations it may be useful to run a pass pipeline within another pass,
to allow configuring or filtering based on some invariants of the current
operation being operated on. For example, the
<a class="reference external" href="Passes.md/#-inline-inline-function-calls">Inliner Pass</a> may want to run
intraprocedural simplification passes while it is inlining to produce a better
cost model, and provide more optimal inlining. To enable this, passes may run an
arbitrary <code class="docutils literal notranslate"><span class="pre">OpPassManager</span></code> on the current operation being operated on or any
operation nested within the current operation via the <code class="docutils literal notranslate"><span class="pre">LogicalResult</span> <span class="pre">Pass::runPipeline(OpPassManager</span> <span class="pre">&amp;,</span> <span class="pre">Operation</span> <span class="pre">*)</span></code> method. This method returns
whether the dynamic pipeline succeeded or failed, similarly to the result of the
top-level <code class="docutils literal notranslate"><span class="pre">PassManager::run</span></code> method. A simple example is shown below:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">MyModulePass::runOnOperation</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">ModuleOp</span><span class="w"> </span><span class="k">module</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getOperation</span><span class="p">();</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">hasSomeSpecificProperty</span><span class="p">(</span><span class="k">module</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">OpPassManager</span><span class="w"> </span><span class="n">dynamicPM</span><span class="p">(</span><span class="s">&quot;builtin.module&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">...;</span><span class="w"> </span><span class="c1">// Build the dynamic pipeline.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">failed</span><span class="p">(</span><span class="n">runPipeline</span><span class="p">(</span><span class="n">dynamicPM</span><span class="p">,</span><span class="w"> </span><span class="k">module</span><span class="p">)))</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">signalPassFailure</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note: though above the dynamic pipeline was constructed within the
<code class="docutils literal notranslate"><span class="pre">runOnOperation</span></code> method, this is not necessary and pipelines should be cached
when possible as the <code class="docutils literal notranslate"><span class="pre">OpPassManager</span></code> class can be safely copy constructed.</p>
<p>The mechanism described in this section should be used whenever a pass pipeline
should run in a nested fashion, i.e. when the nested pipeline cannot be
scheduled statically along with the rest of the main pass pipeline. More
specifically, a <code class="docutils literal notranslate"><span class="pre">PassManager</span></code> should generally never need to be constructed
within a <code class="docutils literal notranslate"><span class="pre">Pass</span></code>. Using <code class="docutils literal notranslate"><span class="pre">runPipeline</span></code> also ensures that all analyses,
<a class="reference external" href="#pass-instrumentation">instrumentations</a>, and other pass manager related
components are integrated with the dynamic pipeline being executed.</p>
</section>
<section id="instance-specific-pass-options">
<h2>Instance Specific Pass Options<a class="headerlink" href="#instance-specific-pass-options" title="此标题的永久链接">¶</a></h2>
<p>MLIR provides a builtin mechanism for passes to specify options that configure
its behavior. These options are parsed at pass construction time independently
for each instance of the pass. Options are defined using the <code class="docutils literal notranslate"><span class="pre">Option&lt;&gt;</span></code> and
<code class="docutils literal notranslate"><span class="pre">ListOption&lt;&gt;</span></code> classes, and generally follow the
<a class="reference external" href="https://llvm.org/docs/CommandLine.html">LLVM command line</a> flag definition
rules. One major distinction from the LLVM command line functionality is that
all <code class="docutils literal notranslate"><span class="pre">ListOption</span></code>s are comma-separated, and delimited sub-ranges within individual
elements of the list may contain commas that are not treated as separators for the
top-level list.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">MyPass</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">/// Make sure that we have a valid default constructor and copy constructor to</span>
<span class="w">  </span><span class="c1">/// ensure that the options are initialized properly.</span>
<span class="w">  </span><span class="n">MyPass</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>
<span class="w">  </span><span class="n">MyPass</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">MyPass</span><span class="o">&amp;</span><span class="w"> </span><span class="n">pass</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>

<span class="w">  </span><span class="c1">/// Any parameters after the description are forwarded to llvm::cl::list and</span>
<span class="w">  </span><span class="c1">/// llvm::cl::opt respectively.</span>
<span class="w">  </span><span class="n">Option</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">exampleOption</span><span class="p">{</span><span class="o">*</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;flag-name&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;...&quot;</span><span class="p">)};</span>
<span class="w">  </span><span class="n">ListOption</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">exampleListOption</span><span class="p">{</span><span class="o">*</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;list-flag-name&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;...&quot;</span><span class="p">)};</span>
<span class="p">};</span>
</pre></div>
</div>
<p>For pass pipelines, the <code class="docutils literal notranslate"><span class="pre">PassPipelineRegistration</span></code> templates take an additional
template parameter for an optional <code class="docutils literal notranslate"><span class="pre">Option</span></code> struct definition. This struct
should inherit from <code class="docutils literal notranslate"><span class="pre">mlir::PassPipelineOptions</span></code> and contain the desired pipeline
options. When using <code class="docutils literal notranslate"><span class="pre">PassPipelineRegistration</span></code>, the constructor now takes a
function with the signature <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(OpPassManager</span> <span class="pre">&amp;pm,</span> <span class="pre">const</span> <span class="pre">MyPipelineOptions&amp;)</span></code>
which should construct the passes from the options and pass them to the pm:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">MyPipelineOptions</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">PassPipelineOptions</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// The structure of these options is the same as those for pass options.</span>
<span class="w">  </span><span class="n">Option</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">exampleOption</span><span class="p">{</span><span class="o">*</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;flag-name&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;...&quot;</span><span class="p">)};</span>
<span class="w">  </span><span class="n">ListOption</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">exampleListOption</span><span class="p">{</span><span class="o">*</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;list-flag-name&quot;</span><span class="p">,</span>
<span class="w">                                    </span><span class="n">llvm</span><span class="o">::</span><span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;...&quot;</span><span class="p">)};</span>
<span class="p">};</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">registerMyPasses</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">PassPipelineRegistration</span><span class="o">&lt;</span><span class="n">MyPipelineOptions</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">    </span><span class="s">&quot;example-pipeline&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Run an example pipeline.&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">[](</span><span class="n">OpPassManager</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pm</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">MyPipelineOptions</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pipelineOptions</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// Initialize the pass manager.</span>
<span class="w">    </span><span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="pass-statistics">
<h2>Pass Statistics<a class="headerlink" href="#pass-statistics" title="此标题的永久链接">¶</a></h2>
<p>Statistics are a way to keep track of what the compiler is doing and how
effective various transformations are. It is often useful to see what effect
specific transformations have on a particular input, and how often they trigger.
Pass statistics are specific to each pass instance, which allow for seeing the
effect of placing a particular transformation at specific places within the pass
pipeline. For example, they help answer questions like “What happens if I run
CSE again here?”.</p>
<p>Statistics can be added to a pass by using the ‘Pass::Statistic’ class. This
class takes as a constructor arguments: the parent pass, a name, and a
description. This class acts like an atomic unsigned integer, and may be
incremented and updated accordingly. These statistics rely on the same
infrastructure as
<a class="reference external" href="http://llvm.org/docs/ProgrammersManual.html#the-statistic-class-stats-option"><code class="docutils literal notranslate"><span class="pre">llvm::Statistic</span></code></a>
and thus have similar usage constraints. Collected statistics can be dumped by
the <a class="reference external" href="#pass-manager">pass manager</a> programmatically via
<code class="docutils literal notranslate"><span class="pre">PassManager::enableStatistics</span></code>; or via <code class="docutils literal notranslate"><span class="pre">-mlir-pass-statistics</span></code> and
<code class="docutils literal notranslate"><span class="pre">-mlir-pass-statistics-display</span></code> on the command line.</p>
<p>An example is shown below:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">MyPass</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">/// Make sure that we have a valid default constructor and copy constructor to</span>
<span class="w">  </span><span class="c1">/// ensure that the options are initialized properly.</span>
<span class="w">  </span><span class="n">MyPass</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>
<span class="w">  </span><span class="n">MyPass</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">MyPass</span><span class="o">&amp;</span><span class="w"> </span><span class="n">pass</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="w">  </span><span class="n">StringRef</span><span class="w"> </span><span class="n">getArgument</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">final</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// This is the argument used to refer to the pass in</span>
<span class="w">    </span><span class="c1">// the textual format (on the commandline for example).</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;argument&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">StringRef</span><span class="w"> </span><span class="n">getDescription</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">final</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// This is a brief description of the pass.</span>
<span class="w">    </span><span class="k">return</span><span class="w">  </span><span class="s">&quot;description&quot;</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">/// Define the statistic to track during the execution of MyPass.</span>
<span class="w">  </span><span class="n">Statistic</span><span class="w"> </span><span class="n">exampleStat</span><span class="p">{</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;exampleStat&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;An example statistic&quot;</span><span class="p">};</span>

<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="nf">runOnOperation</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>

<span class="w">    </span><span class="c1">// Update the statistic after some invariant was hit.</span>
<span class="w">    </span><span class="o">++</span><span class="n">exampleStat</span><span class="p">;</span>

<span class="w">    </span><span class="p">...</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The collected statistics may be aggregated in two types of views:</p>
<p>A pipeline view that models the structure of the pass manager, this is the
default view:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>mlir-opt<span class="w"> </span>-pass-pipeline<span class="o">=</span><span class="s1">&#39;any(func.func(my-pass,my-pass))&#39;</span><span class="w"> </span>foo.mlir<span class="w"> </span>-mlir-pass-statistics

<span class="o">===</span>-------------------------------------------------------------------------<span class="o">===</span>
<span class="w">                         </span>...<span class="w"> </span>Pass<span class="w"> </span>statistics<span class="w"> </span>report<span class="w"> </span>...
<span class="o">===</span>-------------------------------------------------------------------------<span class="o">===</span>
<span class="s1">&#39;func.func&#39;</span><span class="w"> </span>Pipeline
<span class="w">  </span>MyPass
<span class="w">    </span><span class="o">(</span>S<span class="o">)</span><span class="w"> </span><span class="m">15</span><span class="w"> </span>exampleStat<span class="w"> </span>-<span class="w"> </span>An<span class="w"> </span>example<span class="w"> </span>statistic
<span class="w">  </span>VerifierPass
<span class="w">  </span>MyPass
<span class="w">    </span><span class="o">(</span>S<span class="o">)</span><span class="w">  </span><span class="m">6</span><span class="w"> </span>exampleStat<span class="w"> </span>-<span class="w"> </span>An<span class="w"> </span>example<span class="w"> </span>statistic
<span class="w">  </span>VerifierPass
VerifierPass
</pre></div>
</div>
<p>A list view that aggregates the statistics of all instances of a specific pass
together:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>mlir-opt<span class="w"> </span>-pass-pipeline<span class="o">=</span><span class="s1">&#39;any(func.func(my-pass,my-pass))&#39;</span><span class="w"> </span>foo.mlir<span class="w"> </span>-mlir-pass-statistics<span class="w"> </span>-mlir-pass-statistics-display<span class="o">=</span><span class="nv">list</span>

<span class="o">===</span>-------------------------------------------------------------------------<span class="o">===</span>
<span class="w">                         </span>...<span class="w"> </span>Pass<span class="w"> </span>statistics<span class="w"> </span>report<span class="w"> </span>...
<span class="o">===</span>-------------------------------------------------------------------------<span class="o">===</span>
MyPass
<span class="w">  </span><span class="o">(</span>S<span class="o">)</span><span class="w"> </span><span class="m">21</span><span class="w"> </span>exampleStat<span class="w"> </span>-<span class="w"> </span>An<span class="w"> </span>example<span class="w"> </span>statistic
</pre></div>
</div>
</section>
<section id="pass-registration">
<h2>Pass Registration<a class="headerlink" href="#pass-registration" title="此标题的永久链接">¶</a></h2>
<p>Briefly shown in the example definitions of the various pass types is the
<code class="docutils literal notranslate"><span class="pre">PassRegistration</span></code> class. This mechanism allows for registering pass classes so
that they may be created within a
<a class="reference external" href="#textual-pass-pipeline-specification">textual pass pipeline description</a>. An
example registration is shown below:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">registerMyPass</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">PassRegistration</span><span class="o">&lt;</span><span class="n">MyPass</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">MyPass</span></code> is the name of the derived pass class.</p></li>
<li><p>The pass <code class="docutils literal notranslate"><span class="pre">getArgument()</span></code> method is used to get the identifier that will be
used to refer to the pass.</p></li>
<li><p>The pass <code class="docutils literal notranslate"><span class="pre">getDescription()</span></code> method provides a short summary describing the
pass.</p></li>
</ul>
<p>For passes that cannot be default-constructed, <code class="docutils literal notranslate"><span class="pre">PassRegistration</span></code> accepts an
optional argument that takes a callback to create the pass:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">registerMyPass</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">PassRegistration</span><span class="o">&lt;</span><span class="n">MyParametricPass</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">    </span><span class="p">[]()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Pass</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Pass</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">MyParametricPass</span><span class="o">&gt;</span><span class="p">(</span><span class="cm">/*options*/</span><span class="p">);</span>
<span class="w">      </span><span class="cm">/*... non-trivial-logic to configure the pass ...*/</span><span class="p">;</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="w">    </span><span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This variant of registration can be used, for example, to accept the
configuration of a pass from command-line arguments and pass it to the pass
constructor.</p>
<p>Note: Make sure that the pass is copy-constructible in a way that does not share
data as the <a class="reference external" href="#pass-manager">pass manager</a> may create copies of the pass to run
in parallel.</p>
<section id="pass-pipeline-registration">
<h3>Pass Pipeline Registration<a class="headerlink" href="#pass-pipeline-registration" title="此标题的永久链接">¶</a></h3>
<p>Described above is the mechanism used for registering a specific derived pass
class. On top of that, MLIR allows for registering custom pass pipelines in a
similar fashion. This allows for custom pipelines to be available to tools like
mlir-opt in the same way that passes are, which is useful for encapsulating
common pipelines like the “-O1” series of passes. Pipelines are registered via a
similar mechanism to passes in the form of <code class="docutils literal notranslate"><span class="pre">PassPipelineRegistration</span></code>. Compared
to <code class="docutils literal notranslate"><span class="pre">PassRegistration</span></code>, this class takes an additional parameter in the form of a
pipeline builder that modifies a provided <code class="docutils literal notranslate"><span class="pre">OpPassManager</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">pipelineBuilder</span><span class="p">(</span><span class="n">OpPassManager</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pm</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">pm</span><span class="p">.</span><span class="n">addPass</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">MyPass</span><span class="o">&gt;</span><span class="p">());</span>
<span class="w">  </span><span class="n">pm</span><span class="p">.</span><span class="n">addPass</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">MyOtherPass</span><span class="o">&gt;</span><span class="p">());</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">registerMyPasses</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Register an existing pipeline builder function.</span>
<span class="w">  </span><span class="n">PassPipelineRegistration</span><span class="o">&lt;&gt;</span><span class="p">(</span>
<span class="w">    </span><span class="s">&quot;argument&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;description&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">pipelineBuilder</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Register an inline pipeline builder.</span>
<span class="w">  </span><span class="n">PassPipelineRegistration</span><span class="o">&lt;&gt;</span><span class="p">(</span>
<span class="w">    </span><span class="s">&quot;argument&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;description&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[](</span><span class="n">OpPassManager</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pm</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">pm</span><span class="p">.</span><span class="n">addPass</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">MyPass</span><span class="o">&gt;</span><span class="p">());</span>
<span class="w">      </span><span class="n">pm</span><span class="p">.</span><span class="n">addPass</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">MyOtherPass</span><span class="o">&gt;</span><span class="p">());</span>
<span class="w">    </span><span class="p">});</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="textual-pass-pipeline-specification">
<h3>Textual Pass Pipeline Specification<a class="headerlink" href="#textual-pass-pipeline-specification" title="此标题的永久链接">¶</a></h3>
<p>The previous sections detailed how to register passes and pass pipelines with a
specific argument and description. Once registered, these can be used to
configure a pass manager from a string description. This is especially useful
for tools like <code class="docutils literal notranslate"><span class="pre">mlir-opt</span></code>, that configure pass managers from the command line,
or as options to passes that utilize
<a class="reference external" href="#dynamic-pass-pipelines">dynamic pass pipelines</a>.</p>
<p>To support the ability to describe the full structure of pass pipelines, MLIR
supports a custom textual description of pass pipelines. The textual description
includes the nesting structure, the arguments of the passes and pass pipelines
to run, and any options for those passes and pipelines. A textual pipeline is
defined as a series of names, each of which may in itself recursively contain a
nested pipeline description. The syntax for this specification is as follows:</p>
<div class="highlight-ebnf notranslate"><div class="highlight"><pre><span></span>pipeline          ::= op-anchor `(` pipeline-element (`,` pipeline-element)* `)`
pipeline-element  ::= pipeline | (pass-name | pass-pipeline-name) options?
options           ::= &#39;{&#39; (key (&#39;=&#39; value)?)+ &#39;}&#39;
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">op-anchor</span></code></p>
<ul>
<li><p>This corresponds to the mnemonic name that anchors the execution of the
pass manager. This is either the name of an operation to run passes on,
e.g. <code class="docutils literal notranslate"><span class="pre">func.func</span></code> or <code class="docutils literal notranslate"><span class="pre">builtin.module</span></code>, or <code class="docutils literal notranslate"><span class="pre">any</span></code>, for op-agnostic pass
managers that execute on any viable operation (i.e. any operation that
can be used to anchor a pass manager).</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">pass-name</span></code> | <code class="docutils literal notranslate"><span class="pre">pass-pipeline-name</span></code></p>
<ul>
<li><p>This corresponds to the argument of a registered pass or pass pipeline,
e.g. <code class="docutils literal notranslate"><span class="pre">cse</span></code> or <code class="docutils literal notranslate"><span class="pre">canonicalize</span></code>.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">options</span></code></p>
<ul>
<li><p>Options are specific key value pairs representing options defined by a
pass or pass pipeline, as described in the
<a class="reference external" href="#instance-specific-pass-options">“Instance Specific Pass Options”</a>
section. See this section for an example usage in a textual pipeline.</p></li>
</ul>
</li>
</ul>
<p>For example, the following pipeline:</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>mlir-opt<span class="w"> </span>foo.mlir<span class="w"> </span>-cse<span class="w"> </span>-canonicalize<span class="w"> </span>-convert-func-to-llvm<span class="o">=</span><span class="s1">&#39;use-bare-ptr-memref-call-conv=1&#39;</span>
</pre></div>
</div>
<p>Can also be specified as (via the <code class="docutils literal notranslate"><span class="pre">-pass-pipeline</span></code> flag):</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span><span class="c1"># Anchor the cse and canonicalize passes on the `func.func` operation.</span>
$<span class="w"> </span>mlir-opt<span class="w"> </span>foo.mlir<span class="w"> </span>-pass-pipeline<span class="o">=</span><span class="s1">&#39;builtin.module(func.func(cse,canonicalize),convert-func-to-llvm{use-bare-ptr-memref-call-conv=1})&#39;</span>

<span class="c1"># Anchor the cse and canonicalize passes on &quot;any&quot; viable root operation.</span>
$<span class="w"> </span>mlir-opt<span class="w"> </span>foo.mlir<span class="w"> </span>-pass-pipeline<span class="o">=</span><span class="s1">&#39;builtin.module(any(cse,canonicalize),convert-func-to-llvm{use-bare-ptr-memref-call-conv=1})&#39;</span>
</pre></div>
</div>
<p>In order to support round-tripping a pass to the textual representation using
<code class="docutils literal notranslate"><span class="pre">OpPassManager::printAsTextualPipeline(raw_ostream&amp;)</span></code>, override <code class="docutils literal notranslate"><span class="pre">StringRef</span> <span class="pre">Pass::getArgument()</span></code> to specify the argument used when registering a pass.</p>
</section>
</section>
<section id="declarative-pass-specification">
<h2>Declarative Pass Specification<a class="headerlink" href="#declarative-pass-specification" title="此标题的永久链接">¶</a></h2>
<p>Some aspects of a Pass may be specified declaratively, in a form similar to
<a class="reference internal" href="DefiningDialects/Operations.html"><span class="doc">operations</span></a>. This specification simplifies several mechanisms
used when defining passes. It can be used for generating pass registration
calls, defining boilerplate pass utilities, and generating pass documentation.</p>
<p>Consider the following pass specified in C++:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">MyPass</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">PassWrapper</span><span class="o">&lt;</span><span class="n">MyPass</span><span class="p">,</span><span class="w"> </span><span class="n">OperationPass</span><span class="o">&lt;</span><span class="n">ModuleOp</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">MyPass</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>
<span class="w">  </span><span class="n">MyPass</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">MyPass</span><span class="w"> </span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>

<span class="w">  </span><span class="p">...</span>

<span class="w">  </span><span class="c1">// Specify any options.</span>
<span class="w">  </span><span class="n">Option</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="w"> </span><span class="n">option</span><span class="p">{</span>
<span class="w">      </span><span class="o">*</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;example-option&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="n">llvm</span><span class="o">::</span><span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;An example option&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">llvm</span><span class="o">::</span><span class="n">cl</span><span class="o">::</span><span class="n">init</span><span class="p">(</span><span class="nb">true</span><span class="p">)};</span>
<span class="w">  </span><span class="n">ListOption</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">listOption</span><span class="p">{</span>
<span class="w">      </span><span class="o">*</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;example-list&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="n">llvm</span><span class="o">::</span><span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;An example list option&quot;</span><span class="p">)};</span>

<span class="w">  </span><span class="c1">// Specify any statistics.</span>
<span class="w">  </span><span class="n">Statistic</span><span class="w"> </span><span class="n">statistic</span><span class="p">{</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;example-statistic&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;An example statistic&quot;</span><span class="p">};</span>
<span class="p">};</span>

<span class="c1">/// Expose this pass to the outside world.</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Pass</span><span class="o">&gt;</span><span class="w"> </span><span class="n">foo</span><span class="o">::</span><span class="n">createMyPass</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">MyPass</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">/// Register this pass.</span>
<span class="kt">void</span><span class="w"> </span><span class="n">foo</span><span class="o">::</span><span class="n">registerMyPass</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">PassRegistration</span><span class="o">&lt;</span><span class="n">MyPass</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This pass may be specified declaratively as so:</p>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def MyPass : Pass&lt;&quot;my-pass&quot;, &quot;ModuleOp&quot;&gt; {
  let summary = &quot;My Pass Summary&quot;;
  let description = [{
    Here we can now give a much larger description of `MyPass`, including all of
    its various constraints and behavior.
  }];

  // A constructor must be provided to specify how to create a default instance
  // of MyPass. It can be skipped for this specific example, because both the
  // constructor and the registration methods live in the same namespace.
  let constructor = &quot;foo::createMyPass()&quot;;

  // Specify any options.
  let options = [
    Option&lt;&quot;option&quot;, &quot;example-option&quot;, &quot;bool&quot;, /*default=*/&quot;true&quot;,
           &quot;An example option&quot;&gt;,
    ListOption&lt;&quot;listOption&quot;, &quot;example-list&quot;, &quot;int64_t&quot;,
               &quot;An example list option&quot;&gt;
  ];

  // Specify any statistics.
  let statistics = [
    Statistic&lt;&quot;statistic&quot;, &quot;example-statistic&quot;, &quot;An example statistic&quot;&gt;
  ];
}
</pre></div>
</div>
<p>Using the <code class="docutils literal notranslate"><span class="pre">gen-pass-decls</span></code> generator, we can generate most of the boilerplate
above automatically. This generator takes as an input a <code class="docutils literal notranslate"><span class="pre">-name</span></code> parameter, that
provides a tag for the group of passes that are being generated. This generator
produces code with multiple purposes:</p>
<p>The first is to register the declared passes with the global registry. For
each pass, the generator produces a <code class="docutils literal notranslate"><span class="pre">registerPassName</span></code> where
<code class="docutils literal notranslate"><span class="pre">PassName</span></code> is the name of the definition specified in tablegen. It also
generates a <code class="docutils literal notranslate"><span class="pre">registerGroupPasses</span></code>, where <code class="docutils literal notranslate"><span class="pre">Group</span></code> is the tag provided via the
<code class="docutils literal notranslate"><span class="pre">-name</span></code> input parameter, that registers all of the passes present.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Tablegen options: -gen-pass-decls -name=&quot;Example&quot;</span>

<span class="c1">// Passes.h</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">foo</span><span class="w"> </span><span class="p">{</span>
<span class="cp">#define GEN_PASS_REGISTRATION</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;Passes.h.inc&quot;</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// namespace foo</span>

<span class="kt">void</span><span class="w"> </span><span class="n">registerMyPasses</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// Register all of the passes.</span>
<span class="w">  </span><span class="n">foo</span><span class="o">::</span><span class="n">registerExamplePasses</span><span class="p">();</span>
<span class="w">  </span>
<span class="w">  </span><span class="c1">// Or</span>

<span class="w">  </span><span class="c1">// Register `MyPass` specifically.</span>
<span class="w">  </span><span class="n">foo</span><span class="o">::</span><span class="n">registerMyPass</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The second is to provide a way to configure the pass options. These classes are
named in the form of <code class="docutils literal notranslate"><span class="pre">MyPassOptions</span></code>, where <code class="docutils literal notranslate"><span class="pre">MyPass</span></code> is the name of the pass
definition in tablegen. The configurable parameters reflect the options declared
in the tablegen file. These declarations can be enabled for the whole group of
passes by defining the <code class="docutils literal notranslate"><span class="pre">GEN_PASS_DECL</span></code> macro, or on a per-pass basis by defining
<code class="docutils literal notranslate"><span class="pre">GEN_PASS_DECL_PASSNAME</span></code> where <code class="docutils literal notranslate"><span class="pre">PASSNAME</span></code> is the uppercase version of the name
specified in tablegen.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// .h.inc</span>

<span class="cp">#ifdef GEN_PASS_DECL_MYPASS</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">MyPassOptions</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">option</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="o">::</span><span class="n">llvm</span><span class="o">::</span><span class="n">ArrayRef</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">listOption</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#undef GEN_PASS_DECL_MYPASS</span>
<span class="cp">#endif </span><span class="c1">// GEN_PASS_DECL_MYPASS</span>
</pre></div>
</div>
<p>If the <code class="docutils literal notranslate"><span class="pre">constructor</span></code> field has not been specified in the tablegen declaration,
then autogenerated file will also contain the declarations of the default
constructors.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// .h.inc</span>

<span class="cp">#ifdef GEN_PASS_DECL_MYPASS</span>
<span class="p">...</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;::</span><span class="n">mlir</span><span class="o">::</span><span class="n">Pass</span><span class="o">&gt;</span><span class="w"> </span><span class="n">createMyPass</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;::</span><span class="n">mlir</span><span class="o">::</span><span class="n">Pass</span><span class="o">&gt;</span><span class="w"> </span><span class="n">createMyPass</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">MyPassOptions</span><span class="w"> </span><span class="o">&amp;</span><span class="n">options</span><span class="p">);</span>

<span class="cp">#undef GEN_PASS_DECL_MYPASS</span>
<span class="cp">#endif </span><span class="c1">// GEN_PASS_DECL_MYPASS</span>
</pre></div>
</div>
<p>The last purpose of this generator is to emit a base class for each of the
passes, containing most of the boiler plate related to pass definitions. These
classes are named in the form of <code class="docutils literal notranslate"><span class="pre">MyPassBase</span></code> and are declared inside the
<code class="docutils literal notranslate"><span class="pre">impl</span></code> namespace, where <code class="docutils literal notranslate"><span class="pre">MyPass</span></code> is the name of the pass definition in
tablegen. We can update the original C++ pass definition as so:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// MyPass.cpp</span>

<span class="c1">/// Include the generated base pass class definitions.</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">foo</span><span class="w"> </span><span class="p">{</span>
<span class="cp">#define GEN_PASS_DEF_MYPASS</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;Passes.h.inc&quot;</span>
<span class="p">}</span>

<span class="c1">/// Define the main class as deriving from the generated base class.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">MyPass</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">foo</span><span class="o">::</span><span class="n">impl</span><span class="o">::</span><span class="n">MyPassBase</span><span class="o">&lt;</span><span class="n">MyPass</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">using</span><span class="w"> </span><span class="n">MyPassBase</span><span class="o">::</span><span class="n">MyPassBase</span><span class="p">;</span>

<span class="w">  </span><span class="c1">/// The definitions of the options and statistics are now generated within</span>
<span class="w">  </span><span class="c1">/// the base class, but are accessible in the same way.</span>
<span class="p">};</span>
</pre></div>
</div>
<p>These definitions can be enabled on a per-pass basis by defining the appropriate
preprocessor <code class="docutils literal notranslate"><span class="pre">GEN_PASS_DEF_PASSNAME</span></code> macro, with <code class="docutils literal notranslate"><span class="pre">PASSNAME</span></code> equal to the
uppercase version of the name of the pass definition in tablegen.
If the <code class="docutils literal notranslate"><span class="pre">constructor</span></code> field has not been specified in tablegen, then the default
constructors are also defined and expect the name of the actual pass class to
be equal to the name defined in tablegen.</p>
<p>Using the <code class="docutils literal notranslate"><span class="pre">gen-pass-doc</span></code> generator, markdown documentation for each of the
passes can be generated. See <a class="reference internal" href="Passes.html"><span class="doc">Passes.md</span></a> for example output of real
MLIR passes.</p>
<section id="tablegen-specification">
<h3>Tablegen Specification<a class="headerlink" href="#tablegen-specification" title="此标题的永久链接">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">Pass</span></code> class is used to begin a new pass definition. This class takes as an
argument the registry argument to attribute to the pass, as well as an optional
string corresponding to the operation type that the pass operates on. The class
contains the following fields:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">summary</span></code></p>
<ul>
<li><p>A short one-line summary of the pass, used as the description when
registering the pass.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">description</span></code></p>
<ul>
<li><p>A longer, more detailed description of the pass. This is used when
generating pass documentation.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">dependentDialects</span></code></p>
<ul>
<li><p>A list of strings representing the <code class="docutils literal notranslate"><span class="pre">Dialect</span></code> classes this pass may
introduce entities, Attributes/Operations/Types/etc., of.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">constructor</span></code></p>
<ul>
<li><p>A code block used to create a default instance of the pass.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">options</span></code></p>
<ul>
<li><p>A list of pass options used by the pass.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">statistics</span></code></p>
<ul>
<li><p>A list of pass statistics used by the pass.</p></li>
</ul>
</li>
</ul>
<section id="options">
<h4>Options<a class="headerlink" href="#options" title="此标题的永久链接">¶</a></h4>
<p>Options may be specified via the <code class="docutils literal notranslate"><span class="pre">Option</span></code> and <code class="docutils literal notranslate"><span class="pre">ListOption</span></code> classes. The <code class="docutils literal notranslate"><span class="pre">Option</span></code>
class takes the following template parameters:</p>
<ul class="simple">
<li><p>C++ variable name</p>
<ul>
<li><p>A name to use for the generated option variable.</p></li>
</ul>
</li>
<li><p>argument</p>
<ul>
<li><p>The argument name of the option.</p></li>
</ul>
</li>
<li><p>type</p>
<ul>
<li><p>The C++ type of the option.</p></li>
</ul>
</li>
<li><p>default value</p>
<ul>
<li><p>The default option value.</p></li>
</ul>
</li>
<li><p>description</p>
<ul>
<li><p>A one-line description of the option.</p></li>
</ul>
</li>
<li><p>additional option flags</p>
<ul>
<li><p>A string containing any additional options necessary to construct the
option.</p></li>
</ul>
</li>
</ul>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def MyPass : Pass&lt;&quot;my-pass&quot;&gt; {
  let options = [
    Option&lt;&quot;option&quot;, &quot;example-option&quot;, &quot;bool&quot;, /*default=*/&quot;true&quot;,
           &quot;An example option&quot;&gt;,
  ];
}
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">ListOption</span></code> class takes the following fields:</p>
<ul class="simple">
<li><p>C++ variable name</p>
<ul>
<li><p>A name to use for the generated option variable.</p></li>
</ul>
</li>
<li><p>argument</p>
<ul>
<li><p>The argument name of the option.</p></li>
</ul>
</li>
<li><p>element type</p>
<ul>
<li><p>The C++ type of the list element.</p></li>
</ul>
</li>
<li><p>description</p>
<ul>
<li><p>A one-line description of the option.</p></li>
</ul>
</li>
<li><p>additional option flags</p>
<ul>
<li><p>A string containing any additional options necessary to construct the
option.</p></li>
</ul>
</li>
</ul>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def MyPass : Pass&lt;&quot;my-pass&quot;&gt; {
  let options = [
    ListOption&lt;&quot;listOption&quot;, &quot;example-list&quot;, &quot;int64_t&quot;,
               &quot;An example list option&quot;&gt;
  ];
}
</pre></div>
</div>
</section>
<section id="statistic">
<h4>Statistic<a class="headerlink" href="#statistic" title="此标题的永久链接">¶</a></h4>
<p>Statistics may be specified via the <code class="docutils literal notranslate"><span class="pre">Statistic</span></code>, which takes the following
template parameters:</p>
<ul class="simple">
<li><p>C++ variable name</p>
<ul>
<li><p>A name to use for the generated statistic variable.</p></li>
</ul>
</li>
<li><p>display name</p>
<ul>
<li><p>The name used when displaying the statistic.</p></li>
</ul>
</li>
<li><p>description</p>
<ul>
<li><p>A one-line description of the statistic.</p></li>
</ul>
</li>
</ul>
<div class="highlight-tablegen notranslate"><div class="highlight"><pre><span></span>def MyPass : Pass&lt;&quot;my-pass&quot;&gt; {
  let statistics = [
    Statistic&lt;&quot;statistic&quot;, &quot;example-statistic&quot;, &quot;An example statistic&quot;&gt;
  ];
}
</pre></div>
</div>
</section>
</section>
</section>
<section id="pass-instrumentation">
<h2>Pass Instrumentation<a class="headerlink" href="#pass-instrumentation" title="此标题的永久链接">¶</a></h2>
<p>MLIR provides a customizable framework to instrument pass execution and analysis
computation, via the <code class="docutils literal notranslate"><span class="pre">PassInstrumentation</span></code> class. This class provides hooks into
the PassManager that observe various events:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">runBeforePipeline</span></code></p>
<ul>
<li><p>This callback is run just before a pass pipeline, i.e. pass manager, is
executed.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">runAfterPipeline</span></code></p>
<ul>
<li><p>This callback is run right after a pass pipeline has been executed,
successfully or not.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">runBeforePass</span></code></p>
<ul>
<li><p>This callback is run just before a pass is executed.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">runAfterPass</span></code></p>
<ul>
<li><p>This callback is run right after a pass has been successfully executed.
If this hook is executed, <code class="docutils literal notranslate"><span class="pre">runAfterPassFailed</span></code> will <em>not</em> be.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">runAfterPassFailed</span></code></p>
<ul>
<li><p>This callback is run right after a pass execution fails. If this hook is
executed, <code class="docutils literal notranslate"><span class="pre">runAfterPass</span></code> will <em>not</em> be.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">runBeforeAnalysis</span></code></p>
<ul>
<li><p>This callback is run just before an analysis is computed.</p></li>
<li><p>If the analysis requested another analysis as a dependency, the
<code class="docutils literal notranslate"><span class="pre">runBeforeAnalysis</span></code>/<code class="docutils literal notranslate"><span class="pre">runAfterAnalysis</span></code> pair for the dependency can be
called from inside of the current <code class="docutils literal notranslate"><span class="pre">runBeforeAnalysis</span></code>/<code class="docutils literal notranslate"><span class="pre">runAfterAnalysis</span></code>
pair.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">runAfterAnalysis</span></code></p>
<ul>
<li><p>This callback is run right after an analysis is computed.</p></li>
</ul>
</li>
</ul>
<p>PassInstrumentation instances may be registered directly with a
<a class="reference external" href="#pass-manager">PassManager</a> instance via the <code class="docutils literal notranslate"><span class="pre">addInstrumentation</span></code> method.
Instrumentations added to the PassManager are run in a stack like fashion, i.e.
the last instrumentation to execute a <code class="docutils literal notranslate"><span class="pre">runBefore*</span></code> hook will be the first to
execute the respective <code class="docutils literal notranslate"><span class="pre">runAfter*</span></code> hook. The hooks of a <code class="docutils literal notranslate"><span class="pre">PassInstrumentation</span></code>
class are guaranteed to be executed in a thread-safe fashion, so additional
synchronization is not necessary. Below in an example instrumentation that
counts the number of times the <code class="docutils literal notranslate"><span class="pre">DominanceInfo</span></code> analysis is computed:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">DominanceCounterInstrumentation</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">PassInstrumentation</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">/// The cumulative count of how many times dominance has been calculated.</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="o">&amp;</span><span class="n">count</span><span class="p">;</span>

<span class="w">  </span><span class="n">DominanceCounterInstrumentation</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="o">&amp;</span><span class="n">count</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">count</span><span class="p">(</span><span class="n">count</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="n">runAfterAnalysis</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">StringRef</span><span class="p">,</span><span class="w"> </span><span class="n">TypeID</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">Operation</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">TypeID</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">DominanceInfo</span><span class="o">&gt;</span><span class="p">())</span>
<span class="w">      </span><span class="o">++</span><span class="n">count</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">};</span>

<span class="n">MLIRContext</span><span class="w"> </span><span class="o">*</span><span class="n">ctx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="n">PassManager</span><span class="w"> </span><span class="nf">pm</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>

<span class="c1">// Add the instrumentation to the pass manager.</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="n">domInfoCount</span><span class="p">;</span>
<span class="n">pm</span><span class="p">.</span><span class="n">addInstrumentation</span><span class="p">(</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">DominanceCounterInstrumentation</span><span class="o">&gt;</span><span class="p">(</span><span class="n">domInfoCount</span><span class="p">));</span>

<span class="c1">// Run the pass manager on a module operation.</span>
<span class="n">ModuleOp</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">failed</span><span class="p">(</span><span class="n">pm</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">m</span><span class="p">)))</span>
<span class="w">    </span><span class="p">...</span>

<span class="n">llvm</span><span class="o">::</span><span class="n">errs</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;DominanceInfo was computed &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">domInfoCount</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; times!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</pre></div>
</div>
<section id="standard-instrumentations">
<h3>Standard Instrumentations<a class="headerlink" href="#standard-instrumentations" title="此标题的永久链接">¶</a></h3>
<p>MLIR utilizes the pass instrumentation framework to provide a few useful
developer tools and utilities. Each of these instrumentations are directly
available to all users of the MLIR pass framework.</p>
<section id="pass-timing">
<h4>Pass Timing<a class="headerlink" href="#pass-timing" title="此标题的永久链接">¶</a></h4>
<p>The PassTiming instrumentation provides timing information about the execution
of passes and computation of analyses. This provides a quick glimpse into what
passes are taking the most time to execute, as well as how much of an effect a
pass has on the total execution time of the pipeline. Users can enable this
instrumentation directly on the PassManager via <code class="docutils literal notranslate"><span class="pre">enableTiming</span></code>. This
instrumentation is also made available in mlir-opt via the <code class="docutils literal notranslate"><span class="pre">-mlir-timing</span></code> flag.
The PassTiming instrumentation provides several different display modes for the
timing results, each of which is described below:</p>
<section id="list-display-mode">
<h5>List Display Mode<a class="headerlink" href="#list-display-mode" title="此标题的永久链接">¶</a></h5>
<p>In this mode, the results are displayed in a list sorted by total time with each
pass/analysis instance aggregated into one unique result. This view is useful
for getting an overview of what analyses/passes are taking the most time in a
pipeline. This display mode is available in mlir-opt via
<code class="docutils literal notranslate"><span class="pre">-mlir-timing-display=list</span></code>.</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>mlir-opt<span class="w"> </span>foo.mlir<span class="w"> </span>-mlir-disable-threading<span class="w"> </span>-pass-pipeline<span class="o">=</span><span class="s1">&#39;builtin.module(func.func(cse,canonicalize),convert-func-to-llvm)&#39;</span><span class="w"> </span>-mlir-timing<span class="w"> </span>-mlir-timing-display<span class="o">=</span><span class="nv">list</span>

<span class="o">===</span>-------------------------------------------------------------------------<span class="o">===</span>
<span class="w">                      </span>...<span class="w"> </span>Pass<span class="w"> </span>execution<span class="w"> </span>timing<span class="w"> </span>report<span class="w"> </span>...
<span class="o">===</span>-------------------------------------------------------------------------<span class="o">===</span>
<span class="w">  </span>Total<span class="w"> </span>Execution<span class="w"> </span>Time:<span class="w"> </span><span class="m">0</span>.0203<span class="w"> </span>seconds

<span class="w">   </span>---Wall<span class="w"> </span>Time---<span class="w">  </span>---<span class="w"> </span>Name<span class="w"> </span>---
<span class="w">   </span><span class="m">0</span>.0047<span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="m">55</span>.9%<span class="o">)</span><span class="w">  </span>Canonicalizer
<span class="w">   </span><span class="m">0</span>.0019<span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="m">22</span>.2%<span class="o">)</span><span class="w">  </span>VerifierPass
<span class="w">   </span><span class="m">0</span>.0016<span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="m">18</span>.5%<span class="o">)</span><span class="w">  </span>LLVMLoweringPass
<span class="w">   </span><span class="m">0</span>.0003<span class="w"> </span><span class="o">(</span><span class="w">  </span><span class="m">3</span>.4%<span class="o">)</span><span class="w">  </span>CSE
<span class="w">   </span><span class="m">0</span>.0002<span class="w"> </span><span class="o">(</span><span class="w">  </span><span class="m">1</span>.9%<span class="o">)</span><span class="w">  </span><span class="o">(</span>A<span class="o">)</span><span class="w"> </span>DominanceInfo
<span class="w">   </span><span class="m">0</span>.0084<span class="w"> </span><span class="o">(</span><span class="m">100</span>.0%<span class="o">)</span><span class="w">  </span>Total
</pre></div>
</div>
</section>
<section id="tree-display-mode">
<h5>Tree Display Mode<a class="headerlink" href="#tree-display-mode" title="此标题的永久链接">¶</a></h5>
<p>In this mode, the results are displayed in a nested pipeline view that mirrors
the internal pass pipeline that is being executed in the pass manager. This view
is useful for understanding specifically which parts of the pipeline are taking
the most time, and can also be used to identify when analyses are being
invalidated and recomputed. This is the default display mode.</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>mlir-opt<span class="w"> </span>foo.mlir<span class="w"> </span>-mlir-disable-threading<span class="w"> </span>-pass-pipeline<span class="o">=</span><span class="s1">&#39;builtin.module(func.func(cse,canonicalize),convert-func-to-llvm)&#39;</span><span class="w"> </span>-mlir-timing

<span class="o">===</span>-------------------------------------------------------------------------<span class="o">===</span>
<span class="w">                      </span>...<span class="w"> </span>Pass<span class="w"> </span>execution<span class="w"> </span>timing<span class="w"> </span>report<span class="w"> </span>...
<span class="o">===</span>-------------------------------------------------------------------------<span class="o">===</span>
<span class="w">  </span>Total<span class="w"> </span>Execution<span class="w"> </span>Time:<span class="w"> </span><span class="m">0</span>.0249<span class="w"> </span>seconds

<span class="w">   </span>---Wall<span class="w"> </span>Time---<span class="w">  </span>---<span class="w"> </span>Name<span class="w"> </span>---
<span class="w">   </span><span class="m">0</span>.0058<span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="m">70</span>.8%<span class="o">)</span><span class="w">  </span><span class="s1">&#39;func.func&#39;</span><span class="w"> </span>Pipeline
<span class="w">   </span><span class="m">0</span>.0004<span class="w"> </span><span class="o">(</span><span class="w">  </span><span class="m">4</span>.3%<span class="o">)</span><span class="w">    </span>CSE
<span class="w">   </span><span class="m">0</span>.0002<span class="w"> </span><span class="o">(</span><span class="w">  </span><span class="m">2</span>.6%<span class="o">)</span><span class="w">      </span><span class="o">(</span>A<span class="o">)</span><span class="w"> </span>DominanceInfo
<span class="w">   </span><span class="m">0</span>.0004<span class="w"> </span><span class="o">(</span><span class="w">  </span><span class="m">4</span>.8%<span class="o">)</span><span class="w">    </span>VerifierPass
<span class="w">   </span><span class="m">0</span>.0046<span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="m">55</span>.4%<span class="o">)</span><span class="w">    </span>Canonicalizer
<span class="w">   </span><span class="m">0</span>.0005<span class="w"> </span><span class="o">(</span><span class="w">  </span><span class="m">6</span>.2%<span class="o">)</span><span class="w">    </span>VerifierPass
<span class="w">   </span><span class="m">0</span>.0005<span class="w"> </span><span class="o">(</span><span class="w">  </span><span class="m">5</span>.8%<span class="o">)</span><span class="w">  </span>VerifierPass
<span class="w">   </span><span class="m">0</span>.0014<span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="m">17</span>.2%<span class="o">)</span><span class="w">  </span>LLVMLoweringPass
<span class="w">   </span><span class="m">0</span>.0005<span class="w"> </span><span class="o">(</span><span class="w">  </span><span class="m">6</span>.2%<span class="o">)</span><span class="w">  </span>VerifierPass
<span class="w">   </span><span class="m">0</span>.0082<span class="w"> </span><span class="o">(</span><span class="m">100</span>.0%<span class="o">)</span><span class="w">  </span>Total
</pre></div>
</div>
</section>
<section id="multi-threaded-pass-timing">
<h5>Multi-threaded Pass Timing<a class="headerlink" href="#multi-threaded-pass-timing" title="此标题的永久链接">¶</a></h5>
<p>When multi-threading is enabled in the pass manager the meaning of the display
slightly changes. First, a new timing column is added, <code class="docutils literal notranslate"><span class="pre">User</span> <span class="pre">Time</span></code>, that
displays the total time spent across all threads. Secondly, the <code class="docutils literal notranslate"><span class="pre">Wall</span> <span class="pre">Time</span></code>
column displays the longest individual time spent amongst all of the threads.
This means that the <code class="docutils literal notranslate"><span class="pre">Wall</span> <span class="pre">Time</span></code> column will continue to give an indicator on the
perceived time, or clock time, whereas the <code class="docutils literal notranslate"><span class="pre">User</span> <span class="pre">Time</span></code> will display the total
cpu time.</p>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>mlir-opt<span class="w"> </span>foo.mlir<span class="w"> </span>-pass-pipeline<span class="o">=</span><span class="s1">&#39;builtin.module(func.func(cse,canonicalize),convert-func-to-llvm)&#39;</span><span class="w">  </span>-mlir-timing

<span class="o">===</span>-------------------------------------------------------------------------<span class="o">===</span>
<span class="w">                      </span>...<span class="w"> </span>Pass<span class="w"> </span>execution<span class="w"> </span>timing<span class="w"> </span>report<span class="w"> </span>...
<span class="o">===</span>-------------------------------------------------------------------------<span class="o">===</span>
<span class="w">  </span>Total<span class="w"> </span>Execution<span class="w"> </span>Time:<span class="w"> </span><span class="m">0</span>.0078<span class="w"> </span>seconds

<span class="w">   </span>---User<span class="w"> </span>Time---<span class="w">   </span>---Wall<span class="w"> </span>Time---<span class="w">  </span>---<span class="w"> </span>Name<span class="w"> </span>---
<span class="w">   </span><span class="m">0</span>.0177<span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="m">88</span>.5%<span class="o">)</span><span class="w">     </span><span class="m">0</span>.0057<span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="m">71</span>.3%<span class="o">)</span><span class="w">  </span><span class="s1">&#39;func.func&#39;</span><span class="w"> </span>Pipeline
<span class="w">   </span><span class="m">0</span>.0044<span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="m">22</span>.0%<span class="o">)</span><span class="w">     </span><span class="m">0</span>.0015<span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="m">18</span>.9%<span class="o">)</span><span class="w">    </span>CSE
<span class="w">   </span><span class="m">0</span>.0029<span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="m">14</span>.5%<span class="o">)</span><span class="w">     </span><span class="m">0</span>.0012<span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="m">15</span>.2%<span class="o">)</span><span class="w">      </span><span class="o">(</span>A<span class="o">)</span><span class="w"> </span>DominanceInfo
<span class="w">   </span><span class="m">0</span>.0038<span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="m">18</span>.9%<span class="o">)</span><span class="w">     </span><span class="m">0</span>.0015<span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="m">18</span>.7%<span class="o">)</span><span class="w">    </span>VerifierPass
<span class="w">   </span><span class="m">0</span>.0089<span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="m">44</span>.6%<span class="o">)</span><span class="w">     </span><span class="m">0</span>.0025<span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="m">31</span>.1%<span class="o">)</span><span class="w">    </span>Canonicalizer
<span class="w">   </span><span class="m">0</span>.0006<span class="w"> </span><span class="o">(</span><span class="w">  </span><span class="m">3</span>.0%<span class="o">)</span><span class="w">     </span><span class="m">0</span>.0002<span class="w"> </span><span class="o">(</span><span class="w">  </span><span class="m">2</span>.6%<span class="o">)</span><span class="w">    </span>VerifierPass
<span class="w">   </span><span class="m">0</span>.0004<span class="w"> </span><span class="o">(</span><span class="w">  </span><span class="m">2</span>.2%<span class="o">)</span><span class="w">     </span><span class="m">0</span>.0004<span class="w"> </span><span class="o">(</span><span class="w">  </span><span class="m">5</span>.4%<span class="o">)</span><span class="w">  </span>VerifierPass
<span class="w">   </span><span class="m">0</span>.0013<span class="w"> </span><span class="o">(</span><span class="w">  </span><span class="m">6</span>.5%<span class="o">)</span><span class="w">     </span><span class="m">0</span>.0013<span class="w"> </span><span class="o">(</span><span class="w"> </span><span class="m">16</span>.3%<span class="o">)</span><span class="w">  </span>LLVMLoweringPass
<span class="w">   </span><span class="m">0</span>.0006<span class="w"> </span><span class="o">(</span><span class="w">  </span><span class="m">2</span>.8%<span class="o">)</span><span class="w">     </span><span class="m">0</span>.0006<span class="w"> </span><span class="o">(</span><span class="w">  </span><span class="m">7</span>.0%<span class="o">)</span><span class="w">  </span>VerifierPass
<span class="w">   </span><span class="m">0</span>.0200<span class="w"> </span><span class="o">(</span><span class="m">100</span>.0%<span class="o">)</span><span class="w">     </span><span class="m">0</span>.0081<span class="w"> </span><span class="o">(</span><span class="m">100</span>.0%<span class="o">)</span><span class="w">  </span>Total
</pre></div>
</div>
</section>
</section>
<section id="ir-printing">
<h4>IR Printing<a class="headerlink" href="#ir-printing" title="此标题的永久链接">¶</a></h4>
<p>When debugging it is often useful to dump the IR at various stages of a pass
pipeline. This is where the IR printing instrumentation comes into play. This
instrumentation allows for conditionally printing the IR before and after pass
execution by optionally filtering on the pass being executed. This
instrumentation can be added directly to the PassManager via the
<code class="docutils literal notranslate"><span class="pre">enableIRPrinting</span></code> method. <code class="docutils literal notranslate"><span class="pre">mlir-opt</span></code> provides a few useful flags for utilizing
this instrumentation:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mlir-print-ir-before=(comma-separated-pass-list)</span></code></p>
<ul>
<li><p>Print the IR before each of the passes provided within the pass list.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">mlir-print-ir-before-all</span></code></p>
<ul>
<li><p>Print the IR before every pass in the pipeline.</p></li>
</ul>
</li>
</ul>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>mlir-opt<span class="w"> </span>foo.mlir<span class="w"> </span>-pass-pipeline<span class="o">=</span><span class="s1">&#39;func.func(cse)&#39;</span><span class="w"> </span>-mlir-print-ir-before<span class="o">=</span>cse

***<span class="w"> </span>IR<span class="w"> </span>Dump<span class="w"> </span>Before<span class="w"> </span>CSE<span class="w"> </span>***
func.func<span class="w"> </span>@simple_constant<span class="o">()</span><span class="w"> </span>-&gt;<span class="w"> </span><span class="o">(</span>i32,<span class="w"> </span>i32<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">  </span>%c1_i32<span class="w"> </span><span class="o">=</span><span class="w"> </span>arith.constant<span class="w"> </span><span class="m">1</span><span class="w"> </span>:<span class="w"> </span>i32
<span class="w">  </span>%c1_i32_0<span class="w"> </span><span class="o">=</span><span class="w"> </span>arith.constant<span class="w"> </span><span class="m">1</span><span class="w"> </span>:<span class="w"> </span>i32
<span class="w">  </span><span class="k">return</span><span class="w"> </span>%c1_i32,<span class="w"> </span>%c1_i32_0<span class="w"> </span>:<span class="w"> </span>i32,<span class="w"> </span>i32
<span class="o">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mlir-print-ir-after=(comma-separated-pass-list)</span></code></p>
<ul>
<li><p>Print the IR after each of the passes provided within the pass list.</p></li>
</ul>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">mlir-print-ir-after-all</span></code></p>
<ul>
<li><p>Print the IR after every pass in the pipeline.</p></li>
</ul>
</li>
</ul>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>mlir-opt<span class="w"> </span>foo.mlir<span class="w"> </span>-pass-pipeline<span class="o">=</span><span class="s1">&#39;func.func(cse)&#39;</span><span class="w"> </span>-mlir-print-ir-after<span class="o">=</span>cse

***<span class="w"> </span>IR<span class="w"> </span>Dump<span class="w"> </span>After<span class="w"> </span>CSE<span class="w"> </span>***
func.func<span class="w"> </span>@simple_constant<span class="o">()</span><span class="w"> </span>-&gt;<span class="w"> </span><span class="o">(</span>i32,<span class="w"> </span>i32<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">  </span>%c1_i32<span class="w"> </span><span class="o">=</span><span class="w"> </span>arith.constant<span class="w"> </span><span class="m">1</span><span class="w"> </span>:<span class="w"> </span>i32
<span class="w">  </span><span class="k">return</span><span class="w"> </span>%c1_i32,<span class="w"> </span>%c1_i32<span class="w"> </span>:<span class="w"> </span>i32,<span class="w"> </span>i32
<span class="o">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mlir-print-ir-after-change</span></code></p>
<ul>
<li><p>Only print the IR after a pass if the pass mutated the IR. This helps to
reduce the number of IR dumps for “uninteresting” passes.</p></li>
<li><p>Note: Changes are detected by comparing a hash of the operation before
and after the pass. This adds additional run-time to compute the hash of
the IR, and in some rare cases may result in false-positives depending
on the collision rate of the hash algorithm used.</p></li>
<li><p>Note: This option should be used in unison with one of the other
‘mlir-print-ir-after’ options above, as this option alone does not enable
printing.</p></li>
</ul>
</li>
</ul>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>mlir-opt<span class="w"> </span>foo.mlir<span class="w"> </span>-pass-pipeline<span class="o">=</span><span class="s1">&#39;func.func(cse,cse)&#39;</span><span class="w"> </span>-mlir-print-ir-after<span class="o">=</span>cse<span class="w"> </span>-mlir-print-ir-after-change

***<span class="w"> </span>IR<span class="w"> </span>Dump<span class="w"> </span>After<span class="w"> </span>CSE<span class="w"> </span>***
func.func<span class="w"> </span>@simple_constant<span class="o">()</span><span class="w"> </span>-&gt;<span class="w"> </span><span class="o">(</span>i32,<span class="w"> </span>i32<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">  </span>%c1_i32<span class="w"> </span><span class="o">=</span><span class="w"> </span>arith.constant<span class="w"> </span><span class="m">1</span><span class="w"> </span>:<span class="w"> </span>i32
<span class="w">  </span><span class="k">return</span><span class="w"> </span>%c1_i32,<span class="w"> </span>%c1_i32<span class="w"> </span>:<span class="w"> </span>i32,<span class="w"> </span>i32
<span class="o">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mlir-print-ir-after-failure</span></code></p>
<ul>
<li><p>Only print IR after a pass failure.</p></li>
<li><p>This option should <em>not</em> be used with the other <code class="docutils literal notranslate"><span class="pre">mlir-print-ir-after</span></code> flags
above.</p></li>
</ul>
</li>
</ul>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>mlir-opt<span class="w"> </span>foo.mlir<span class="w"> </span>-pass-pipeline<span class="o">=</span><span class="s1">&#39;func.func(cse,bad-pass)&#39;</span><span class="w"> </span>-mlir-print-ir-after-failure

***<span class="w"> </span>IR<span class="w"> </span>Dump<span class="w"> </span>After<span class="w"> </span>BadPass<span class="w"> </span>Failed<span class="w"> </span>***
func.func<span class="w"> </span>@simple_constant<span class="o">()</span><span class="w"> </span>-&gt;<span class="w"> </span><span class="o">(</span>i32,<span class="w"> </span>i32<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">  </span>%c1_i32<span class="w"> </span><span class="o">=</span><span class="w"> </span>arith.constant<span class="w"> </span><span class="m">1</span><span class="w"> </span>:<span class="w"> </span>i32
<span class="w">  </span><span class="k">return</span><span class="w"> </span>%c1_i32,<span class="w"> </span>%c1_i32<span class="w"> </span>:<span class="w"> </span>i32,<span class="w"> </span>i32
<span class="o">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">mlir-print-ir-module-scope</span></code></p>
<ul>
<li><p>Always print the top-level module operation, regardless of pass type or
operation nesting level.</p></li>
<li><p>Note: Printing at module scope should only be used when multi-threading
is disabled(<code class="docutils literal notranslate"><span class="pre">-mlir-disable-threading</span></code>)</p></li>
</ul>
</li>
</ul>
<div class="highlight-shell notranslate"><div class="highlight"><pre><span></span>$<span class="w"> </span>mlir-opt<span class="w"> </span>foo.mlir<span class="w"> </span>-mlir-disable-threading<span class="w"> </span>-pass-pipeline<span class="o">=</span><span class="s1">&#39;func.func(cse)&#39;</span><span class="w"> </span>-mlir-print-ir-after<span class="o">=</span>cse<span class="w"> </span>-mlir-print-ir-module-scope

***<span class="w"> </span>IR<span class="w"> </span>Dump<span class="w"> </span>After<span class="w"> </span>CSE<span class="w"> </span>***<span class="w">  </span><span class="o">(</span><span class="s1">&#39;func.func&#39;</span><span class="w"> </span>operation:<span class="w"> </span>@bar<span class="o">)</span>
func.func<span class="w"> </span>@bar<span class="o">(</span>%arg0:<span class="w"> </span>f32,<span class="w"> </span>%arg1:<span class="w"> </span>f32<span class="o">)</span><span class="w"> </span>-&gt;<span class="w"> </span>f32<span class="w"> </span><span class="o">{</span>
<span class="w">  </span>...
<span class="o">}</span>

func.func<span class="w"> </span>@simple_constant<span class="o">()</span><span class="w"> </span>-&gt;<span class="w"> </span><span class="o">(</span>i32,<span class="w"> </span>i32<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">  </span>%c1_i32<span class="w"> </span><span class="o">=</span><span class="w"> </span>arith.constant<span class="w"> </span><span class="m">1</span><span class="w"> </span>:<span class="w"> </span>i32
<span class="w">  </span>%c1_i32_0<span class="w"> </span><span class="o">=</span><span class="w"> </span>arith.constant<span class="w"> </span><span class="m">1</span><span class="w"> </span>:<span class="w"> </span>i32
<span class="w">  </span><span class="k">return</span><span class="w"> </span>%c1_i32,<span class="w"> </span>%c1_i32_0<span class="w"> </span>:<span class="w"> </span>i32,<span class="w"> </span>i32
<span class="o">}</span>

***<span class="w"> </span>IR<span class="w"> </span>Dump<span class="w"> </span>After<span class="w"> </span>CSE<span class="w"> </span>***<span class="w">  </span><span class="o">(</span><span class="s1">&#39;func.func&#39;</span><span class="w"> </span>operation:<span class="w"> </span>@simple_constant<span class="o">)</span>
func.func<span class="w"> </span>@bar<span class="o">(</span>%arg0:<span class="w"> </span>f32,<span class="w"> </span>%arg1:<span class="w"> </span>f32<span class="o">)</span><span class="w"> </span>-&gt;<span class="w"> </span>f32<span class="w"> </span><span class="o">{</span>
<span class="w">  </span>...
<span class="o">}</span>

func.func<span class="w"> </span>@simple_constant<span class="o">()</span><span class="w"> </span>-&gt;<span class="w"> </span><span class="o">(</span>i32,<span class="w"> </span>i32<span class="o">)</span><span class="w"> </span><span class="o">{</span>
<span class="w">  </span>%c1_i32<span class="w"> </span><span class="o">=</span><span class="w"> </span>arith.constant<span class="w"> </span><span class="m">1</span><span class="w"> </span>:<span class="w"> </span>i32
<span class="w">  </span><span class="k">return</span><span class="w"> </span>%c1_i32,<span class="w"> </span>%c1_i32<span class="w"> </span>:<span class="w"> </span>i32,<span class="w"> </span>i32
<span class="o">}</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="crash-and-failure-reproduction">
<h2>Crash and Failure Reproduction<a class="headerlink" href="#crash-and-failure-reproduction" title="此标题的永久链接">¶</a></h2>
<p>The <a class="reference external" href="#pass-manager">pass manager</a> in MLIR contains a builtin mechanism to
generate reproducibles in the event of a crash, or a
<a class="reference external" href="#pass-failure">pass failure</a>. This functionality can be enabled via
<code class="docutils literal notranslate"><span class="pre">PassManager::enableCrashReproducerGeneration</span></code> or via the command line flag
<code class="docutils literal notranslate"><span class="pre">mlir-pass-pipeline-crash-reproducer</span></code>. In either case, an argument is provided that
corresponds to the output <code class="docutils literal notranslate"><span class="pre">.mlir</span></code> file name that the reproducible should be
written to. The reproducible contains the configuration of the pass manager that
was executing, as well as the initial IR before any passes were run. The reproducer
is stored within the assembly format as an external resource. A potential reproducible
may have the form:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>module {
  func.func @foo() {
    ...
  }
}

{-#
  external_resources: {
    mlir_reproducer: {
      pipeline: &quot;builtin.module(func.func(cse,canonicalize),inline)&quot;,
      disable_threading: true,
      verify_each: true
    }
  }
#-}
</pre></div>
</div>
<p>The configuration dumped can be passed to <code class="docutils literal notranslate"><span class="pre">mlir-opt</span></code>. This will result in
parsing the configuration of the reproducer and adjusting the necessary opt
state, e.g. configuring the pass manager, context, etc.</p>
<p>Beyond specifying a filename, one can also register a <code class="docutils literal notranslate"><span class="pre">ReproducerStreamFactory</span></code>
function that would be invoked in the case of a crash and the reproducer written
to its stream.</p>
<section id="local-reproducer-generation">
<h3>Local Reproducer Generation<a class="headerlink" href="#local-reproducer-generation" title="此标题的永久链接">¶</a></h3>
<p>An additional flag may be passed to
<code class="docutils literal notranslate"><span class="pre">PassManager::enableCrashReproducerGeneration</span></code>, and specified via
<code class="docutils literal notranslate"><span class="pre">mlir-pass-pipeline-local-reproducer</span></code> on the command line, that signals that the pass
manager should attempt to generate a “local” reproducer. This will attempt to
generate a reproducer containing IR right before the pass that fails. This is
useful for situations where the crash is known to be within a specific pass, or
when the original input relies on components (like dialects or passes) that may
not always be available.</p>
<p>Note: Local reproducer generation requires that multi-threading is
disabled(<code class="docutils literal notranslate"><span class="pre">-mlir-disable-threading</span></code>)</p>
<p>For example, if the failure in the previous example came from the <code class="docutils literal notranslate"><span class="pre">canonicalize</span></code> pass,
the following reproducer would be generated:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span>module {
  func.func @foo() {
    ...
  }
}

{-#
  external_resources: {
    mlir_reproducer: {
      pipeline: &quot;builtin.module(func.func(canonicalize))&quot;,
      disable_threading: true,
      verify_each: true
    }
  }
#-}
</pre></div>
</div>
</section>
</section>
</section>


          </div>
          <div class="page-nav">
            <div class="inner"><ul class="page-nav">
</ul><div class="footer" role="contentinfo">
      &#169; 版权所有 2023, yaoyue123.
    <br>
    Created using <a href="http://sphinx-doc.org/">Sphinx</a> 6.1.3 with <a href="https://github.com/schettino72/sphinx_press_theme">Press Theme</a> 0.8.0.
</div>
            </div>
          </div>
      </page>
    </div></div>
    
    
  </body>
</html>